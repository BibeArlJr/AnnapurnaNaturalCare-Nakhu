"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-datepicker";
exports.ids = ["vendor-chunks/react-datepicker"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-datepicker/dist/index.es.js":
/*!********************************************************!*\
  !*** ./node_modules/react-datepicker/dist/index.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CalendarContainer: () => (/* binding */ CalendarContainer),\n/* harmony export */   DatePicker: () => (/* binding */ DatePicker),\n/* harmony export */   \"default\": () => (/* binding */ DatePicker),\n/* harmony export */   getDefaultLocale: () => (/* binding */ getDefaultLocale),\n/* harmony export */   registerLocale: () => (/* binding */ registerLocale),\n/* harmony export */   setDefaultLocale: () => (/* binding */ setDefaultLocale)\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/parseISO.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/toDate.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/parse.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isValid.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/format.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setHours.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setMinutes.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setSeconds.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getISOWeek.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfWeek.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfWeek.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isEqual.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isWithinInterval.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarDays.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getHours.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getMinutes.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getSeconds.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subMonths.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarMonths.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addMonths.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subQuarters.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarQuarters.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addQuarters.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subYears.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarYears.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addYears.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/min.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/max.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isDate.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addHours.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addMinutes.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addSeconds.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isAfter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isBefore.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getDate.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addDays.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addWeeks.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getTime.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInDays.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subWeeks.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subDays.js\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n/*!\n  react-datepicker v9.0.0\n  https://github.com/Hacker0x01/react-datepicker\n  Released under the MIT License.\n*/\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nvar CalendarContainer = function (_a) {\n    var _b = _a.showTimeSelectOnly, showTimeSelectOnly = _b === void 0 ? false : _b, _c = _a.showTime, showTime = _c === void 0 ? false : _c, className = _a.className, children = _a.children, inline = _a.inline;\n    var ariaLabel = showTimeSelectOnly\n        ? \"Choose Time\"\n        : \"Choose Date\".concat(showTime ? \" and Time\" : \"\");\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: className, \"aria-label\": ariaLabel, role: inline ? undefined : \"dialog\", \"aria-modal\": inline ? undefined : \"true\" }, children));\n};\n\nvar useDetectClickOutside = function (onClickOutside, ignoreClass) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var onClickOutsideRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(onClickOutside);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        onClickOutsideRef.current = onClickOutside;\n    }, [onClickOutside]);\n    var handleClickOutside = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (event) {\n        var _a;\n        var target = (event.composed &&\n            event.composedPath &&\n            event\n                .composedPath()\n                .find(function (eventTarget) { return eventTarget instanceof Node; })) ||\n            event.target;\n        if (ref.current && !ref.current.contains(target)) {\n            if (!(ignoreClass &&\n                target instanceof HTMLElement &&\n                target.classList.contains(ignoreClass))) {\n                (_a = onClickOutsideRef.current) === null || _a === void 0 ? void 0 : _a.call(onClickOutsideRef, event);\n            }\n        }\n    }, [ignoreClass]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        document.addEventListener(\"mousedown\", handleClickOutside);\n        return function () {\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n        };\n    }, [handleClickOutside]);\n    return ref;\n};\nvar ClickOutsideWrapper = function (_a) {\n    var children = _a.children, onClickOutside = _a.onClickOutside, className = _a.className, containerRef = _a.containerRef, style = _a.style, ignoreClass = _a.ignoreClass;\n    var detectRef = useDetectClickOutside(onClickOutside, ignoreClass);\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: className, style: style, ref: function (node) {\n            detectRef.current = node;\n            if (containerRef) {\n                containerRef.current = node;\n            }\n        } }, children));\n};\n\n// Cache for the date-fns-tz module\nvar dateFnsTz = null;\nvar dateFnsTzLoadAttempted = false;\n/**\n * Attempts to load date-fns-tz module.\n * Returns null if the module is not installed.\n */\nfunction getDateFnsTz() {\n    if (dateFnsTzLoadAttempted) {\n        return dateFnsTz;\n    }\n    dateFnsTzLoadAttempted = true;\n    try {\n        // Dynamic require for date-fns-tz\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        dateFnsTz = __webpack_require__(/*! date-fns-tz */ \"(ssr)/./node_modules/date-fns-tz/dist/cjs/index.js\");\n    }\n    catch (_a) {\n        /* istanbul ignore next - only executes when date-fns-tz is not installed */\n        dateFnsTz = null;\n    }\n    return dateFnsTz;\n}\n/**\n * Converts a date to the specified timezone.\n * If no timezone is specified or date-fns-tz is not installed, returns the original date.\n *\n * @param date - The date to convert\n * @param timeZone - The IANA timezone identifier (e.g., \"America/New_York\", \"UTC\")\n * @returns The date in the specified timezone\n */\nfunction toZonedTime(date, timeZone) {\n    if (!timeZone) {\n        return date;\n    }\n    var tz = getDateFnsTz();\n    if (!tz) {\n        if (true) {\n            console.warn('react-datepicker: timeZone prop requires \"date-fns-tz\" package. ' +\n                \"Please install it: npm install date-fns-tz\");\n        }\n        return date;\n    }\n    return tz.toZonedTime(date, timeZone);\n}\n/**\n * Converts a date from the specified timezone to UTC.\n * If no timezone is specified or date-fns-tz is not installed, returns the original date.\n *\n * @param date - The date in the specified timezone\n * @param timeZone - The IANA timezone identifier (e.g., \"America/New_York\", \"UTC\")\n * @returns The date in UTC\n */\nfunction fromZonedTime(date, timeZone) {\n    if (!timeZone) {\n        return date;\n    }\n    var tz = getDateFnsTz();\n    if (!tz) {\n        if (true) {\n            console.warn('react-datepicker: timeZone prop requires \"date-fns-tz\" package. ' +\n                \"Please install it: npm install date-fns-tz\");\n        }\n        return date;\n    }\n    return tz.fromZonedTime(date, timeZone);\n}\nvar KeyType;\n(function (KeyType) {\n    KeyType[\"ArrowUp\"] = \"ArrowUp\";\n    KeyType[\"ArrowDown\"] = \"ArrowDown\";\n    KeyType[\"ArrowLeft\"] = \"ArrowLeft\";\n    KeyType[\"ArrowRight\"] = \"ArrowRight\";\n    KeyType[\"PageUp\"] = \"PageUp\";\n    KeyType[\"PageDown\"] = \"PageDown\";\n    KeyType[\"Home\"] = \"Home\";\n    KeyType[\"End\"] = \"End\";\n    KeyType[\"Enter\"] = \"Enter\";\n    KeyType[\"Space\"] = \" \";\n    KeyType[\"Tab\"] = \"Tab\";\n    KeyType[\"Escape\"] = \"Escape\";\n    KeyType[\"Backspace\"] = \"Backspace\";\n    KeyType[\"X\"] = \"x\";\n})(KeyType || (KeyType = {}));\nfunction getLocaleScope() {\n    // Use this cast to avoid messing with users globalThis (like window) and the rest of keys in the globalThis object we don't care about\n    var scope = (typeof window !== \"undefined\"\n        ? window\n        : globalThis);\n    return scope;\n}\nvar DEFAULT_YEAR_ITEM_NUMBER = 12;\n// ** Date Constructors **\nfunction newDate(value) {\n    if (value == null) {\n        return new Date();\n    }\n    var d = typeof value === \"string\" ? (0,date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(value) : (0,date_fns__WEBPACK_IMPORTED_MODULE_4__.toDate)(value);\n    return isValid(d) ? d : new Date();\n}\n/**\n * Parses a date.\n *\n * @param value - The string representing the Date in a parsable form, e.g., ISO 1861\n * @param dateFormat - The date format.\n * @param locale - The locale.\n * @param strictParsing - The strict parsing flag.\n * @param refDate - The base date to be passed to date-fns parse() function.\n * @returns - The parsed date or null.\n */\nfunction parseDate(value, dateFormat, locale, strictParsing, refDate) {\n    if (refDate === void 0) { refDate = newDate(); }\n    var localeObject = getLocaleObject(locale) || getLocaleObject(getDefaultLocale());\n    var formats = Array.isArray(dateFormat) ? dateFormat : [dateFormat];\n    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n        var format_1 = formats_1[_i];\n        var parsedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__.parse)(value, format_1, refDate, {\n            locale: localeObject,\n            useAdditionalWeekYearTokens: true,\n            useAdditionalDayOfYearTokens: true,\n        });\n        if (isValid(parsedDate) &&\n            (!strictParsing || value === formatDate(parsedDate, format_1, locale))) {\n            return parsedDate;\n        }\n    }\n    return null;\n}\n/**\n * Parses a partial date string for calendar navigation purposes.\n * Unlike parseDate, this function attempts to extract whatever date\n * information is available (year, month) from a partial input,\n * returning a date suitable for navigating the calendar view.\n *\n * @param value - The date string to parse.\n * @param refDate - The reference date to use for missing components.\n * @returns - A date for navigation or null if no date info could be extracted.\n */\nfunction parseDateForNavigation(value, refDate) {\n    if (refDate === void 0) { refDate = newDate(); }\n    if (!value)\n        return null;\n    // Try to extract a 4-digit year from the input\n    var yearMatch = value.match(/\\b(1\\d{3}|2\\d{3})\\b/);\n    if (!yearMatch || !yearMatch[1])\n        return null;\n    var year = parseInt(yearMatch[1], 10);\n    // Try to extract a month (1-12) from the input\n    // Look for patterns like \"03/\", \"/03\", \"03-\", \"-03\" or standalone \"03\" at start\n    var monthMatch = value.match(/(?:^|[/\\-\\s])?(0?[1-9]|1[0-2])(?:[/\\-\\s]|$)/);\n    var month = monthMatch && monthMatch[1]\n        ? parseInt(monthMatch[1], 10) - 1\n        : refDate.getMonth();\n    // Return a date with the extracted year and month, using day 1\n    return new Date(year, month, 1);\n}\n/**\n * Checks if a given date is a valid Date object.\n * @param date - The date to be checked.\n * @returns A boolean value indicating whether the date is valid.\n */\nfunction isValid(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_6__.isValid)(date);\n}\n// ** Date Formatting **\n/**\n * Formats a date.\n *\n * @param date - The date.\n * @param formatStr - The format string.\n * @param locale - The locale.\n * @returns - The formatted date.\n */\nfunction formatDate(date, formatStr, locale) {\n    if (locale === \"en\") {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.format)(date, formatStr, {\n            useAdditionalWeekYearTokens: true,\n            useAdditionalDayOfYearTokens: true,\n        });\n    }\n    var localeObj = locale ? getLocaleObject(locale) : undefined;\n    if (locale && !localeObj) {\n        console.warn(\"A locale object was not found for the provided string [\\\"\".concat(locale, \"\\\"].\"));\n    }\n    localeObj = localeObj || getLocaleObject(getDefaultLocale());\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.format)(date, formatStr, {\n        locale: localeObj,\n        useAdditionalWeekYearTokens: true,\n        useAdditionalDayOfYearTokens: true,\n    });\n}\n/**\n * Safely formats a date.\n *\n * @param date - The date.\n * @param options - An object containing the dateFormat and locale.\n * @returns - The formatted date or an empty string.\n */\nfunction safeDateFormat(date, _a) {\n    var dateFormat = _a.dateFormat, locale = _a.locale;\n    var formatStr = (Array.isArray(dateFormat) && dateFormat.length > 0\n        ? dateFormat[0]\n        : dateFormat); // Cast to string because it's impossible to get `string | string[] | undefined` here and typescript doesn't know that\n    return (date && formatDate(date, formatStr, locale)) || \"\";\n}\n/**\n * Used as a delimiter to separate two dates when formatting a date range\n */\nvar DATE_RANGE_SEPARATOR = \" - \";\n/**\n * Safely formats a date range.\n *\n * @param startDate - The start date.\n * @param endDate - The end date.\n * @param props - The props.\n * @returns - The formatted date range or an empty string.\n */\nfunction safeDateRangeFormat(startDate, endDate, props) {\n    if (!startDate && !endDate) {\n        return \"\";\n    }\n    var formattedStartDate = startDate ? safeDateFormat(startDate, props) : \"\";\n    var formattedEndDate = endDate ? safeDateFormat(endDate, props) : \"\";\n    var dateRangeSeparator = props.rangeSeparator || DATE_RANGE_SEPARATOR;\n    return \"\".concat(formattedStartDate).concat(dateRangeSeparator).concat(formattedEndDate);\n}\n/**\n * Safely formats multiple dates.\n *\n * @param dates - The dates.\n * @param props - The props.\n * @returns - The formatted dates or an empty string.\n */\nfunction safeMultipleDatesFormat(dates, props) {\n    if (!(dates === null || dates === void 0 ? void 0 : dates.length)) {\n        return \"\";\n    }\n    var formattedFirstDate = dates[0] ? safeDateFormat(dates[0], props) : \"\";\n    if (dates.length === 1) {\n        return formattedFirstDate;\n    }\n    if (dates.length === 2 && dates[1]) {\n        var formattedSecondDate = safeDateFormat(dates[1], props);\n        return \"\".concat(formattedFirstDate, \", \").concat(formattedSecondDate);\n    }\n    var extraDatesCount = dates.length - 1;\n    return \"\".concat(formattedFirstDate, \" (+\").concat(extraDatesCount, \")\");\n}\n// ** Date Setters **\n/**\n * Sets the time for a given date.\n *\n * @param date - The date.\n * @param time - An object containing the hour, minute, and second.\n * @returns - The date with the time set.\n */\nfunction setTime(date, _a) {\n    var _b = _a.hour, hour = _b === void 0 ? 0 : _b, _c = _a.minute, minute = _c === void 0 ? 0 : _c, _d = _a.second, second = _d === void 0 ? 0 : _d;\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_8__.setHours)((0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setMinutes)((0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setSeconds)(date, second), minute), hour);\n}\n/**\n * Gets the week of the year for a given date.\n *\n * @param date - The date.\n * @returns - The week of the year.\n */\nfunction getWeek(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_11__.getISOWeek)(date);\n}\n/**\n * Gets the day of the week code for a given day.\n *\n * @param day - The day.\n * @param locale - The locale.\n * @returns - The day of the week code.\n */\nfunction getDayOfWeekCode(day, locale) {\n    return formatDate(day, \"ddd\", locale);\n}\n// *** Start of ***\n/**\n * Gets the start of the day for a given date.\n *\n * @param date - The date.\n * @returns - The start of the day.\n */\nfunction getStartOfDay(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_12__.startOfDay)(date);\n}\n/**\n * Gets the start of the week for a given date.\n *\n * @param date - The date.\n * @param locale - The locale.\n * @param calendarStartDay - The day the calendar starts on.\n * @returns - The start of the week.\n */\nfunction getStartOfWeek(date, locale, calendarStartDay) {\n    var localeObj = locale\n        ? getLocaleObject(locale)\n        : getLocaleObject(getDefaultLocale());\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_13__.startOfWeek)(date, {\n        locale: localeObj,\n        weekStartsOn: calendarStartDay,\n    });\n}\n/**\n * Gets the start of the month for a given date.\n *\n * @param date - The date.\n * @returns - The start of the month.\n */\nfunction getStartOfMonth(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_14__.startOfMonth)(date);\n}\n/**\n * Gets the start of the year for a given date.\n *\n * @param date - The date.\n * @returns - The start of the year.\n */\nfunction getStartOfYear(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_15__.startOfYear)(date);\n}\n/**\n * Gets the start of the quarter for a given date.\n *\n * @param date - The date.\n * @returns - The start of the quarter.\n */\nfunction getStartOfQuarter(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_16__.startOfQuarter)(date);\n}\n/**\n * Gets the start of today.\n *\n * @returns - The start of today.\n */\nfunction getStartOfToday() {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_12__.startOfDay)(newDate());\n}\n// *** End of ***\n/**\n * Gets the end of the day for a given date.\n *\n * @param date - The date.\n * @returns - The end of the day.\n */\nfunction getEndOfDay(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_17__.endOfDay)(date);\n}\n/**\n * Gets the end of the week for a given date.\n *\n * @param date - The date.\n * @returns - The end of the week.\n */\nfunction getEndOfWeek(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_18__.endOfWeek)(date);\n}\n/**\n * Gets the end of the month for a given date.\n *\n * @param date - The date.\n * @returns - The end of the month.\n */\nfunction getEndOfMonth(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_19__.endOfMonth)(date);\n}\n/**\n * Checks if two dates are in the same year.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are in the same year, false otherwise.\n */\nfunction isSameYear(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_20__.isSameYear)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are in the same month.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are in the same month, false otherwise.\n */\nfunction isSameMonth(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_21__.isSameMonth)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are in the same quarter.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are in the same quarter, false otherwise.\n */\nfunction isSameQuarter(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_22__.isSameQuarter)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are on the same day.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are on the same day, false otherwise.\n */\nfunction isSameDay(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_23__.isSameDay)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are equal.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are equal, false otherwise.\n */\nfunction isEqual(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_24__.isEqual)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if a day is within a date range.\n *\n * @param day - The day to check.\n * @param startDate - The start date of the range.\n * @param endDate - The end date of the range.\n * @returns - True if the day is within the range, false otherwise.\n */\nfunction isDayInRange(day, startDate, endDate) {\n    var valid;\n    var start = (0,date_fns__WEBPACK_IMPORTED_MODULE_12__.startOfDay)(startDate);\n    var end = (0,date_fns__WEBPACK_IMPORTED_MODULE_17__.endOfDay)(endDate);\n    try {\n        valid = (0,date_fns__WEBPACK_IMPORTED_MODULE_25__.isWithinInterval)(day, { start: start, end: end });\n    }\n    catch (err) {\n        valid = false;\n    }\n    return valid;\n}\n// ** Date Localization **\n/**\n * Registers a locale.\n *\n * @param localeName - The name of the locale.\n * @param localeData - The data of the locale.\n */\nfunction registerLocale(localeName, localeData) {\n    var scope = getLocaleScope();\n    if (!scope.__localeData__) {\n        scope.__localeData__ = {};\n    }\n    scope.__localeData__[localeName] = localeData;\n}\n/**\n * Sets the default locale.\n *\n * @param localeName - The name of the locale.\n */\nfunction setDefaultLocale(localeName) {\n    var scope = getLocaleScope();\n    scope.__localeId__ = localeName;\n}\n/**\n * Gets the default locale.\n *\n * @returns - The default locale.\n */\nfunction getDefaultLocale() {\n    var scope = getLocaleScope();\n    return scope.__localeId__;\n}\n/**\n * Gets the locale object.\n *\n * @param localeSpec - The locale specification.\n * @returns - The locale object.\n */\nfunction getLocaleObject(localeSpec) {\n    if (typeof localeSpec === \"string\") {\n        // Treat it as a locale name registered by registerLocale\n        var scope = getLocaleScope();\n        // Null was replaced with undefined to avoid type coercion\n        return scope.__localeData__ ? scope.__localeData__[localeSpec] : undefined;\n    }\n    else {\n        // Treat it as a raw date-fns locale object\n        return localeSpec;\n    }\n}\n/**\n * Formats the weekday in a given locale.\n *\n * @param date - The date to format.\n * @param formatFunc - The formatting function.\n * @param locale - The locale to use for formatting.\n * @returns - The formatted weekday.\n */\nfunction getFormattedWeekdayInLocale(date, formatFunc, locale) {\n    return formatFunc(formatDate(date, \"EEEE\", locale));\n}\n/**\n * Gets the minimum weekday in a given locale.\n *\n * @param date - The date to format.\n * @param locale - The locale to use for formatting.\n * @returns - The minimum weekday.\n */\nfunction getWeekdayMinInLocale(date, locale) {\n    return formatDate(date, \"EEEEEE\", locale);\n}\n/**\n * Gets the short weekday in a given locale.\n *\n * @param date - The date to format.\n * @param locale - The locale to use for formatting.\n * @returns - The short weekday.\n */\nfunction getWeekdayShortInLocale(date, locale) {\n    return formatDate(date, \"EEE\", locale);\n}\n/**\n * Gets the month in a given locale.\n *\n * @param month - The month to format.\n * @param locale - The locale to use for formatting.\n * @returns - The month.\n */\nfunction getMonthInLocale(month, locale) {\n    return formatDate((0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(newDate(), month), \"LLLL\", locale);\n}\n/**\n * Gets the short month in a given locale.\n *\n * @param month - The month to format.\n * @param locale - The locale to use for formatting.\n * @returns - The short month.\n */\nfunction getMonthShortInLocale(month, locale) {\n    return formatDate((0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(newDate(), month), \"LLL\", locale);\n}\n/**\n * Gets the short quarter in a given locale.\n *\n * @param quarter - The quarter to format.\n * @param locale - The locale to use for formatting.\n * @returns - The short quarter.\n */\nfunction getQuarterShortInLocale(quarter, locale) {\n    return formatDate((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setQuarter)(newDate(), quarter), \"QQQ\", locale);\n}\n/**\n * Checks if a day is disabled.\n *\n * @param day - The day to check.\n * @param options - The options to consider when checking.\n * @returns - Returns true if the day is disabled, false otherwise.\n */\nfunction isDayDisabled(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, excludeDateIntervals = _b.excludeDateIntervals, includeDates = _b.includeDates, includeDateIntervals = _b.includeDateIntervals, filterDate = _b.filterDate, disabled = _b.disabled;\n    if (disabled) {\n        return true;\n    }\n    return (isOutOfBounds(day, { minDate: minDate, maxDate: maxDate }) ||\n        (excludeDates &&\n            excludeDates.some(function (excludeDate) {\n                if (excludeDate instanceof Date) {\n                    return isSameDay(day, excludeDate);\n                }\n                else {\n                    return isSameDay(day, excludeDate.date);\n                }\n            })) ||\n        (excludeDateIntervals &&\n            excludeDateIntervals.some(function (_a) {\n                var start = _a.start, end = _a.end;\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_25__.isWithinInterval)(day, { start: start, end: end });\n            })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) { return isSameDay(day, includeDate); })) ||\n        (includeDateIntervals &&\n            !includeDateIntervals.some(function (_a) {\n                var start = _a.start, end = _a.end;\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_25__.isWithinInterval)(day, { start: start, end: end });\n            })) ||\n        (filterDate && !filterDate(newDate(day))) ||\n        false);\n}\n/**\n * Checks if a day is excluded.\n *\n * @param day - The day to check.\n * @param options - The options to consider when checking.\n * @returns - Returns true if the day is excluded, false otherwise.\n */\nfunction isDayExcluded(day, _a) {\n    var _b = _a === void 0 ? {} : _a, excludeDates = _b.excludeDates, excludeDateIntervals = _b.excludeDateIntervals;\n    if (excludeDateIntervals && excludeDateIntervals.length > 0) {\n        return excludeDateIntervals.some(function (_a) {\n            var start = _a.start, end = _a.end;\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_25__.isWithinInterval)(day, { start: start, end: end });\n        });\n    }\n    return ((excludeDates &&\n        excludeDates.some(function (excludeDate) {\n            var _a;\n            if (excludeDate instanceof Date) {\n                return isSameDay(day, excludeDate);\n            }\n            else {\n                return isSameDay(day, (_a = excludeDate.date) !== null && _a !== void 0 ? _a : new Date());\n            }\n        })) ||\n        false);\n}\nfunction isMonthDisabled(month, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate;\n    return (isOutOfBounds(month, {\n        minDate: minDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_14__.startOfMonth)(minDate) : undefined,\n        maxDate: maxDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_19__.endOfMonth)(maxDate) : undefined,\n    }) ||\n        (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function (excludeDate) {\n            return isSameMonth(month, excludeDate instanceof Date ? excludeDate : excludeDate.date);\n        })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) { return isSameMonth(month, includeDate); })) ||\n        (filterDate && !filterDate(newDate(month))) ||\n        false);\n}\nfunction isMonthInRange(startDate, endDate, m, day) {\n    var startDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(startDate);\n    var startDateMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(startDate);\n    var endDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(endDate);\n    var endDateMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(endDate);\n    var dayYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(day);\n    if (startDateYear === endDateYear && startDateYear === dayYear) {\n        return startDateMonth <= m && m <= endDateMonth;\n    }\n    else if (startDateYear < endDateYear) {\n        return ((dayYear === startDateYear && startDateMonth <= m) ||\n            (dayYear === endDateYear && endDateMonth >= m) ||\n            (dayYear < endDateYear && dayYear > startDateYear));\n    }\n    return false;\n}\n/**\n * To check if a date's month and year are disabled/excluded\n * @param date Date to check\n * @returns {boolean} true if month and year are disabled/excluded, false otherwise\n */\nfunction isMonthYearDisabled(date, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates;\n    return (isOutOfBounds(date, { minDate: minDate, maxDate: maxDate }) ||\n        (excludeDates &&\n            excludeDates.some(function (excludedDate) {\n                return isSameMonth(excludedDate instanceof Date ? excludedDate : excludedDate.date, date);\n            })) ||\n        (includeDates &&\n            !includeDates.some(function (includedDate) { return isSameMonth(includedDate, date); })) ||\n        false);\n}\nfunction isQuarterDisabled(quarter, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate, disabled = _b.disabled;\n    if (disabled) {\n        return true;\n    }\n    return (isOutOfBounds(quarter, { minDate: minDate, maxDate: maxDate }) ||\n        (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function (excludeDate) {\n            return isSameQuarter(quarter, excludeDate instanceof Date ? excludeDate : excludeDate.date);\n        })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) {\n                return isSameQuarter(quarter, includeDate);\n            })) ||\n        (filterDate && !filterDate(newDate(quarter))) ||\n        false);\n}\nfunction isYearInRange(year, start, end) {\n    if (!start || !end)\n        return false;\n    if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_6__.isValid)(start) || !(0,date_fns__WEBPACK_IMPORTED_MODULE_6__.isValid)(end))\n        return false;\n    var startYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(start);\n    var endYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(end);\n    return startYear <= year && endYear >= year;\n}\nfunction isYearDisabled(year, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate, disabled = _b.disabled;\n    if (disabled) {\n        return true;\n    }\n    var date = new Date(year, 0, 1);\n    return (isOutOfBounds(date, {\n        minDate: minDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_15__.startOfYear)(minDate) : undefined,\n        maxDate: maxDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.endOfYear)(maxDate) : undefined,\n    }) ||\n        (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function (excludeDate) {\n            return isSameYear(date, excludeDate instanceof Date ? excludeDate : excludeDate.date);\n        })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) { return isSameYear(date, includeDate); })) ||\n        (filterDate && !filterDate(newDate(date))) ||\n        false);\n}\nfunction isQuarterInRange(startDate, endDate, q, day) {\n    var startDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(startDate);\n    var startDateQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.getQuarter)(startDate);\n    var endDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(endDate);\n    var endDateQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.getQuarter)(endDate);\n    var dayYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(day);\n    if (startDateYear === endDateYear && startDateYear === dayYear) {\n        return startDateQuarter <= q && q <= endDateQuarter;\n    }\n    else if (startDateYear < endDateYear) {\n        return ((dayYear === startDateYear && startDateQuarter <= q) ||\n            (dayYear === endDateYear && endDateQuarter >= q) ||\n            (dayYear < endDateYear && dayYear > startDateYear));\n    }\n    return false;\n}\nfunction isOutOfBounds(day, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, minDate = _c.minDate, maxDate = _c.maxDate;\n    return ((_b = ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.differenceInCalendarDays)(day, minDate) < 0) ||\n        (maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.differenceInCalendarDays)(day, maxDate) > 0))) !== null && _b !== void 0 ? _b : false);\n}\nfunction isTimeInList(time, times) {\n    return times.some(function (listTime) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(listTime) === (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time) &&\n            (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(listTime) === (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time) &&\n            (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(listTime) === (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(time);\n    });\n}\nfunction isTimeDisabled(time, _a) {\n    var _b = _a === void 0 ? {} : _a, excludeTimes = _b.excludeTimes, includeTimes = _b.includeTimes, filterTime = _b.filterTime;\n    return ((excludeTimes && isTimeInList(time, excludeTimes)) ||\n        (includeTimes && !isTimeInList(time, includeTimes)) ||\n        (filterTime && !filterTime(time)) ||\n        false);\n}\nfunction isTimeInDisabledRange(time, _a) {\n    var minTime = _a.minTime, maxTime = _a.maxTime;\n    if (!minTime || !maxTime) {\n        throw new Error(\"Both minTime and maxTime props required\");\n    }\n    var baseTime = newDate();\n    baseTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__.setHours)(baseTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time));\n    baseTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setMinutes)(baseTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time));\n    baseTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setSeconds)(baseTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(time));\n    var min = newDate();\n    min = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__.setHours)(min, (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(minTime));\n    min = (0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setMinutes)(min, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(minTime));\n    min = (0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setSeconds)(min, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(minTime));\n    var max = newDate();\n    max = (0,date_fns__WEBPACK_IMPORTED_MODULE_8__.setHours)(max, (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(maxTime));\n    max = (0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setMinutes)(max, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(maxTime));\n    max = (0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setSeconds)(max, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(maxTime));\n    var valid;\n    try {\n        valid = !(0,date_fns__WEBPACK_IMPORTED_MODULE_25__.isWithinInterval)(baseTime, { start: min, end: max });\n    }\n    catch (err) {\n        /* istanbul ignore next - date-fns historically threw on invalid intervals */\n        valid = false;\n    }\n    return valid;\n}\nfunction monthDisabledBefore(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, includeDates = _b.includeDates;\n    var previousMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.subMonths)(day, 1);\n    return ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.differenceInCalendarMonths)(minDate, previousMonth) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.differenceInCalendarMonths)(includeDate, previousMonth) > 0;\n            })) ||\n        false);\n}\nfunction monthDisabledAfter(day, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, includeDates = _b.includeDates;\n    var nextMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(day, 1);\n    return ((maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.differenceInCalendarMonths)(nextMonth, maxDate) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.differenceInCalendarMonths)(nextMonth, includeDate) > 0; })) ||\n        false);\n}\nfunction quarterDisabledBefore(date, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, includeDates = _b.includeDates;\n    var firstDateOfYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_15__.startOfYear)(date);\n    var previousQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.subQuarters)(firstDateOfYear, 1);\n    return ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_40__.differenceInCalendarQuarters)(minDate, previousQuarter) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_40__.differenceInCalendarQuarters)(includeDate, previousQuarter) > 0;\n            })) ||\n        false);\n}\nfunction quarterDisabledAfter(date, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, includeDates = _b.includeDates;\n    var lastDateOfYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.endOfYear)(date);\n    var nextQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_41__.addQuarters)(lastDateOfYear, 1);\n    return ((maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_40__.differenceInCalendarQuarters)(nextQuarter, maxDate) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_40__.differenceInCalendarQuarters)(nextQuarter, includeDate) > 0;\n            })) ||\n        false);\n}\nfunction yearDisabledBefore(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, includeDates = _b.includeDates;\n    var previousYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_42__.subYears)(day, 1);\n    return ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.differenceInCalendarYears)(minDate, previousYear) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.differenceInCalendarYears)(includeDate, previousYear) > 0;\n            })) ||\n        false);\n}\nfunction yearsDisabledBefore(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : _c;\n    var previousYear = getStartOfYear((0,date_fns__WEBPACK_IMPORTED_MODULE_42__.subYears)(day, yearItemNumber));\n    var endPeriod = getYearsPeriod(previousYear, yearItemNumber).endPeriod;\n    var minDateYear = minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(minDate);\n    return (minDateYear && minDateYear > endPeriod) || false;\n}\nfunction yearDisabledAfter(day, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, includeDates = _b.includeDates;\n    var nextYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(day, 1);\n    return ((maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.differenceInCalendarYears)(nextYear, maxDate) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.differenceInCalendarYears)(nextYear, includeDate) > 0; })) ||\n        false);\n}\nfunction yearsDisabledAfter(day, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : _c;\n    var nextYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(day, yearItemNumber);\n    var startPeriod = getYearsPeriod(nextYear, yearItemNumber).startPeriod;\n    var maxDateYear = maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(maxDate);\n    return (maxDateYear && maxDateYear < startPeriod) || false;\n}\nfunction getEffectiveMinDate(_a) {\n    var minDate = _a.minDate, includeDates = _a.includeDates;\n    if (includeDates && minDate) {\n        var minDates = includeDates.filter(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.differenceInCalendarDays)(includeDate, minDate) >= 0; });\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.min)(minDates);\n    }\n    else if (includeDates) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.min)(includeDates);\n    }\n    else {\n        return minDate;\n    }\n}\nfunction getEffectiveMaxDate(_a) {\n    var maxDate = _a.maxDate, includeDates = _a.includeDates;\n    if (includeDates && maxDate) {\n        var maxDates = includeDates.filter(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.differenceInCalendarDays)(includeDate, maxDate) <= 0; });\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_46__.max)(maxDates);\n    }\n    else if (includeDates) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_46__.max)(includeDates);\n    }\n    else {\n        return maxDate;\n    }\n}\n/**\n * Get a map of highlighted dates with their corresponding classes.\n * @param highlightDates The dates to highlight.\n * @param defaultClassName The default class to use for highlighting.\n * @returns A map with dates as keys and arrays of class names as values.\n */\nfunction getHighLightDaysMap(highlightDates, defaultClassName) {\n    var _a;\n    if (highlightDates === void 0) { highlightDates = []; }\n    if (defaultClassName === void 0) { defaultClassName = \"react-datepicker__day--highlighted\"; }\n    var dateClasses = new Map();\n    for (var i = 0, len = highlightDates.length; i < len; i++) {\n        var obj = highlightDates[i];\n        if ((0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(obj)) {\n            var key = formatDate(obj, \"MM.dd.yyyy\");\n            var classNamesArr = dateClasses.get(key) || [];\n            if (!classNamesArr.includes(defaultClassName)) {\n                classNamesArr.push(defaultClassName);\n                dateClasses.set(key, classNamesArr);\n            }\n        }\n        else if (typeof obj === \"object\") {\n            var keys = Object.keys(obj);\n            var className = (_a = keys[0]) !== null && _a !== void 0 ? _a : \"\";\n            var arrOfDates = obj[className];\n            if (typeof className === \"string\" && Array.isArray(arrOfDates)) {\n                for (var k = 0, len_1 = arrOfDates.length; k < len_1; k++) {\n                    var dateK = arrOfDates[k];\n                    if (dateK) {\n                        var key = formatDate(dateK, \"MM.dd.yyyy\");\n                        var classNamesArr = dateClasses.get(key) || [];\n                        if (!classNamesArr.includes(className)) {\n                            classNamesArr.push(className);\n                            dateClasses.set(key, classNamesArr);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dateClasses;\n}\n/**\n * Compare the two arrays\n * @param array1 The first array to compare.\n * @param array2 The second array to compare.\n * @returns true, if the passed arrays are equal, false otherwise.\n */\nfunction arraysAreEqual(array1, array2) {\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    return array1.every(function (value, index) { return value === array2[index]; });\n}\n/**\n * Assign the custom class to each date\n * @param holidayDates array of object containing date and name of the holiday\n * @param defaultClassName className to be added.\n * @returns Map containing date as key and array of className and holiday name as value\n */\nfunction getHolidaysMap(holidayDates, defaultClassName) {\n    if (holidayDates === void 0) { holidayDates = []; }\n    if (defaultClassName === void 0) { defaultClassName = \"react-datepicker__day--holidays\"; }\n    var dateClasses = new Map();\n    holidayDates.forEach(function (holiday) {\n        var dateObj = holiday.date, holidayName = holiday.holidayName;\n        if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(dateObj)) {\n            return;\n        }\n        var key = formatDate(dateObj, \"MM.dd.yyyy\");\n        var classNamesObj = dateClasses.get(key) || {\n            className: \"\",\n            holidayNames: [],\n        };\n        if (\"className\" in classNamesObj &&\n            classNamesObj[\"className\"] === defaultClassName &&\n            arraysAreEqual(classNamesObj[\"holidayNames\"], [holidayName])) {\n            return;\n        }\n        classNamesObj[\"className\"] = defaultClassName;\n        var holidayNameArr = classNamesObj[\"holidayNames\"];\n        classNamesObj[\"holidayNames\"] = holidayNameArr\n            ? __spreadArray(__spreadArray([], holidayNameArr, true), [holidayName], false) : [holidayName];\n        dateClasses.set(key, classNamesObj);\n    });\n    return dateClasses;\n}\n/**\n * Determines the times to inject after a given start of day, current time, and multiplier.\n * @param startOfDay The start of the day.\n * @param currentTime The current time.\n * @param currentMultiplier The current multiplier.\n * @param intervals The intervals.\n * @param injectedTimes The times to potentially inject.\n * @returns An array of times to inject.\n */\nfunction timesToInjectAfter(startOfDay, currentTime, currentMultiplier, intervals, injectedTimes) {\n    var l = injectedTimes.length;\n    var times = [];\n    for (var i = 0; i < l; i++) {\n        var injectedTime = startOfDay;\n        var injectedTimeValue = injectedTimes[i];\n        if (injectedTimeValue) {\n            injectedTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_48__.addHours)(injectedTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(injectedTimeValue));\n            injectedTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_49__.addMinutes)(injectedTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(injectedTimeValue));\n            injectedTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_50__.addSeconds)(injectedTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(injectedTimeValue));\n        }\n        var nextTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_49__.addMinutes)(startOfDay, (currentMultiplier + 1) * intervals);\n        if ((0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(injectedTime, currentTime) &&\n            (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(injectedTime, nextTime) &&\n            injectedTimeValue != undefined) {\n            times.push(injectedTimeValue);\n        }\n    }\n    return times;\n}\n/**\n * Adds a leading zero to a number if it's less than 10.\n * @param i The number to add a leading zero to.\n * @returns The number as a string, with a leading zero if it was less than 10.\n */\nfunction addZero(i) {\n    return i < 10 ? \"0\".concat(i) : \"\".concat(i);\n}\n/**\n * Gets the start and end years for a period.\n * @param date The date to get the period for.\n * @param yearItemNumber The number of years in the period. Defaults to DEFAULT_YEAR_ITEM_NUMBER.\n * @returns An object with the start and end years for the period.\n */\nfunction getYearsPeriod(date, yearItemNumber) {\n    if (yearItemNumber === void 0) { yearItemNumber = DEFAULT_YEAR_ITEM_NUMBER; }\n    var endPeriod = Math.ceil((0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(date) / yearItemNumber) * yearItemNumber;\n    var startPeriod = endPeriod - (yearItemNumber - 1);\n    return { startPeriod: startPeriod, endPeriod: endPeriod };\n}\n/**\n * Gets the number of hours in a day.\n * @param d The date to get the number of hours for.\n * @returns The number of hours in the day.\n */\nfunction getHoursInDay(d) {\n    var startOfDay = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n    var startOfTheNextDay = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 24);\n    return Math.round((+startOfTheNextDay - +startOfDay) / 3600000);\n}\n/**\n * Returns the start of the minute for the given date\n *\n * NOTE: this function is a DST and timezone-safe analog of `date-fns/startOfMinute`\n * do not make changes unless you know what you're doing\n *\n * See comments on https://github.com/Hacker0x01/react-datepicker/pull/4244\n * for more details\n *\n * @param d date\n * @returns start of the minute\n */\nfunction startOfMinute(d) {\n    var seconds = d.getSeconds();\n    var milliseconds = d.getMilliseconds();\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_4__.toDate)(d.getTime() - seconds * 1000 - milliseconds);\n}\n/**\n * Returns whether the given dates are in the same minute\n *\n * This function is a DST and timezone-safe analog of `date-fns/isSameMinute`\n *\n * @param d1\n * @param d2\n * @returns\n */\nfunction isSameMinute(d1, d2) {\n    return startOfMinute(d1).getTime() === startOfMinute(d2).getTime();\n}\n/**\n * Returns a new datetime object representing the input date with midnight time\n * @param date The date to get the midnight time for\n * @returns A new datetime object representing the input date with midnight time\n */\nfunction getMidnightDate(date) {\n    if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(date)) {\n        throw new Error(\"Invalid date\");\n    }\n    var dateWithoutTime = new Date(date);\n    dateWithoutTime.setHours(0, 0, 0, 0);\n    return dateWithoutTime;\n}\n/**\n * Is the first date before the second one?\n * @param date The date that should be before the other one to return true\n * @param dateToCompare The date to compare with\n * @returns The first date is before the second date\n *\n * Note:\n *  This function considers the mid-night of the given dates for comparison.\n *  It evaluates whether date is before dateToCompare based on their mid-night timestamps.\n */\nfunction isDateBefore(date, dateToCompare) {\n    if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(date) || !(0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(dateToCompare)) {\n        throw new Error(\"Invalid date received\");\n    }\n    var midnightDate = getMidnightDate(date);\n    var midnightDateToCompare = getMidnightDate(dateToCompare);\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(midnightDate, midnightDateToCompare);\n}\n/**\n * Checks if the space key was pressed down.\n *\n * @param event - The keyboard event.\n * @returns - Returns true if the space key was pressed down, false otherwise.\n */\nfunction isSpaceKeyDown(event) {\n    return event.key === KeyType.Space;\n}\n\n/**\n * `InputTime` is a React component that manages time input.\n *\n * @component\n * @example\n * <InputTime timeString=\"12:00\" />\n *\n * @param props - The properties that define the `InputTime` component.\n * @param props.onChange - Function that is called when the date changes.\n * @param props.date - The initial date value.\n * @param props.timeString - The initial time string value.\n * @param props.timeInputLabel - The label for the time input.\n * @param props.customTimeInput - An optional custom time input element.\n *\n * @returns The `InputTime` component.\n */\nvar InputTime = /** @class */ (function (_super) {\n    __extends(InputTime, _super);\n    function InputTime(props) {\n        var _this = _super.call(this, props) || this;\n        _this.inputRef = react__WEBPACK_IMPORTED_MODULE_1___default().createRef();\n        _this.onTimeChange = function (time) {\n            var _a, _b;\n            _this.setState({ time: time });\n            var propDate = _this.props.date;\n            var isPropDateValid = propDate instanceof Date && !isNaN(+propDate);\n            var date = isPropDateValid ? propDate : new Date();\n            if (time === null || time === void 0 ? void 0 : time.includes(\":\")) {\n                var _c = time.split(\":\"), hours = _c[0], minutes = _c[1];\n                date.setHours(Number(hours));\n                date.setMinutes(Number(minutes));\n            }\n            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, date);\n        };\n        _this.renderTimeInput = function () {\n            var time = _this.state.time;\n            var _a = _this.props, date = _a.date, timeString = _a.timeString, customTimeInput = _a.customTimeInput;\n            if (customTimeInput) {\n                return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(customTimeInput, {\n                    date: date,\n                    value: time,\n                    onChange: _this.onTimeChange,\n                });\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"input\", { type: \"time\", className: \"react-datepicker-time__input\", placeholder: \"Time\", name: \"time-input\", ref: _this.inputRef, onClick: function () {\n                    var _a;\n                    (_a = _this.inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n                }, required: true, value: time, onChange: function (event) {\n                    _this.onTimeChange(event.target.value || timeString);\n                } }));\n        };\n        _this.state = {\n            time: _this.props.timeString,\n        };\n        return _this;\n    }\n    InputTime.getDerivedStateFromProps = function (props, state) {\n        if (props.timeString !== state.time) {\n            return {\n                time: props.timeString,\n            };\n        }\n        // Return null to indicate no change to state.\n        return null;\n    };\n    InputTime.prototype.render = function () {\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__input-time-container\" },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__caption\" }, this.props.timeInputLabel),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__input-container\" },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__input\" }, this.renderTimeInput()))));\n    };\n    return InputTime;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\n/**\n * `Day` is a React component that represents a single day in a date picker.\n * It handles the rendering and interaction of a day.\n *\n * @prop ariaLabelPrefixWhenEnabled - Aria label prefix when the day is enabled.\n * @prop ariaLabelPrefixWhenDisabled - Aria label prefix when the day is disabled.\n * @prop disabledKeyboardNavigation - Whether keyboard navigation is disabled.\n * @prop day - The day to be displayed.\n * @prop dayClassName - Function to customize the CSS class of the day.\n * @prop endDate - The end date in a range.\n * @prop highlightDates - Map of dates to be highlighted.\n * @prop holidays - Map of holiday dates.\n * @prop inline - Whether the date picker is inline.\n * @prop shouldFocusDayInline - Whether the day should be focused when date picker is inline.\n * @prop month - The month the day belongs to.\n * @prop onClick - Click event handler.\n * @prop onMouseEnter - Mouse enter event handler.\n * @prop handleOnKeyDown - Key down event handler.\n * @prop usePointerEvent - Whether to use pointer events.\n * @prop preSelection - The date that is currently selected.\n * @prop selected - The selected date.\n * @prop selectingDate - The date currently being selected.\n * @prop selectsEnd - Whether the day can be the end date in a range.\n * @prop selectsStart - Whether the day can be the start date in a range.\n * @prop selectsRange - Whether the day can be in a range.\n * @prop showWeekPicker - Whether to show week picker.\n * @prop showWeekNumber - Whether to show week numbers.\n * @prop selectsDisabledDaysInRange - Whether to select disabled days in a range.\n * @prop selectsMultiple - Whether to allow multiple date selection.\n * @prop selectedDates - Array of selected dates.\n * @prop startDate - The start date in a range.\n * @prop renderDayContents - Function to customize the rendering of the day's contents.\n * @prop containerRef - Ref for the container.\n * @prop excludeDates - Array of dates to be excluded.\n * @prop calendarStartDay - The start day of the week.\n * @prop locale - The locale object.\n * @prop monthShowsDuplicateDaysEnd - Whether to show duplicate days at the end of the month.\n * @prop monthShowsDuplicateDaysStart - Whether to show duplicate days at the start of the month.\n * @prop includeDates - Array of dates to be included.\n * @prop includeDateIntervals - Array of date intervals to be included.\n * @prop minDate - The minimum date that can be selected.\n * @prop maxDate - The maximum date that can be selected.\n *\n * @example\n * ```tsx\n * import React from 'react';\n * import Day from './day';\n *\n * function MyComponent() {\n *   const handleDayClick = (event) => {\n *     console.log('Day clicked', event);\n *   };\n *\n *   const handleDayMouseEnter = (event) => {\n *     console.log('Mouse entered day', event);\n *   };\n *\n *   const renderDayContents = (date) => {\n *     return <div>{date.getDate()}</div>;\n *   };\n *\n *   return (\n *     <Day\n *       day={new Date()}\n *       onClick={handleDayClick}\n *       onMouseEnter={handleDayMouseEnter}\n *       renderDayContents={renderDayContents}\n *     />\n *   );\n * }\n *\n * export default MyComponent;\n * ```\n */\nvar Day = /** @class */ (function (_super) {\n    __extends(Day, _super);\n    function Day() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.dayEl = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.handleClick = function (event) {\n            if (!_this.isDisabled() && _this.props.onClick) {\n                _this.props.onClick(event);\n            }\n        };\n        _this.handleMouseEnter = function (event) {\n            if (!_this.isDisabled() && _this.props.onMouseEnter) {\n                _this.props.onMouseEnter(event);\n            }\n        };\n        _this.handleOnKeyDown = function (event) {\n            var _a, _b;\n            var eventKey = event.key;\n            if (eventKey === KeyType.Space) {\n                event.preventDefault();\n                event.key = KeyType.Enter;\n            }\n            (_b = (_a = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.isSameDay = function (other) {\n            return isSameDay(_this.props.day, other);\n        };\n        _this.isKeyboardSelected = function () {\n            var _a;\n            if (_this.props.disabledKeyboardNavigation) {\n                return false;\n            }\n            var isSelectedDate = _this.props.selectsMultiple\n                ? (_a = _this.props.selectedDates) === null || _a === void 0 ? void 0 : _a.some(function (date) { return _this.isSameDayOrWeek(date); })\n                : _this.isSameDayOrWeek(_this.props.selected);\n            var isDisabled = _this.props.preSelection && _this.isDisabled(_this.props.preSelection);\n            return (!isSelectedDate &&\n                _this.isSameDayOrWeek(_this.props.preSelection) &&\n                !isDisabled);\n        };\n        _this.isDisabled = function (day) {\n            if (day === void 0) { day = _this.props.day; }\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayDisabled(day, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n                includeDateIntervals: _this.props.includeDateIntervals,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n                disabled: _this.props.disabled,\n            });\n        };\n        _this.isExcluded = function () {\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayExcluded(_this.props.day, {\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n            });\n        };\n        _this.isStartOfWeek = function () {\n            return isSameDay(_this.props.day, getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay));\n        };\n        _this.isSameWeek = function (other) {\n            return _this.props.showWeekPicker &&\n                isSameDay(other, getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay));\n        };\n        _this.isSameDayOrWeek = function (other) {\n            return _this.isSameDay(other) || _this.isSameWeek(other);\n        };\n        _this.getHighLightedClass = function () {\n            var _a = _this.props, day = _a.day, highlightDates = _a.highlightDates;\n            if (!highlightDates) {\n                return false;\n            }\n            // Looking for className in the Map of {'day string, 'className'}\n            var dayStr = formatDate(day, \"MM.dd.yyyy\");\n            return highlightDates.get(dayStr);\n        };\n        // Function to return the array containing className associated to the date\n        _this.getHolidaysClass = function () {\n            var _a;\n            var _b = _this.props, day = _b.day, holidays = _b.holidays;\n            if (!holidays) {\n                // For type consistency no other reasons\n                return [undefined];\n            }\n            var dayStr = formatDate(day, \"MM.dd.yyyy\");\n            // Looking for className in the Map of {day string: {className, holidayName}}\n            if (holidays.has(dayStr)) {\n                return [(_a = holidays.get(dayStr)) === null || _a === void 0 ? void 0 : _a.className];\n            }\n            // For type consistency no other reasons\n            return [undefined];\n        };\n        _this.isInRange = function () {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isDayInRange(day, startDate, endDate);\n        };\n        _this.isInSelectingRange = function () {\n            var _a;\n            var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, selectsDisabledDaysInRange = _b.selectsDisabledDaysInRange, startDate = _b.startDate, swapRange = _b.swapRange, endDate = _b.endDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            // Don't highlight days outside the current month\n            if (_this.isAfterMonth() || _this.isBeforeMonth()) {\n                return false;\n            }\n            if (!(selectsStart || selectsEnd || selectsRange) ||\n                !selectingDate ||\n                (!selectsDisabledDaysInRange && _this.isDisabled())) {\n                return false;\n            }\n            if (selectsStart &&\n                endDate &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(selectingDate, endDate) || isEqual(selectingDate, endDate))) {\n                return isDayInRange(day, selectingDate, endDate);\n            }\n            if (selectsEnd &&\n                startDate &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(selectingDate, startDate) || isEqual(selectingDate, startDate))) {\n                return isDayInRange(day, startDate, selectingDate);\n            }\n            if (selectsRange && startDate && !endDate) {\n                if (isEqual(selectingDate, startDate)) {\n                    return isDayInRange(day, startDate, selectingDate);\n                }\n                if ((0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(selectingDate, startDate)) {\n                    return isDayInRange(day, startDate, selectingDate);\n                }\n                if (swapRange && (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(selectingDate, startDate)) {\n                    return isDayInRange(day, selectingDate, startDate);\n                }\n            }\n            return false;\n        };\n        _this.isSelectingRangeStart = function () {\n            var _a;\n            if (!_this.isInSelectingRange()) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, startDate = _b.startDate, selectsStart = _b.selectsStart, swapRange = _b.swapRange, selectsRange = _b.selectsRange;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsStart) {\n                return isSameDay(day, selectingDate);\n            }\n            if (selectsRange && swapRange && startDate && selectingDate) {\n                return isSameDay(day, (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(selectingDate, startDate) ? selectingDate : startDate);\n            }\n            return isSameDay(day, startDate);\n        };\n        _this.isSelectingRangeEnd = function () {\n            var _a;\n            if (!_this.isInSelectingRange()) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, swapRange = _b.swapRange, startDate = _b.startDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsEnd) {\n                return isSameDay(day, selectingDate);\n            }\n            if (selectsRange && swapRange && startDate && selectingDate) {\n                return isSameDay(day, (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(selectingDate, startDate) ? startDate : selectingDate);\n            }\n            if (selectsRange) {\n                return isSameDay(day, selectingDate);\n            }\n            return isSameDay(day, endDate);\n        };\n        _this.isRangeStart = function () {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameDay(startDate, day);\n        };\n        _this.isRangeEnd = function () {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameDay(endDate, day);\n        };\n        _this.isWeekend = function () {\n            var weekday = (0,date_fns__WEBPACK_IMPORTED_MODULE_53__.getDay)(_this.props.day);\n            return weekday === 0 || weekday === 6;\n        };\n        _this.isAfterMonth = function () {\n            return (_this.props.month !== undefined &&\n                (_this.props.month + 1) % 12 === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(_this.props.day));\n        };\n        _this.isBeforeMonth = function () {\n            return (_this.props.month !== undefined &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(_this.props.day) + 1) % 12 === _this.props.month);\n        };\n        _this.isCurrentDay = function () { return _this.isSameDay(newDate()); };\n        _this.isSelected = function () {\n            var _a;\n            if (_this.props.selectsMultiple) {\n                return (_a = _this.props.selectedDates) === null || _a === void 0 ? void 0 : _a.some(function (date) {\n                    return _this.isSameDayOrWeek(date);\n                });\n            }\n            return _this.isSameDayOrWeek(_this.props.selected);\n        };\n        _this.getClassNames = function (date) {\n            var dayClassName = _this.props.dayClassName\n                ? _this.props.dayClassName(date)\n                : undefined;\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__day\", dayClassName, \"react-datepicker__day--\" + getDayOfWeekCode(_this.props.day), {\n                \"react-datepicker__day--disabled\": _this.isDisabled(),\n                \"react-datepicker__day--excluded\": _this.isExcluded(),\n                \"react-datepicker__day--selected\": _this.isSelected(),\n                \"react-datepicker__day--keyboard-selected\": _this.isKeyboardSelected(),\n                \"react-datepicker__day--range-start\": _this.isRangeStart(),\n                \"react-datepicker__day--range-end\": _this.isRangeEnd(),\n                \"react-datepicker__day--in-range\": _this.isInRange(),\n                \"react-datepicker__day--in-selecting-range\": _this.isInSelectingRange(),\n                \"react-datepicker__day--selecting-range-start\": _this.isSelectingRangeStart(),\n                \"react-datepicker__day--selecting-range-end\": _this.isSelectingRangeEnd(),\n                \"react-datepicker__day--today\": _this.isCurrentDay(),\n                \"react-datepicker__day--weekend\": _this.isWeekend(),\n                \"react-datepicker__day--outside-month\": _this.isAfterMonth() || _this.isBeforeMonth(),\n            }, _this.getHighLightedClass(), _this.getHolidaysClass());\n        };\n        _this.getAriaLabel = function () {\n            var _a = _this.props, day = _a.day, _b = _a.ariaLabelPrefixWhenEnabled, ariaLabelPrefixWhenEnabled = _b === void 0 ? \"Choose\" : _b, _c = _a.ariaLabelPrefixWhenDisabled, ariaLabelPrefixWhenDisabled = _c === void 0 ? \"Not available\" : _c;\n            var prefix = _this.isDisabled() || _this.isExcluded()\n                ? ariaLabelPrefixWhenDisabled\n                : ariaLabelPrefixWhenEnabled;\n            return \"\".concat(prefix, \" \").concat(formatDate(day, \"PPPP\", _this.props.locale));\n        };\n        // A function to return the holiday's name as title's content\n        _this.getTitle = function () {\n            var _a = _this.props, day = _a.day, _b = _a.holidays, holidays = _b === void 0 ? new Map() : _b, excludeDates = _a.excludeDates;\n            var compareDt = formatDate(day, \"MM.dd.yyyy\");\n            var titles = [];\n            if (holidays.has(compareDt)) {\n                titles.push.apply(titles, holidays.get(compareDt).holidayNames);\n            }\n            if (_this.isExcluded()) {\n                titles.push(excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.filter(function (excludeDate) {\n                    if (excludeDate instanceof Date) {\n                        return isSameDay(excludeDate, day);\n                    }\n                    return isSameDay(excludeDate === null || excludeDate === void 0 ? void 0 : excludeDate.date, day);\n                }).map(function (excludeDate) {\n                    if (excludeDate instanceof Date) {\n                        return undefined;\n                    }\n                    return excludeDate === null || excludeDate === void 0 ? void 0 : excludeDate.message;\n                }));\n            }\n            // I'm not sure that this is a right output, but all tests are green\n            return titles.join(\", \");\n        };\n        _this.getTabIndex = function () {\n            var selectedDay = _this.props.selected;\n            var preSelectionDay = _this.props.preSelection;\n            var tabIndex = !(_this.props.showWeekPicker &&\n                (_this.props.showWeekNumber || !_this.isStartOfWeek())) &&\n                (_this.isKeyboardSelected() ||\n                    (_this.isSameDay(selectedDay) &&\n                        isSameDay(preSelectionDay, selectedDay)))\n                ? 0\n                : -1;\n            return tabIndex;\n        };\n        // various cases when we need to apply focus to the preselected day\n        // focus the day on mount/update so that keyboard navigation works while cycling through months with up or down keys (not for prev and next month buttons)\n        // prevent focus for these activeElement cases so we don't pull focus from the input as the calendar opens\n        _this.handleFocusDay = function () {\n            var _a;\n            // only do this while the input isn't focused\n            // otherwise, typing/backspacing the date manually may steal focus away from the input\n            _this.shouldFocusDay() && ((_a = _this.dayEl.current) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true }));\n        };\n        _this.renderDayContents = function () {\n            if (_this.props.monthShowsDuplicateDaysEnd && _this.isAfterMonth())\n                return null;\n            if (_this.props.monthShowsDuplicateDaysStart && _this.isBeforeMonth())\n                return null;\n            return _this.props.renderDayContents\n                ? _this.props.renderDayContents((0,date_fns__WEBPACK_IMPORTED_MODULE_54__.getDate)(_this.props.day), _this.props.day)\n                : (0,date_fns__WEBPACK_IMPORTED_MODULE_54__.getDate)(_this.props.day);\n        };\n        _this.render = function () { return (\n        // TODO: Use <option> instead of the \"option\" role to ensure accessibility across all devices.\n        react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: _this.dayEl, className: _this.getClassNames(_this.props.day), onKeyDown: _this.handleOnKeyDown, onClick: _this.handleClick, onMouseEnter: !_this.props.usePointerEvent ? _this.handleMouseEnter : undefined, onPointerEnter: _this.props.usePointerEvent ? _this.handleMouseEnter : undefined, tabIndex: _this.getTabIndex(), \"aria-label\": _this.getAriaLabel(), role: \"gridcell\", title: _this.getTitle(), \"aria-disabled\": _this.isDisabled(), \"aria-current\": _this.isCurrentDay() ? \"date\" : undefined, \"aria-selected\": _this.isSelected() || _this.isInRange() },\n            _this.renderDayContents(),\n            _this.getTitle() !== \"\" && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"overlay\" }, _this.getTitle())))); };\n        return _this;\n    }\n    Day.prototype.componentDidMount = function () {\n        this.handleFocusDay();\n    };\n    Day.prototype.componentDidUpdate = function () {\n        this.handleFocusDay();\n    };\n    Day.prototype.shouldFocusDay = function () {\n        var shouldFocusDay = false;\n        if (this.getTabIndex() === 0 && this.isSameDay(this.props.preSelection)) {\n            // there is currently no activeElement and not inline\n            if (!document.activeElement || document.activeElement === document.body) {\n                shouldFocusDay = true;\n            }\n            // inline version:\n            // do not focus on initial render to prevent autoFocus issue\n            // focus after month has changed via keyboard\n            if (this.props.inline && !this.props.shouldFocusDayInline) {\n                shouldFocusDay = false;\n            }\n            if (this.isDayActiveElement()) {\n                shouldFocusDay = true;\n            }\n            if (this.isDuplicateDay()) {\n                shouldFocusDay = false;\n            }\n        }\n        return shouldFocusDay;\n    };\n    // the activeElement is in the container, and it is another instance of Day\n    Day.prototype.isDayActiveElement = function () {\n        var _a, _b, _c;\n        return (((_b = (_a = this.props.containerRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(document.activeElement)) &&\n            ((_c = document.activeElement) === null || _c === void 0 ? void 0 : _c.classList.contains(\"react-datepicker__day\")));\n    };\n    Day.prototype.isDuplicateDay = function () {\n        return (\n        //day is one of the non rendered duplicate days\n        (this.props.monthShowsDuplicateDaysEnd && this.isAfterMonth()) ||\n            (this.props.monthShowsDuplicateDaysStart && this.isBeforeMonth()));\n    };\n    return Day;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar WeekNumber = /** @class */ (function (_super) {\n    __extends(WeekNumber, _super);\n    function WeekNumber() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.weekNumberEl = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.handleClick = function (event) {\n            if (_this.props.onClick) {\n                _this.props.onClick(event);\n            }\n        };\n        _this.handleOnKeyDown = function (event) {\n            var _a, _b;\n            var eventKey = event.key;\n            if (eventKey === KeyType.Space) {\n                event.preventDefault();\n                event.key = KeyType.Enter;\n            }\n            (_b = (_a = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.isKeyboardSelected = function () {\n            return !_this.props.disabledKeyboardNavigation &&\n                !isSameDay(_this.props.date, _this.props.selected) &&\n                isSameDay(_this.props.date, _this.props.preSelection);\n        };\n        _this.getTabIndex = function () {\n            return _this.props.showWeekPicker &&\n                _this.props.showWeekNumber &&\n                (_this.isKeyboardSelected() ||\n                    (isSameDay(_this.props.date, _this.props.selected) &&\n                        isSameDay(_this.props.preSelection, _this.props.selected)))\n                ? 0\n                : -1;\n        };\n        // various cases when we need to apply focus to the preselected week-number\n        // focus the week-number on mount/update so that keyboard navigation works while cycling through months with up or down keys (not for prev and next month buttons)\n        // prevent focus for these activeElement cases so we don't pull focus from the input as the calendar opens\n        _this.handleFocusWeekNumber = function (prevProps) {\n            var shouldFocusWeekNumber = false;\n            // only do this while the input isn't focused\n            // otherwise, typing/backspacing the date manually may steal focus away from the input\n            if (_this.getTabIndex() === 0 &&\n                !(prevProps === null || prevProps === void 0 ? void 0 : prevProps.isInputFocused) &&\n                isSameDay(_this.props.date, _this.props.preSelection)) {\n                // there is currently no activeElement and not inline\n                if (!document.activeElement || document.activeElement === document.body) {\n                    shouldFocusWeekNumber = true;\n                }\n                // inline version:\n                // do not focus on initial render to prevent autoFocus issue\n                // focus after month has changed via keyboard\n                if (_this.props.inline && !_this.props.shouldFocusDayInline) {\n                    shouldFocusWeekNumber = false;\n                }\n                // the activeElement is in the container, and it is another instance of WeekNumber\n                if (_this.props.containerRef &&\n                    _this.props.containerRef.current &&\n                    _this.props.containerRef.current.contains(document.activeElement) &&\n                    document.activeElement &&\n                    document.activeElement.classList.contains(\"react-datepicker__week-number\")) {\n                    shouldFocusWeekNumber = true;\n                }\n            }\n            shouldFocusWeekNumber &&\n                _this.weekNumberEl.current &&\n                _this.weekNumberEl.current.focus({ preventScroll: true });\n        };\n        return _this;\n    }\n    Object.defineProperty(WeekNumber, \"defaultProps\", {\n        get: function () {\n            return {\n                ariaLabelPrefix: \"week \",\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WeekNumber.prototype.componentDidMount = function () {\n        this.handleFocusWeekNumber();\n    };\n    WeekNumber.prototype.componentDidUpdate = function (prevProps) {\n        this.handleFocusWeekNumber(prevProps);\n    };\n    WeekNumber.prototype.render = function () {\n        var _a = this.props, weekNumber = _a.weekNumber, isWeekDisabled = _a.isWeekDisabled, _b = _a.ariaLabelPrefix, ariaLabelPrefix = _b === void 0 ? WeekNumber.defaultProps.ariaLabelPrefix : _b, onClick = _a.onClick;\n        var weekNumberClasses = {\n            \"react-datepicker__week-number\": true,\n            \"react-datepicker__week-number--clickable\": !!onClick && !isWeekDisabled,\n            \"react-datepicker__week-number--selected\": !!onClick && isSameDay(this.props.date, this.props.selected),\n        };\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: this.weekNumberEl, className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(weekNumberClasses), \"aria-label\": \"\".concat(ariaLabelPrefix, \" \").concat(this.props.weekNumber), onClick: this.handleClick, onKeyDown: this.handleOnKeyDown, tabIndex: this.getTabIndex(), role: \"gridcell\" }, weekNumber));\n    };\n    return WeekNumber;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar Week = /** @class */ (function (_super) {\n    __extends(Week, _super);\n    function Week() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isDisabled = function (day) {\n            return isDayDisabled(day, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n                includeDateIntervals: _this.props.includeDateIntervals,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n            });\n        };\n        _this.handleDayClick = function (day, event) {\n            if (_this.props.onDayClick) {\n                _this.props.onDayClick(day, event);\n            }\n        };\n        _this.handleDayMouseEnter = function (day) {\n            if (_this.props.onDayMouseEnter) {\n                _this.props.onDayMouseEnter(day);\n            }\n        };\n        _this.handleWeekClick = function (day, weekNumber, event) {\n            var _a, _b, _c;\n            var enabledWeekDay = new Date(day);\n            for (var i = 0; i < 7; i++) {\n                var processingDay = new Date(day);\n                processingDay.setDate(processingDay.getDate() + i);\n                var isEnabled = !_this.isDisabled(processingDay);\n                if (isEnabled) {\n                    enabledWeekDay = processingDay;\n                    break;\n                }\n            }\n            if (typeof _this.props.onWeekSelect === \"function\") {\n                _this.props.onWeekSelect(enabledWeekDay, weekNumber, event);\n            }\n            if (_this.props.showWeekPicker) {\n                _this.handleDayClick(enabledWeekDay, event);\n            }\n            if ((_a = _this.props.shouldCloseOnSelect) !== null && _a !== void 0 ? _a : Week.defaultProps.shouldCloseOnSelect) {\n                (_c = (_b = _this.props).setOpen) === null || _c === void 0 ? void 0 : _c.call(_b, false);\n            }\n        };\n        _this.formatWeekNumber = function (date) {\n            if (_this.props.formatWeekNumber) {\n                return _this.props.formatWeekNumber(date);\n            }\n            return getWeek(date);\n        };\n        _this.isWeekDisabled = function () {\n            var startOfWeek = _this.startOfWeek();\n            var endOfWeek = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, 6);\n            var processingDate = new Date(startOfWeek);\n            while (processingDate <= endOfWeek) {\n                if (!_this.isDisabled(processingDate))\n                    return false;\n                processingDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(processingDate, 1);\n            }\n            return true;\n        };\n        _this.renderDays = function () {\n            var startOfWeek = _this.startOfWeek();\n            var days = [];\n            var weekNumber = _this.formatWeekNumber(startOfWeek);\n            if (_this.props.showWeekNumber) {\n                var onClickAction = _this.props.onWeekSelect || _this.props.showWeekPicker\n                    ? _this.handleWeekClick.bind(_this, startOfWeek, weekNumber)\n                    : undefined;\n                days.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(WeekNumber, _assign({ key: \"W\" }, Week.defaultProps, _this.props, { weekNumber: weekNumber, isWeekDisabled: _this.isWeekDisabled(), date: startOfWeek, onClick: onClickAction })));\n            }\n            return days.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {\n                var day = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, offset);\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Day, _assign({}, Week.defaultProps, _this.props, { ariaLabelPrefixWhenEnabled: _this.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: _this.props.disabledDayAriaLabelPrefix, key: day.valueOf(), day: day, onClick: _this.handleDayClick.bind(_this, day), onMouseEnter: _this.handleDayMouseEnter.bind(_this, day) })));\n            }));\n        };\n        _this.startOfWeek = function () {\n            return getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay);\n        };\n        _this.isKeyboardSelected = function () {\n            return !_this.props.disabledKeyboardNavigation &&\n                !isSameDay(_this.startOfWeek(), _this.props.selected) &&\n                isSameDay(_this.startOfWeek(), _this.props.preSelection);\n        };\n        return _this;\n    }\n    Object.defineProperty(Week, \"defaultProps\", {\n        get: function () {\n            return {\n                shouldCloseOnSelect: true,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Week.prototype.render = function () {\n        var weekNumberClasses = {\n            \"react-datepicker__week\": true,\n            \"react-datepicker__week--selected\": isSameDay(this.startOfWeek(), this.props.selected),\n            \"react-datepicker__week--keyboard-selected\": this.isKeyboardSelected(),\n        };\n        var customWeekClassName = this.props.weekClassName\n            ? this.props.weekClassName(this.startOfWeek())\n            : undefined;\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(weekNumberClasses, customWeekClassName), role: \"row\" }, this.renderDays()));\n    };\n    return Week;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar _a;\nvar FIXED_HEIGHT_STANDARD_WEEK_COUNT = 6;\nvar MONTH_COLUMNS_LAYOUT = {\n    TWO_COLUMNS: \"two_columns\",\n    THREE_COLUMNS: \"three_columns\",\n    FOUR_COLUMNS: \"four_columns\",\n};\nvar MONTH_COLUMNS = (_a = {},\n    _a[MONTH_COLUMNS_LAYOUT.TWO_COLUMNS] = {\n        grid: [\n            [0, 1],\n            [2, 3],\n            [4, 5],\n            [6, 7],\n            [8, 9],\n            [10, 11],\n        ],\n        verticalNavigationOffset: 2,\n    },\n    _a[MONTH_COLUMNS_LAYOUT.THREE_COLUMNS] = {\n        grid: [\n            [0, 1, 2],\n            [3, 4, 5],\n            [6, 7, 8],\n            [9, 10, 11],\n        ],\n        verticalNavigationOffset: 3,\n    },\n    _a[MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS] = {\n        grid: [\n            [0, 1, 2, 3],\n            [4, 5, 6, 7],\n            [8, 9, 10, 11],\n        ],\n        verticalNavigationOffset: 4,\n    },\n    _a);\nvar MONTH_NAVIGATION_HORIZONTAL_OFFSET = 1;\nfunction getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker) {\n    if (showFourColumnMonthYearPicker) {\n        return MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS;\n    }\n    if (showTwoColumnMonthYearPicker) {\n        return MONTH_COLUMNS_LAYOUT.TWO_COLUMNS;\n    }\n    return MONTH_COLUMNS_LAYOUT.THREE_COLUMNS;\n}\n/**\n * `Month` is a React component that represents a month in a calendar.\n * It accepts a `MonthProps` object as props which provides various configurations and event handlers.\n *\n * @prop dayClassName - Function to determine the class name for a day.\n * @prop monthClassName - Function to determine the class name for a month.\n * @prop filterDate - Function to filter dates.\n * @prop formatWeekNumber - Function to format the week number.\n * @prop onDayClick - Function to handle day click events.\n * @prop onDayMouseEnter - Function to handle mouse enter events on a day.\n * @prop onMouseLeave - Function to handle mouse leave events.\n * @prop onWeekSelect - Function to handle week selection.\n * @prop setPreSelection - Function to set pre-selection.\n * @prop setOpen - Function to set open state.\n * @prop renderDayContents - Function to render day contents.\n * @prop renderMonthContent - Function to render month content.\n * @prop renderQuarterContent - Function to render quarter content.\n * @prop handleOnKeyDown - Function to handle key down events.\n * @prop handleOnMonthKeyDown - Function to handle key down events on a month.\n * @prop ariaLabelPrefix - Aria label prefix.\n * @prop chooseDayAriaLabelPrefix - Aria label prefix for choosing a day.\n * @prop disabledDayAriaLabelPrefix - Aria label prefix for disabled day.\n * @prop disabledKeyboardNavigation - Flag to disable keyboard navigation.\n * @prop day - The day.\n * @prop endDate - The end date.\n * @prop orderInDisplay - The order in display.\n * @prop excludeDates - Dates to exclude.\n * @prop excludeDateIntervals - Date intervals to exclude.\n * @prop fixedHeight - Flag to set fixed height.\n * @prop highlightDates - Dates to highlight.\n * @prop holidays - Holidays.\n * @prop includeDates - Dates to include.\n * @prop includeDateIntervals - Date intervals to include.\n * @prop inline - Flag to set inline.\n * @prop shouldFocusDayInline - Flag to set focus on day inline.\n * @prop locale - The locale.\n * @prop maxDate - The maximum date.\n * @prop minDate - The minimum date.\n * @prop usePointerEvent - Flag to use pointer event.\n * @prop peekNextMonth - Flag to peek next month.\n * @prop preSelection - The pre-selection.\n * @prop selected - The selected date.\n * @prop selectingDate - The selecting date.\n * @prop calendarStartDay - The calendar start day.\n * @prop selectsEnd - Flag to select end.\n * @prop selectsStart - Flag to select start.\n * @prop selectsRange - Flag to select range.\n * @prop selectsDisabledDaysInRange - Flag to select disabled days in range.\n * @prop selectsMultiple - Flag to select multiple.\n * @prop selectedDates - The selected dates.\n * @prop showWeekNumbers - Flag to show week numbers.\n * @prop startDate - The start date.\n * @prop shouldCloseOnSelect - Flag to close on select.\n * @prop showMonthYearPicker - Flag to show month year picker.\n * @prop showFullMonthYearPicker - Flag to show full month year picker.\n * @prop showTwoColumnMonthYearPicker - Flag to show two column month year picker.\n * @prop showFourColumnMonthYearPicker - Flag to show four column month year picker.\n * @prop showQuarterYearPicker - Flag to show quarter year picker.\n * @prop showWeekPicker - Flag to show week picker.\n * @prop isInputFocused - Flag to set input focus.\n * @prop weekAriaLabelPrefix - Aria label prefix for week.\n * @prop containerRef - The container reference.\n * @prop monthShowsDuplicateDaysEnd - Flag to show duplicate days at the end of the month.\n * @prop monthShowsDuplicateDaysStart - Flag to show duplicate days at the start of the month.\n *\n * @example\n * ```tsx\n * function App() {\n *  const handleDayClick = (date) => {\n *     console.log('Day clicked: ', date);\n *   };\n *\n *   const handleDayMouseEnter = (date) => {\n *     console.log('Mouse entered on day: ', date);\n *   };\n *\n *   return (\n *     <div>\n *       <Month\n *         day={new Date()}\n *         endDate={new Date()}\n *         onDayClick={handleDayClick}\n *         onDayMouseEnter={handleDayMouseEnter}\n *         disabledKeyboardNavigation={false}\n *         showWeekNumbers={true}\n *         showMonthYearPicker={false}\n *       />\n *     </div>\n *   );\n * }\n * ```\n */\nvar Month = /** @class */ (function (_super) {\n    __extends(Month, _super);\n    function Month() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.MONTH_REFS = __spreadArray([], Array(12), true).map(function () { return (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)(); });\n        _this.QUARTER_REFS = __spreadArray([], Array(4), true).map(function () { return (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)(); });\n        _this.isDisabled = function (day) {\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayDisabled(day, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n                includeDateIntervals: _this.props.includeDateIntervals,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n                disabled: _this.props.disabled,\n            });\n        };\n        _this.isExcluded = function (day) {\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayExcluded(day, {\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n            });\n        };\n        _this.handleDayClick = function (day, event) {\n            var _a, _b;\n            (_b = (_a = _this.props).onDayClick) === null || _b === void 0 ? void 0 : _b.call(_a, day, event, _this.props.orderInDisplay);\n        };\n        _this.handleDayMouseEnter = function (day) {\n            var _a, _b;\n            (_b = (_a = _this.props).onDayMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, day);\n        };\n        _this.handleMouseLeave = function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a);\n        };\n        _this.isRangeStartMonth = function (m) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameMonth((0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, m), startDate);\n        };\n        _this.isRangeStartQuarter = function (q) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameQuarter((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setQuarter)(day, q), startDate);\n        };\n        _this.isRangeEndMonth = function (m) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameMonth((0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, m), endDate);\n        };\n        _this.isRangeEndQuarter = function (q) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameQuarter((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setQuarter)(day, q), endDate);\n        };\n        _this.isInSelectingRangeMonth = function (m) {\n            var _a;\n            var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (!(selectsStart || selectsEnd || selectsRange) || !selectingDate) {\n                return false;\n            }\n            if (selectsStart && endDate) {\n                return isMonthInRange(selectingDate, endDate, m, day);\n            }\n            if (selectsEnd && startDate) {\n                return isMonthInRange(startDate, selectingDate, m, day);\n            }\n            if (selectsRange && startDate && !endDate) {\n                return isMonthInRange(startDate, selectingDate, m, day);\n            }\n            return false;\n        };\n        _this.isSelectingMonthRangeStart = function (m) {\n            var _a;\n            if (!_this.isInSelectingRangeMonth(m)) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, startDate = _b.startDate, selectsStart = _b.selectsStart;\n            var _month = (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, m);\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsStart) {\n                return isSameMonth(_month, selectingDate);\n            }\n            else {\n                return isSameMonth(_month, startDate);\n            }\n        };\n        _this.isSelectingMonthRangeEnd = function (m) {\n            var _a;\n            if (!_this.isInSelectingRangeMonth(m)) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange;\n            var _month = (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, m);\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsEnd || selectsRange) {\n                return isSameMonth(_month, selectingDate);\n            }\n            else {\n                return isSameMonth(_month, endDate);\n            }\n        };\n        _this.isInSelectingRangeQuarter = function (q) {\n            var _a;\n            var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (!(selectsStart || selectsEnd || selectsRange) || !selectingDate) {\n                return false;\n            }\n            if (selectsStart && endDate) {\n                return isQuarterInRange(selectingDate, endDate, q, day);\n            }\n            if (selectsEnd && startDate) {\n                return isQuarterInRange(startDate, selectingDate, q, day);\n            }\n            if (selectsRange && startDate && !endDate) {\n                return isQuarterInRange(startDate, selectingDate, q, day);\n            }\n            return false;\n        };\n        _this.isWeekInMonth = function (startOfWeek) {\n            var day = _this.props.day;\n            var endOfWeek = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, 6);\n            return isSameMonth(startOfWeek, day) || isSameMonth(endOfWeek, day);\n        };\n        _this.isCurrentMonth = function (day, m) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(newDate()) && m === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(newDate());\n        };\n        _this.isCurrentQuarter = function (day, q) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(newDate()) && q === (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.getQuarter)(newDate());\n        };\n        _this.isSelectedMonth = function (day, m, selected) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(selected) === m && (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(selected);\n        };\n        _this.isSelectMonthInList = function (day, m, selectedDates) {\n            return selectedDates.some(function (selectedDate) {\n                return _this.isSelectedMonth(day, m, selectedDate);\n            });\n        };\n        _this.isSelectedQuarter = function (day, q, selected) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.getQuarter)(selected) === q && (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(selected);\n        };\n        _this.isSelectQuarterInList = function (day, q, selectedDates) {\n            return selectedDates.some(function (selectedDate) {\n                return _this.isSelectedQuarter(day, q, selectedDate);\n            });\n        };\n        _this.isMonthSelected = function () {\n            var _a = _this.props, day = _a.day, selected = _a.selected, selectedDates = _a.selectedDates, selectsMultiple = _a.selectsMultiple;\n            var monthIdx = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(day);\n            if (selectsMultiple) {\n                return selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.some(function (date) {\n                    return _this.isSelectedMonth(day, monthIdx, date);\n                });\n            }\n            return !!selected && _this.isSelectedMonth(day, monthIdx, selected);\n        };\n        _this.isQuarterSelected = function () {\n            var _a = _this.props, day = _a.day, selected = _a.selected, selectedDates = _a.selectedDates, selectsMultiple = _a.selectsMultiple;\n            var quarterIdx = (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.getQuarter)(day);\n            if (selectsMultiple) {\n                return selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.some(function (selectedDate) {\n                    return _this.isSelectedQuarter(day, quarterIdx, selectedDate);\n                });\n            }\n            return !!selected && _this.isSelectedQuarter(day, quarterIdx, selected);\n        };\n        _this.renderWeeks = function () {\n            // Return empty array if day is invalid\n            if (!isValid(_this.props.day)) {\n                return [];\n            }\n            var weeks = [];\n            var isFixedHeight = _this.props.fixedHeight;\n            var i = 0;\n            var breakAfterNextPush = false;\n            var currentWeekStart = getStartOfWeek(getStartOfMonth(_this.props.day), _this.props.locale, _this.props.calendarStartDay);\n            var isPreSelected = function (preSelection) {\n                return _this.props.showWeekPicker\n                    ? getStartOfWeek(preSelection, _this.props.locale, _this.props.calendarStartDay)\n                    : _this.props.preSelection;\n            };\n            var isSelected = function (selected) {\n                return _this.props.showWeekPicker\n                    ? getStartOfWeek(selected, _this.props.locale, _this.props.calendarStartDay)\n                    : _this.props.selected;\n            };\n            var selected = _this.props.selected\n                ? isSelected(_this.props.selected)\n                : undefined;\n            var preSelection = _this.props.preSelection\n                ? isPreSelected(_this.props.preSelection)\n                : undefined;\n            while (true) {\n                weeks.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Week, _assign({}, _this.props, { ariaLabelPrefix: _this.props.weekAriaLabelPrefix, key: i, day: currentWeekStart, month: (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(_this.props.day), onDayClick: _this.handleDayClick, onDayMouseEnter: _this.handleDayMouseEnter, selected: selected, preSelection: preSelection, showWeekNumber: _this.props.showWeekNumbers })));\n                if (breakAfterNextPush)\n                    break;\n                i++;\n                currentWeekStart = (0,date_fns__WEBPACK_IMPORTED_MODULE_56__.addWeeks)(currentWeekStart, 1);\n                // If one of these conditions is true, we will either break on this week\n                // or break on the next week\n                var isFixedAndFinalWeek = isFixedHeight && i >= FIXED_HEIGHT_STANDARD_WEEK_COUNT;\n                var isNonFixedAndOutOfMonth = !isFixedHeight && !_this.isWeekInMonth(currentWeekStart);\n                if (isFixedAndFinalWeek || isNonFixedAndOutOfMonth) {\n                    if (_this.props.peekNextMonth) {\n                        breakAfterNextPush = true;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            return weeks;\n        };\n        _this.onMonthClick = function (event, m) {\n            var _a = _this.isMonthDisabledForLabelDate(m), isDisabled = _a.isDisabled, labelDate = _a.labelDate;\n            if (isDisabled) {\n                return;\n            }\n            _this.handleDayClick(getStartOfMonth(labelDate), event);\n        };\n        _this.onMonthMouseEnter = function (m) {\n            var _a = _this.isMonthDisabledForLabelDate(m), isDisabled = _a.isDisabled, labelDate = _a.labelDate;\n            if (isDisabled) {\n                return;\n            }\n            _this.handleDayMouseEnter(getStartOfMonth(labelDate));\n        };\n        _this.handleMonthNavigation = function (newMonth, newDate) {\n            var _a, _b, _c, _d;\n            (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, newDate);\n            (_d = (_c = _this.MONTH_REFS[newMonth]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();\n        };\n        _this.handleKeyboardNavigation = function (event, eventKey, month) {\n            var _a;\n            var _b = _this.props, selected = _b.selected, preSelection = _b.preSelection, setPreSelection = _b.setPreSelection, minDate = _b.minDate, maxDate = _b.maxDate, showFourColumnMonthYearPicker = _b.showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker = _b.showTwoColumnMonthYearPicker;\n            if (!preSelection)\n                return;\n            var monthColumnsLayout = getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker);\n            var verticalOffset = _this.getVerticalOffset(monthColumnsLayout);\n            var monthsGrid = (_a = MONTH_COLUMNS[monthColumnsLayout]) === null || _a === void 0 ? void 0 : _a.grid;\n            var calculateNewDateAndMonth = function (eventKey, date, month) {\n                var _a, _b;\n                var newCalculatedDate = date;\n                var newCalculatedMonth = month;\n                switch (eventKey) {\n                    case KeyType.ArrowRight:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(date, MONTH_NAVIGATION_HORIZONTAL_OFFSET);\n                        newCalculatedMonth =\n                            month === 11 ? 0 : month + MONTH_NAVIGATION_HORIZONTAL_OFFSET;\n                        break;\n                    case KeyType.ArrowLeft:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.subMonths)(date, MONTH_NAVIGATION_HORIZONTAL_OFFSET);\n                        newCalculatedMonth =\n                            month === 0 ? 11 : month - MONTH_NAVIGATION_HORIZONTAL_OFFSET;\n                        break;\n                    case KeyType.ArrowUp:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.subMonths)(date, verticalOffset);\n                        newCalculatedMonth = ((_a = monthsGrid === null || monthsGrid === void 0 ? void 0 : monthsGrid[0]) === null || _a === void 0 ? void 0 : _a.includes(month))\n                            ? month + 12 - verticalOffset\n                            : month - verticalOffset;\n                        break;\n                    case KeyType.ArrowDown:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(date, verticalOffset);\n                        newCalculatedMonth = ((_b = monthsGrid === null || monthsGrid === void 0 ? void 0 : monthsGrid[monthsGrid.length - 1]) === null || _b === void 0 ? void 0 : _b.includes(month))\n                            ? month - 12 + verticalOffset\n                            : month + verticalOffset;\n                        break;\n                }\n                return { newCalculatedDate: newCalculatedDate, newCalculatedMonth: newCalculatedMonth };\n            };\n            var getNewDateAndMonth = function (eventKey, selectedDate, month) {\n                var MAX_ITERATIONS = 40;\n                var eventKeyCopy = eventKey;\n                var validDateFound = false;\n                var iterations = 0;\n                var _a = calculateNewDateAndMonth(eventKeyCopy, selectedDate, month), newCalculatedDate = _a.newCalculatedDate, newCalculatedMonth = _a.newCalculatedMonth;\n                while (!validDateFound) {\n                    if (iterations >= MAX_ITERATIONS) {\n                        newCalculatedDate = selectedDate;\n                        newCalculatedMonth = month;\n                        break;\n                    }\n                    // if minDate exists and the new month is before the minimum month, it will try to find the next available month after\n                    if (minDate && newCalculatedDate < minDate) {\n                        eventKeyCopy = KeyType.ArrowRight;\n                        var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate, newCalculatedMonth);\n                        newCalculatedDate = obj.newCalculatedDate;\n                        newCalculatedMonth = obj.newCalculatedMonth;\n                    }\n                    // if maxDate exists and the new month is after the maximum month, it will try to find the next available month before\n                    if (maxDate && newCalculatedDate > maxDate) {\n                        eventKeyCopy = KeyType.ArrowLeft;\n                        var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate, newCalculatedMonth);\n                        newCalculatedDate = obj.newCalculatedDate;\n                        newCalculatedMonth = obj.newCalculatedMonth;\n                    }\n                    if (isMonthYearDisabled(newCalculatedDate, _this.props)) {\n                        var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate, newCalculatedMonth);\n                        newCalculatedDate = obj.newCalculatedDate;\n                        newCalculatedMonth = obj.newCalculatedMonth;\n                    }\n                    else {\n                        validDateFound = true;\n                    }\n                    iterations++;\n                }\n                return { newCalculatedDate: newCalculatedDate, newCalculatedMonth: newCalculatedMonth };\n            };\n            if (eventKey === KeyType.Enter) {\n                if (!_this.isMonthDisabled(month)) {\n                    _this.onMonthClick(event, month);\n                    setPreSelection === null || setPreSelection === void 0 ? void 0 : setPreSelection(selected);\n                }\n                return;\n            }\n            var _c = getNewDateAndMonth(eventKey, preSelection, month), newCalculatedDate = _c.newCalculatedDate, newCalculatedMonth = _c.newCalculatedMonth;\n            switch (eventKey) {\n                case KeyType.ArrowRight:\n                case KeyType.ArrowLeft:\n                case KeyType.ArrowUp:\n                case KeyType.ArrowDown:\n                    _this.handleMonthNavigation(newCalculatedMonth, newCalculatedDate);\n                    break;\n            }\n        };\n        _this.getVerticalOffset = function (monthColumnsLayout) {\n            var _a, _b;\n            return (_b = (_a = MONTH_COLUMNS[monthColumnsLayout]) === null || _a === void 0 ? void 0 : _a.verticalNavigationOffset) !== null && _b !== void 0 ? _b : 0;\n        };\n        _this.onMonthKeyDown = function (event, month) {\n            var _a = _this.props, disabledKeyboardNavigation = _a.disabledKeyboardNavigation, handleOnMonthKeyDown = _a.handleOnMonthKeyDown;\n            var eventKey = event.key;\n            if (eventKey !== KeyType.Tab) {\n                // preventDefault on tab event blocks focus change\n                event.preventDefault();\n            }\n            if (!disabledKeyboardNavigation) {\n                _this.handleKeyboardNavigation(event, eventKey, month);\n            }\n            handleOnMonthKeyDown && handleOnMonthKeyDown(event);\n        };\n        _this.onQuarterClick = function (event, q) {\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setQuarter)(_this.props.day, q);\n            if (isQuarterDisabled(labelDate, _this.props)) {\n                return;\n            }\n            _this.handleDayClick(getStartOfQuarter(labelDate), event);\n        };\n        _this.onQuarterMouseEnter = function (q) {\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setQuarter)(_this.props.day, q);\n            if (isQuarterDisabled(labelDate, _this.props)) {\n                return;\n            }\n            _this.handleDayMouseEnter(getStartOfQuarter(labelDate));\n        };\n        _this.handleQuarterNavigation = function (newQuarter, newDate) {\n            var _a, _b, _c, _d;\n            if (_this.isDisabled(newDate) || _this.isExcluded(newDate)) {\n                return;\n            }\n            (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, newDate);\n            (_d = (_c = _this.QUARTER_REFS[newQuarter - 1]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();\n        };\n        _this.onQuarterKeyDown = function (event, quarter) {\n            var _a, _b;\n            var eventKey = event.key;\n            if (!_this.props.disabledKeyboardNavigation) {\n                switch (eventKey) {\n                    case KeyType.Enter:\n                        _this.onQuarterClick(event, quarter);\n                        (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.selected);\n                        break;\n                    case KeyType.ArrowRight:\n                        if (!_this.props.preSelection) {\n                            break;\n                        }\n                        _this.handleQuarterNavigation(quarter === 4 ? 1 : quarter + 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_41__.addQuarters)(_this.props.preSelection, 1));\n                        break;\n                    case KeyType.ArrowLeft:\n                        if (!_this.props.preSelection) {\n                            break;\n                        }\n                        _this.handleQuarterNavigation(quarter === 1 ? 4 : quarter - 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.subQuarters)(_this.props.preSelection, 1));\n                        break;\n                }\n            }\n        };\n        _this.isMonthDisabledForLabelDate = function (month) {\n            var _a;\n            var _b = _this.props, day = _b.day, disabled = _b.disabled, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates;\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, month);\n            if (disabled) {\n                return {\n                    isDisabled: true,\n                    labelDate: (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, month),\n                };\n            }\n            return {\n                isDisabled: (_a = ((minDate || maxDate || excludeDates || includeDates) &&\n                    isMonthDisabled(labelDate, _this.props))) !== null && _a !== void 0 ? _a : false,\n                labelDate: labelDate,\n            };\n        };\n        _this.isMonthDisabled = function (month) {\n            var isDisabled = _this.isMonthDisabledForLabelDate(month).isDisabled;\n            return isDisabled;\n        };\n        _this.getMonthClassNames = function (m) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate, preSelection = _a.preSelection, monthClassName = _a.monthClassName;\n            var _monthClassName = monthClassName\n                ? monthClassName((0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, m))\n                : undefined;\n            var selection = _this.getSelection();\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__month-text\", \"react-datepicker__month-\".concat(m), _monthClassName, {\n                \"react-datepicker__month-text--disabled\": _this.isMonthDisabled(m),\n                \"react-datepicker__month-text--selected\": selection\n                    ? _this.isSelectMonthInList(day, m, selection)\n                    : undefined,\n                \"react-datepicker__month-text--keyboard-selected\": !_this.props.disabledKeyboardNavigation &&\n                    preSelection &&\n                    _this.isSelectedMonth(day, m, preSelection) &&\n                    !_this.isMonthSelected() &&\n                    !_this.isMonthDisabled(m),\n                \"react-datepicker__month-text--in-selecting-range\": _this.isInSelectingRangeMonth(m),\n                \"react-datepicker__month-text--in-range\": startDate && endDate\n                    ? isMonthInRange(startDate, endDate, m, day)\n                    : undefined,\n                \"react-datepicker__month-text--range-start\": _this.isRangeStartMonth(m),\n                \"react-datepicker__month-text--range-end\": _this.isRangeEndMonth(m),\n                \"react-datepicker__month-text--selecting-range-start\": _this.isSelectingMonthRangeStart(m),\n                \"react-datepicker__month-text--selecting-range-end\": _this.isSelectingMonthRangeEnd(m),\n                \"react-datepicker__month-text--today\": _this.isCurrentMonth(day, m),\n            });\n        };\n        _this.getTabIndex = function (m) {\n            if (_this.props.preSelection == null) {\n                return \"-1\";\n            }\n            var preSelectedMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(_this.props.preSelection);\n            var isPreSelectedMonthDisabled = _this.isMonthDisabledForLabelDate(preSelectedMonth).isDisabled;\n            var tabIndex = m === preSelectedMonth &&\n                !(isPreSelectedMonthDisabled || _this.props.disabledKeyboardNavigation)\n                ? \"0\"\n                : \"-1\";\n            return tabIndex;\n        };\n        _this.getQuarterTabIndex = function (q) {\n            if (_this.props.preSelection == null) {\n                return \"-1\";\n            }\n            var preSelectedQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.getQuarter)(_this.props.preSelection);\n            var isCurrentQuarterDisabled = isQuarterDisabled(_this.props.day, _this.props);\n            var tabIndex = q === preSelectedQuarter &&\n                !(isCurrentQuarterDisabled || _this.props.disabledKeyboardNavigation)\n                ? \"0\"\n                : \"-1\";\n            return tabIndex;\n        };\n        _this.getAriaLabel = function (month) {\n            var _a = _this.props, _b = _a.chooseDayAriaLabelPrefix, chooseDayAriaLabelPrefix = _b === void 0 ? \"Choose\" : _b, _c = _a.disabledDayAriaLabelPrefix, disabledDayAriaLabelPrefix = _c === void 0 ? \"Not available\" : _c, day = _a.day, locale = _a.locale;\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(day, month);\n            var prefix = _this.isDisabled(labelDate) || _this.isExcluded(labelDate)\n                ? disabledDayAriaLabelPrefix\n                : chooseDayAriaLabelPrefix;\n            return \"\".concat(prefix, \" \").concat(formatDate(labelDate, \"MMMM yyyy\", locale));\n        };\n        _this.getQuarterClassNames = function (q) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate, minDate = _a.minDate, maxDate = _a.maxDate, excludeDates = _a.excludeDates, includeDates = _a.includeDates, filterDate = _a.filterDate, preSelection = _a.preSelection, disabledKeyboardNavigation = _a.disabledKeyboardNavigation, disabled = _a.disabled;\n            var isDisabled = (minDate ||\n                maxDate ||\n                excludeDates ||\n                includeDates ||\n                filterDate ||\n                disabled) &&\n                isQuarterDisabled((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setQuarter)(day, q), _this.props);\n            var selection = _this.getSelection();\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__quarter-text\", \"react-datepicker__quarter-\".concat(q), {\n                \"react-datepicker__quarter-text--disabled\": isDisabled,\n                \"react-datepicker__quarter-text--selected\": selection\n                    ? _this.isSelectQuarterInList(day, q, selection)\n                    : undefined,\n                \"react-datepicker__quarter-text--keyboard-selected\": !disabledKeyboardNavigation &&\n                    preSelection &&\n                    _this.isSelectedQuarter(day, q, preSelection) &&\n                    !_this.isQuarterSelected() &&\n                    !isDisabled,\n                \"react-datepicker__quarter-text--in-selecting-range\": _this.isInSelectingRangeQuarter(q),\n                \"react-datepicker__quarter-text--in-range\": startDate && endDate\n                    ? isQuarterInRange(startDate, endDate, q, day)\n                    : undefined,\n                \"react-datepicker__quarter-text--range-start\": _this.isRangeStartQuarter(q),\n                \"react-datepicker__quarter-text--range-end\": _this.isRangeEndQuarter(q),\n                \"react-datepicker__quarter-text--today\": _this.isCurrentQuarter(day, q),\n            });\n        };\n        _this.getMonthContent = function (m) {\n            var _a = _this.props, showFullMonthYearPicker = _a.showFullMonthYearPicker, renderMonthContent = _a.renderMonthContent, locale = _a.locale, day = _a.day;\n            var shortMonthText = getMonthShortInLocale(m, locale);\n            var fullMonthText = getMonthInLocale(m, locale);\n            if (renderMonthContent) {\n                return renderMonthContent(m, shortMonthText, fullMonthText, day);\n            }\n            return showFullMonthYearPicker ? fullMonthText : shortMonthText;\n        };\n        _this.getQuarterContent = function (q) {\n            var _a;\n            var _b = _this.props, renderQuarterContent = _b.renderQuarterContent, locale = _b.locale;\n            var shortQuarter = getQuarterShortInLocale(q, locale);\n            return (_a = renderQuarterContent === null || renderQuarterContent === void 0 ? void 0 : renderQuarterContent(q, shortQuarter)) !== null && _a !== void 0 ? _a : shortQuarter;\n        };\n        _this.renderMonths = function () {\n            var _a;\n            var _b = _this.props, showTwoColumnMonthYearPicker = _b.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker = _b.showFourColumnMonthYearPicker, day = _b.day, selected = _b.selected;\n            var monthColumns = (_a = MONTH_COLUMNS[getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker)]) === null || _a === void 0 ? void 0 : _a.grid;\n            return monthColumns === null || monthColumns === void 0 ? void 0 : monthColumns.map(function (month, i) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__month-wrapper\", key: i }, month.map(function (m, j) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: _this.MONTH_REFS[m], key: j, onClick: function (event) {\n                    _this.onMonthClick(event, m);\n                }, onKeyDown: function (event) {\n                    if (isSpaceKeyDown(event)) {\n                        event.preventDefault();\n                        event.key = KeyType.Enter;\n                    }\n                    _this.onMonthKeyDown(event, m);\n                }, onMouseEnter: !_this.props.usePointerEvent\n                    ? function () { return _this.onMonthMouseEnter(m); }\n                    : undefined, onPointerEnter: _this.props.usePointerEvent\n                    ? function () { return _this.onMonthMouseEnter(m); }\n                    : undefined, tabIndex: Number(_this.getTabIndex(m)), className: _this.getMonthClassNames(m), \"aria-disabled\": _this.isMonthDisabled(m), role: \"option\", \"aria-label\": _this.getAriaLabel(m), \"aria-current\": _this.isCurrentMonth(day, m) ? \"date\" : undefined, \"aria-selected\": selected ? _this.isSelectedMonth(day, m, selected) : undefined }, _this.getMonthContent(m))); }))); });\n        };\n        _this.renderQuarters = function () {\n            var _a = _this.props, day = _a.day, selected = _a.selected;\n            var quarters = [1, 2, 3, 4];\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__quarter-wrapper\" }, quarters.map(function (q, j) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: j, ref: _this.QUARTER_REFS[j], role: \"option\", onClick: function (event) {\n                    _this.onQuarterClick(event, q);\n                }, onKeyDown: function (event) {\n                    _this.onQuarterKeyDown(event, q);\n                }, onMouseEnter: !_this.props.usePointerEvent\n                    ? function () { return _this.onQuarterMouseEnter(q); }\n                    : undefined, onPointerEnter: _this.props.usePointerEvent\n                    ? function () { return _this.onQuarterMouseEnter(q); }\n                    : undefined, className: _this.getQuarterClassNames(q), \"aria-selected\": selected ? _this.isSelectedQuarter(day, q, selected) : undefined, tabIndex: Number(_this.getQuarterTabIndex(q)), \"aria-current\": _this.isCurrentQuarter(day, q) ? \"date\" : undefined }, _this.getQuarterContent(q))); })));\n        };\n        _this.getClassNames = function () {\n            var _a = _this.props, selectingDate = _a.selectingDate, selectsStart = _a.selectsStart, selectsEnd = _a.selectsEnd, showMonthYearPicker = _a.showMonthYearPicker, showQuarterYearPicker = _a.showQuarterYearPicker, showWeekPicker = _a.showWeekPicker;\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__month\", {\n                \"react-datepicker__month--selecting-range\": selectingDate && (selectsStart || selectsEnd),\n            }, { \"react-datepicker__monthPicker\": showMonthYearPicker }, { \"react-datepicker__quarterPicker\": showQuarterYearPicker }, { \"react-datepicker__weekPicker\": showWeekPicker });\n        };\n        return _this;\n    }\n    Month.prototype.getSelection = function () {\n        var _a = this.props, selected = _a.selected, selectedDates = _a.selectedDates, selectsMultiple = _a.selectsMultiple;\n        if (selectsMultiple) {\n            return selectedDates;\n        }\n        if (selected) {\n            return [selected];\n        }\n        return undefined;\n    };\n    Month.prototype.render = function () {\n        var _a = this.props, showMonthYearPicker = _a.showMonthYearPicker, showQuarterYearPicker = _a.showQuarterYearPicker, day = _a.day, _b = _a.ariaLabelPrefix, ariaLabelPrefix = _b === void 0 ? \"Month \" : _b;\n        var formattedAriaLabelPrefix = ariaLabelPrefix\n            ? ariaLabelPrefix.trim() + \" \"\n            : \"\";\n        // Format aria-label, return empty string if date is invalid\n        var formattedAriaLabel = isValid(day)\n            ? \"\".concat(formattedAriaLabelPrefix).concat(formatDate(day, \"MMMM, yyyy\", this.props.locale))\n            : \"\";\n        var shouldUseListboxRole = showMonthYearPicker || showQuarterYearPicker;\n        if (shouldUseListboxRole) {\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: this.getClassNames(), onMouseLeave: !this.props.usePointerEvent ? this.handleMouseLeave : undefined, onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : undefined, \"aria-label\": formattedAriaLabel, role: \"listbox\" }, showMonthYearPicker ? this.renderMonths() : this.renderQuarters()));\n        }\n        // For regular calendar view, use table structure\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { role: \"table\" },\n            this.props.dayNamesHeader && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { role: \"rowgroup\" }, this.props.dayNamesHeader)),\n            this.props.monthHeader && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { role: \"rowgroup\" }, this.props.monthHeader)),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: this.getClassNames(), onMouseLeave: !this.props.usePointerEvent ? this.handleMouseLeave : undefined, onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : undefined, \"aria-label\": formattedAriaLabel, role: \"rowgroup\" }, this.renderWeeks()),\n            this.props.monthFooter && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { role: \"rowgroup\" }, this.props.monthFooter))));\n    };\n    return Month;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar MonthDropdownOptions = /** @class */ (function (_super) {\n    __extends(MonthDropdownOptions, _super);\n    function MonthDropdownOptions() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.monthOptionButtonsRef = {};\n        _this.isSelectedMonth = function (i) { return _this.props.month === i; };\n        _this.handleOptionKeyDown = function (i, e) {\n            var _a;\n            switch (e.key) {\n                case \"Enter\":\n                    e.preventDefault();\n                    _this.onChange(i);\n                    break;\n                case \"Escape\":\n                    e.preventDefault();\n                    _this.props.onCancel();\n                    break;\n                case \"ArrowUp\":\n                case \"ArrowDown\": {\n                    e.preventDefault();\n                    var newMonth = (i + (e.key === \"ArrowUp\" ? -1 : 1) + _this.props.monthNames.length) %\n                        _this.props.monthNames.length;\n                    (_a = _this.monthOptionButtonsRef[newMonth]) === null || _a === void 0 ? void 0 : _a.focus();\n                    break;\n                }\n            }\n        };\n        _this.renderOptions = function () {\n            // Clear refs to prevent memory leaks on re-render\n            _this.monthOptionButtonsRef = {};\n            return _this.props.monthNames.map(function (month, i) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: function (el) {\n                    _this.monthOptionButtonsRef[i] = el;\n                    if (_this.isSelectedMonth(i)) {\n                        el === null || el === void 0 ? void 0 : el.focus();\n                    }\n                }, role: \"button\", tabIndex: 0, className: _this.isSelectedMonth(i)\n                    ? \"react-datepicker__month-option react-datepicker__month-option--selected_month\"\n                    : \"react-datepicker__month-option\", key: month, onClick: _this.onChange.bind(_this, i), onKeyDown: _this.handleOptionKeyDown.bind(_this, i), \"aria-selected\": _this.isSelectedMonth(i) ? \"true\" : undefined },\n                _this.isSelectedMonth(i) ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-option--selected\" }, \"\\u2713\")) : (\"\"),\n                month)); });\n        };\n        _this.onChange = function (month) { return _this.props.onChange(month); };\n        _this.handleClickOutside = function () { return _this.props.onCancel(); };\n        return _this;\n    }\n    MonthDropdownOptions.prototype.render = function () {\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { className: \"react-datepicker__month-dropdown\", onClickOutside: this.handleClickOutside }, this.renderOptions()));\n    };\n    return MonthDropdownOptions;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar MonthDropdown = /** @class */ (function (_super) {\n    __extends(MonthDropdown, _super);\n    function MonthDropdown() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            dropdownVisible: false,\n        };\n        _this.renderSelectOptions = function (monthNames) {\n            return monthNames.map(function (m, i) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"option\", { key: m, value: i }, m)); });\n        };\n        _this.renderSelectMode = function (monthNames) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"select\", { value: _this.props.month, className: \"react-datepicker__month-select\", onChange: function (e) { return _this.onChange(parseInt(e.target.value)); } }, _this.renderSelectOptions(monthNames))); };\n        _this.renderReadView = function (visible, monthNames) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { key: \"read\", type: \"button\", style: { visibility: visible ? \"visible\" : \"hidden\" }, className: \"react-datepicker__month-read-view\", onClick: _this.toggleDropdown },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-read-view--down-arrow\" }),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-read-view--selected-month\" }, monthNames[_this.props.month]))); };\n        _this.renderDropdown = function (monthNames) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthDropdownOptions, _assign({ key: \"dropdown\" }, _this.props, { monthNames: monthNames, onChange: _this.onChange, onCancel: _this.toggleDropdown }))); };\n        _this.renderScrollMode = function (monthNames) {\n            var dropdownVisible = _this.state.dropdownVisible;\n            var result = [_this.renderReadView(!dropdownVisible, monthNames)];\n            if (dropdownVisible) {\n                result.unshift(_this.renderDropdown(monthNames));\n            }\n            return result;\n        };\n        _this.onChange = function (month) {\n            _this.toggleDropdown();\n            if (month !== _this.props.month) {\n                _this.props.onChange(month);\n            }\n        };\n        _this.toggleDropdown = function () {\n            return _this.setState({\n                dropdownVisible: !_this.state.dropdownVisible,\n            });\n        };\n        return _this;\n    }\n    MonthDropdown.prototype.render = function () {\n        var _this = this;\n        var monthNames = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown\n            ? function (m) { return getMonthShortInLocale(m, _this.props.locale); }\n            : function (m) { return getMonthInLocale(m, _this.props.locale); });\n        var renderedDropdown;\n        switch (this.props.dropdownMode) {\n            case \"scroll\":\n                renderedDropdown = this.renderScrollMode(monthNames);\n                break;\n            case \"select\":\n                renderedDropdown = this.renderSelectMode(monthNames);\n                break;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--\".concat(this.props.dropdownMode) }, renderedDropdown));\n    };\n    return MonthDropdown;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nfunction generateMonthYears(minDate, maxDate) {\n    var list = [];\n    var currDate = getStartOfMonth(minDate);\n    var lastDate = getStartOfMonth(maxDate);\n    while (!(0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(currDate, lastDate)) {\n        list.push(newDate(currDate));\n        currDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(currDate, 1);\n    }\n    return list;\n}\nvar MonthYearDropdownOptions = /** @class */ (function (_super) {\n    __extends(MonthYearDropdownOptions, _super);\n    function MonthYearDropdownOptions(props) {\n        var _this = _super.call(this, props) || this;\n        _this.renderOptions = function () {\n            return _this.state.monthYearsList.map(function (monthYear) {\n                var monthYearPoint = (0,date_fns__WEBPACK_IMPORTED_MODULE_57__.getTime)(monthYear);\n                var isSameMonthYear = isSameYear(_this.props.date, monthYear) &&\n                    isSameMonth(_this.props.date, monthYear);\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: isSameMonthYear\n                        ? \"react-datepicker__month-year-option--selected_month-year\"\n                        : \"react-datepicker__month-year-option\", key: monthYearPoint, onClick: _this.onChange.bind(_this, monthYearPoint), \"aria-selected\": isSameMonthYear ? \"true\" : undefined },\n                    isSameMonthYear ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-year-option--selected\" }, \"\\u2713\")) : (\"\"),\n                    formatDate(monthYear, _this.props.dateFormat, _this.props.locale)));\n            });\n        };\n        _this.onChange = function (monthYear) { return _this.props.onChange(monthYear); };\n        _this.handleClickOutside = function () {\n            _this.props.onCancel();\n        };\n        _this.state = {\n            monthYearsList: generateMonthYears(_this.props.minDate, _this.props.maxDate),\n        };\n        return _this;\n    }\n    MonthYearDropdownOptions.prototype.render = function () {\n        var dropdownClass = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)({\n            \"react-datepicker__month-year-dropdown\": true,\n            \"react-datepicker__month-year-dropdown--scrollable\": this.props.scrollableMonthYearDropdown,\n        });\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { className: dropdownClass, onClickOutside: this.handleClickOutside }, this.renderOptions()));\n    };\n    return MonthYearDropdownOptions;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar MonthYearDropdown = /** @class */ (function (_super) {\n    __extends(MonthYearDropdown, _super);\n    function MonthYearDropdown() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            dropdownVisible: false,\n        };\n        _this.renderSelectOptions = function () {\n            var currDate = getStartOfMonth(_this.props.minDate);\n            var lastDate = getStartOfMonth(_this.props.maxDate);\n            var options = [];\n            while (!(0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(currDate, lastDate)) {\n                var timePoint = (0,date_fns__WEBPACK_IMPORTED_MODULE_57__.getTime)(currDate);\n                options.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"option\", { key: timePoint, value: timePoint }, formatDate(currDate, _this.props.dateFormat, _this.props.locale)));\n                currDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(currDate, 1);\n            }\n            return options;\n        };\n        _this.onSelectChange = function (event) {\n            _this.onChange(parseInt(event.target.value));\n        };\n        _this.renderSelectMode = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"select\", { value: (0,date_fns__WEBPACK_IMPORTED_MODULE_57__.getTime)(getStartOfMonth(_this.props.date)), className: \"react-datepicker__month-year-select\", onChange: _this.onSelectChange }, _this.renderSelectOptions())); };\n        _this.renderReadView = function (visible) {\n            var yearMonth = formatDate(_this.props.date, _this.props.dateFormat, _this.props.locale);\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: \"read\", style: { visibility: visible ? \"visible\" : \"hidden\" }, className: \"react-datepicker__month-year-read-view\", onClick: _this.toggleDropdown },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-year-read-view--down-arrow\" }),\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-year-read-view--selected-month-year\" }, yearMonth)));\n        };\n        _this.renderDropdown = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthYearDropdownOptions, _assign({ key: \"dropdown\" }, _this.props, { onChange: _this.onChange, onCancel: _this.toggleDropdown }))); };\n        _this.renderScrollMode = function () {\n            var dropdownVisible = _this.state.dropdownVisible;\n            var result = [_this.renderReadView(!dropdownVisible)];\n            if (dropdownVisible) {\n                result.unshift(_this.renderDropdown());\n            }\n            return result;\n        };\n        _this.onChange = function (monthYearPoint) {\n            _this.toggleDropdown();\n            var changedDate = newDate(monthYearPoint);\n            if (isSameYear(_this.props.date, changedDate) &&\n                isSameMonth(_this.props.date, changedDate)) {\n                return;\n            }\n            _this.props.onChange(changedDate);\n        };\n        _this.toggleDropdown = function () {\n            return _this.setState({\n                dropdownVisible: !_this.state.dropdownVisible,\n            });\n        };\n        return _this;\n    }\n    MonthYearDropdown.prototype.render = function () {\n        var renderedDropdown;\n        switch (this.props.dropdownMode) {\n            case \"scroll\":\n                renderedDropdown = this.renderScrollMode();\n                break;\n            case \"select\":\n                renderedDropdown = this.renderSelectMode();\n                break;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--\".concat(this.props.dropdownMode) }, renderedDropdown));\n    };\n    return MonthYearDropdown;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar Time = /** @class */ (function (_super) {\n    __extends(Time, _super);\n    function Time() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            height: null,\n        };\n        _this.scrollToTheSelectedTime = function () {\n            requestAnimationFrame(function () {\n                var _a, _b, _c;\n                if (!_this.list)\n                    return;\n                _this.list.scrollTop =\n                    (_c = (_this.centerLi &&\n                        Time.calcCenterPosition(_this.props.monthRef\n                            ? _this.props.monthRef.clientHeight -\n                                ((_b = (_a = _this.header) === null || _a === void 0 ? void 0 : _a.clientHeight) !== null && _b !== void 0 ? _b : 0)\n                            : _this.list.clientHeight, _this.centerLi))) !== null && _c !== void 0 ? _c : 0;\n            });\n        };\n        _this.handleClick = function (time) {\n            var _a, _b;\n            if (((_this.props.minTime || _this.props.maxTime) &&\n                isTimeInDisabledRange(time, _this.props)) ||\n                ((_this.props.excludeTimes ||\n                    _this.props.includeTimes ||\n                    _this.props.filterTime) &&\n                    isTimeDisabled(time, _this.props))) {\n                return;\n            }\n            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, time);\n        };\n        _this.isSelectedTime = function (time) {\n            return _this.props.selected && isSameMinute(_this.props.selected, time);\n        };\n        _this.isDisabledTime = function (time) {\n            return ((_this.props.minTime || _this.props.maxTime) &&\n                isTimeInDisabledRange(time, _this.props)) ||\n                ((_this.props.excludeTimes ||\n                    _this.props.includeTimes ||\n                    _this.props.filterTime) &&\n                    isTimeDisabled(time, _this.props));\n        };\n        _this.liClasses = function (time) {\n            var _a;\n            var classes = [\n                \"react-datepicker__time-list-item\",\n                _this.props.timeClassName ? _this.props.timeClassName(time) : undefined,\n            ];\n            if (_this.isSelectedTime(time)) {\n                classes.push(\"react-datepicker__time-list-item--selected\");\n            }\n            if (_this.isDisabledTime(time)) {\n                classes.push(\"react-datepicker__time-list-item--disabled\");\n            }\n            //convert this.props.intervals and the relevant time to seconds and check if it it's a clean multiple of the interval\n            if (_this.props.injectTimes &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time) * 3600 + (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time) * 60 + (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(time)) %\n                    (((_a = _this.props.intervals) !== null && _a !== void 0 ? _a : Time.defaultProps.intervals) * 60) !==\n                    0) {\n                classes.push(\"react-datepicker__time-list-item--injected\");\n            }\n            return classes.join(\" \");\n        };\n        _this.handleOnKeyDown = function (event, time) {\n            var _a, _b;\n            if (event.key === KeyType.Space) {\n                event.preventDefault();\n                event.key = KeyType.Enter;\n            }\n            if ((event.key === KeyType.ArrowUp || event.key === KeyType.ArrowLeft) &&\n                event.target instanceof HTMLElement &&\n                event.target.previousSibling) {\n                event.preventDefault();\n                event.target.previousSibling instanceof HTMLElement &&\n                    event.target.previousSibling.focus();\n            }\n            if ((event.key === KeyType.ArrowDown || event.key === KeyType.ArrowRight) &&\n                event.target instanceof HTMLElement &&\n                event.target.nextSibling) {\n                event.preventDefault();\n                event.target.nextSibling instanceof HTMLElement &&\n                    event.target.nextSibling.focus();\n            }\n            if (event.key === KeyType.Enter) {\n                _this.handleClick(time);\n            }\n            (_b = (_a = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.renderTimes = function () {\n            var _a;\n            var times = [];\n            var format = typeof _this.props.format === \"string\" ? _this.props.format : \"p\";\n            var intervals = (_a = _this.props.intervals) !== null && _a !== void 0 ? _a : Time.defaultProps.intervals;\n            var activeDate = _this.props.selected || _this.props.openToDate || newDate();\n            var base = getStartOfDay(activeDate);\n            var sortedInjectTimes = _this.props.injectTimes &&\n                _this.props.injectTimes.sort(function (a, b) {\n                    return a.getTime() - b.getTime();\n                });\n            var minutesInDay = 60 * getHoursInDay(activeDate);\n            var multiplier = minutesInDay / intervals;\n            for (var i = 0; i < multiplier; i++) {\n                var currentTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_49__.addMinutes)(base, i * intervals);\n                times.push(currentTime);\n                if (sortedInjectTimes) {\n                    var timesToInject = timesToInjectAfter(base, currentTime, i, intervals, sortedInjectTimes);\n                    times = times.concat(timesToInject);\n                }\n            }\n            // Determine which time to focus and scroll into view when component mounts\n            var timeToFocus = times.reduce(function (prev, time) {\n                if (time.getTime() <= activeDate.getTime()) {\n                    return time;\n                }\n                return prev;\n            }, times[0]);\n            return times.map(function (time) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"li\", { key: time.valueOf(), onClick: _this.handleClick.bind(_this, time), className: _this.liClasses(time), ref: function (li) {\n                        if (time === timeToFocus) {\n                            _this.centerLi = li;\n                        }\n                    }, onKeyDown: function (event) {\n                        _this.handleOnKeyDown(event, time);\n                    }, tabIndex: time === timeToFocus ? 0 : -1, role: \"option\", \"aria-selected\": _this.isSelectedTime(time) ? \"true\" : undefined, \"aria-disabled\": _this.isDisabledTime(time) ? \"true\" : undefined }, formatDate(time, format, _this.props.locale)));\n            });\n        };\n        _this.renderTimeCaption = function () {\n            if (_this.props.showTimeCaption === false) {\n                return react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null);\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header react-datepicker__header--time \".concat(_this.props.showTimeSelectOnly\n                    ? \"react-datepicker__header--time--only\"\n                    : \"\"), ref: function (header) {\n                    _this.header = header;\n                } },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__header\" }, _this.props.timeCaption)));\n        };\n        return _this;\n    }\n    Object.defineProperty(Time, \"defaultProps\", {\n        get: function () {\n            return {\n                intervals: 30,\n                todayButton: null,\n                timeCaption: \"Time\",\n                showTimeCaption: true,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Time.prototype.componentDidMount = function () {\n        // code to ensure selected time will always be in focus within time window when it first appears\n        this.scrollToTheSelectedTime();\n        this.observeDatePickerHeightChanges();\n    };\n    Time.prototype.componentWillUnmount = function () {\n        var _a;\n        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    };\n    Time.prototype.observeDatePickerHeightChanges = function () {\n        var _this = this;\n        var monthRef = this.props.monthRef;\n        this.updateContainerHeight();\n        if (monthRef) {\n            this.resizeObserver = new ResizeObserver(function () {\n                _this.updateContainerHeight();\n            });\n            this.resizeObserver.observe(monthRef);\n        }\n    };\n    Time.prototype.updateContainerHeight = function () {\n        if (this.props.monthRef && this.header) {\n            var newHeight = this.props.monthRef.clientHeight - this.header.clientHeight;\n            // Only update state if height actually changed to prevent infinite resize loops\n            if (this.state.height !== newHeight) {\n                this.setState({\n                    height: newHeight,\n                });\n            }\n        }\n    };\n    Time.prototype.render = function () {\n        var _this = this;\n        var _a;\n        var height = this.state.height;\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__time-container \".concat(((_a = this.props.todayButton) !== null && _a !== void 0 ? _a : Time.defaultProps.todayButton)\n                ? \"react-datepicker__time-container--with-today-button\"\n                : \"\") },\n            this.renderTimeCaption(),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__time\" },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__time-box\" },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"ul\", { className: \"react-datepicker__time-list\", ref: function (list) {\n                            _this.list = list;\n                        }, style: height ? { height: height } : {}, role: \"listbox\", \"aria-label\": this.props.timeCaption }, this.renderTimes())))));\n    };\n    Time.calcCenterPosition = function (listHeight, centerLiRef) {\n        return (centerLiRef.offsetTop - (listHeight / 2 - centerLiRef.clientHeight / 2));\n    };\n    return Time;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar VERTICAL_NAVIGATION_OFFSET = 3;\n/**\n * `Year` is a component that represents a year in a date picker.\n *\n * @class\n * @param {YearProps} props - The properties that define the `Year` component.\n * @property {VoidFunction} [props.clearSelectingDate] - Function to clear the selected date.\n * @property {Date} [props.date] - The currently selected date.\n * @property {boolean} [props.disabledKeyboardNavigation] - If true, keyboard navigation is disabled.\n * @property {Date} [props.endDate] - The end date in a range selection.\n * @property {(date: Date) => void} props.onDayClick - Function to handle day click events.\n * @property {Date} props.preSelection - The date that is currently in focus.\n * @property {(date: Date) => void} props.setPreSelection - Function to set the pre-selected date.\n * @property {{ [key: string]: any }} props.selected - The selected date(s).\n * @property {boolean} props.inline - If true, the date picker is displayed inline.\n * @property {Date} props.maxDate - The maximum selectable date.\n * @property {Date} props.minDate - The minimum selectable date.\n * @property {boolean} props.usePointerEvent - If true, pointer events are used instead of mouse events.\n * @property {(date: Date) => void} props.onYearMouseEnter - Function to handle mouse enter events on a year.\n * @property {(date: Date) => void} props.onYearMouseLeave - Function to handle mouse leave events on a year.\n */\nvar Year = /** @class */ (function (_super) {\n    __extends(Year, _super);\n    function Year(props) {\n        var _this = _super.call(this, props) || this;\n        _this.YEAR_REFS = __spreadArray([], Array(_this.props.yearItemNumber), true).map(function () {\n            return (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        });\n        _this.isDisabled = function (date) {\n            return isDayDisabled(date, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n            });\n        };\n        _this.isExcluded = function (date) {\n            return isDayExcluded(date, {\n                excludeDates: _this.props.excludeDates,\n            });\n        };\n        _this.selectingDate = function () { var _a; return (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection; };\n        _this.updateFocusOnPaginate = function (refIndex) {\n            var waitForReRender = function () {\n                var _a, _b;\n                (_b = (_a = _this.YEAR_REFS[refIndex]) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.focus();\n            };\n            window.requestAnimationFrame(waitForReRender);\n        };\n        _this.handleYearClick = function (day, event) {\n            if (_this.props.onDayClick) {\n                _this.props.onDayClick(day, event);\n            }\n        };\n        _this.handleYearNavigation = function (newYear, newDate) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, date = _e.date, yearItemNumber = _e.yearItemNumber;\n            if (date === undefined || yearItemNumber === undefined) {\n                return;\n            }\n            var startPeriod = getYearsPeriod(date, yearItemNumber).startPeriod;\n            if (_this.isDisabled(newDate) || _this.isExcluded(newDate)) {\n                return;\n            }\n            (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, newDate);\n            if (newYear - startPeriod < 0) {\n                _this.updateFocusOnPaginate(yearItemNumber - (startPeriod - newYear));\n            }\n            else if (newYear - startPeriod >= yearItemNumber) {\n                _this.updateFocusOnPaginate(Math.abs(yearItemNumber - (newYear - startPeriod)));\n            }\n            else\n                (_d = (_c = _this.YEAR_REFS[newYear - startPeriod]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();\n        };\n        _this.isSameDay = function (y, other) { return isSameDay(y, other); };\n        _this.isCurrentYear = function (y) { return y === (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(newDate()); };\n        _this.isRangeStart = function (y) {\n            return _this.props.startDate &&\n                _this.props.endDate &&\n                isSameYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y), _this.props.startDate);\n        };\n        _this.isRangeEnd = function (y) {\n            return _this.props.startDate &&\n                _this.props.endDate &&\n                isSameYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y), _this.props.endDate);\n        };\n        _this.isInRange = function (y) {\n            return isYearInRange(y, _this.props.startDate, _this.props.endDate);\n        };\n        _this.isInSelectingRange = function (y) {\n            var _a = _this.props, selectsStart = _a.selectsStart, selectsEnd = _a.selectsEnd, selectsRange = _a.selectsRange, startDate = _a.startDate, endDate = _a.endDate;\n            if (!(selectsStart || selectsEnd || selectsRange) ||\n                !_this.selectingDate()) {\n                return false;\n            }\n            if (selectsStart && endDate) {\n                return isYearInRange(y, _this.selectingDate(), endDate);\n            }\n            if (selectsEnd && startDate) {\n                return isYearInRange(y, startDate, _this.selectingDate());\n            }\n            if (selectsRange && startDate && !endDate) {\n                return isYearInRange(y, startDate, _this.selectingDate());\n            }\n            return false;\n        };\n        _this.isSelectingRangeStart = function (y) {\n            var _a;\n            if (!_this.isInSelectingRange(y)) {\n                return false;\n            }\n            var _b = _this.props, startDate = _b.startDate, selectsStart = _b.selectsStart;\n            var _year = (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y);\n            if (selectsStart) {\n                return isSameYear(_year, (_a = _this.selectingDate()) !== null && _a !== void 0 ? _a : null);\n            }\n            return isSameYear(_year, startDate !== null && startDate !== void 0 ? startDate : null);\n        };\n        _this.isSelectingRangeEnd = function (y) {\n            var _a;\n            if (!_this.isInSelectingRange(y)) {\n                return false;\n            }\n            var _b = _this.props, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange;\n            var _year = (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y);\n            if (selectsEnd || selectsRange) {\n                return isSameYear(_year, (_a = _this.selectingDate()) !== null && _a !== void 0 ? _a : null);\n            }\n            return isSameYear(_year, endDate !== null && endDate !== void 0 ? endDate : null);\n        };\n        _this.isKeyboardSelected = function (y) {\n            if (_this.props.disabledKeyboardNavigation ||\n                _this.props.date === undefined ||\n                _this.props.preSelection == null) {\n                return;\n            }\n            var _a = _this.props, minDate = _a.minDate, maxDate = _a.maxDate, excludeDates = _a.excludeDates, includeDates = _a.includeDates, filterDate = _a.filterDate, selected = _a.selected;\n            var date = getStartOfYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(_this.props.date, y));\n            var isDisabled = (minDate || maxDate || excludeDates || includeDates || filterDate) &&\n                isYearDisabled(y, _this.props);\n            var isSelectedDay = !!selected && isSameDay(date, getStartOfYear(selected));\n            var isKeyboardSelectedDay = isSameDay(date, getStartOfYear(_this.props.preSelection));\n            return (!_this.props.inline &&\n                !isSelectedDay &&\n                isKeyboardSelectedDay &&\n                !isDisabled);\n        };\n        _this.isSelectedYear = function (year) {\n            var _a = _this.props, selectsMultiple = _a.selectsMultiple, selected = _a.selected, selectedDates = _a.selectedDates;\n            if (selectsMultiple) {\n                return selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.some(function (date) { return year === (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(date); });\n            }\n            return !!selected && year === (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(selected);\n        };\n        _this.onYearClick = function (event, y) {\n            var date = _this.props.date;\n            if (date === undefined) {\n                return;\n            }\n            _this.handleYearClick(getStartOfYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(date, y)), event);\n        };\n        _this.onYearKeyDown = function (event, y) {\n            var _a, _b;\n            var key = event.key;\n            var _c = _this.props, date = _c.date, yearItemNumber = _c.yearItemNumber, handleOnKeyDown = _c.handleOnKeyDown;\n            if (key !== KeyType.Tab) {\n                // preventDefault on tab event blocks focus change\n                event.preventDefault();\n            }\n            if (!_this.props.disabledKeyboardNavigation) {\n                switch (key) {\n                    case KeyType.Enter:\n                        if (_this.props.selected == null) {\n                            break;\n                        }\n                        _this.onYearClick(event, y);\n                        (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.selected);\n                        break;\n                    case KeyType.ArrowRight:\n                        if (_this.props.preSelection == null) {\n                            break;\n                        }\n                        _this.handleYearNavigation(y + 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(_this.props.preSelection, 1));\n                        break;\n                    case KeyType.ArrowLeft:\n                        if (_this.props.preSelection == null) {\n                            break;\n                        }\n                        _this.handleYearNavigation(y - 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_42__.subYears)(_this.props.preSelection, 1));\n                        break;\n                    case KeyType.ArrowUp: {\n                        if (date === undefined ||\n                            yearItemNumber === undefined ||\n                            _this.props.preSelection == null) {\n                            break;\n                        }\n                        var startPeriod = getYearsPeriod(date, yearItemNumber).startPeriod;\n                        var offset = VERTICAL_NAVIGATION_OFFSET;\n                        var newYear = y - offset;\n                        if (newYear < startPeriod) {\n                            var leftOverOffset = yearItemNumber % offset;\n                            if (y >= startPeriod && y < startPeriod + leftOverOffset) {\n                                offset = leftOverOffset;\n                            }\n                            else {\n                                offset += leftOverOffset;\n                            }\n                            newYear = y - offset;\n                        }\n                        _this.handleYearNavigation(newYear, (0,date_fns__WEBPACK_IMPORTED_MODULE_42__.subYears)(_this.props.preSelection, offset));\n                        break;\n                    }\n                    case KeyType.ArrowDown: {\n                        if (date === undefined ||\n                            yearItemNumber === undefined ||\n                            _this.props.preSelection == null) {\n                            break;\n                        }\n                        var endPeriod = getYearsPeriod(date, yearItemNumber).endPeriod;\n                        var offset = VERTICAL_NAVIGATION_OFFSET;\n                        var newYear = y + offset;\n                        if (newYear > endPeriod) {\n                            var leftOverOffset = yearItemNumber % offset;\n                            if (y <= endPeriod && y > endPeriod - leftOverOffset) {\n                                offset = leftOverOffset;\n                            }\n                            else {\n                                offset += leftOverOffset;\n                            }\n                            newYear = y + offset;\n                        }\n                        _this.handleYearNavigation(newYear, (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(_this.props.preSelection, offset));\n                        break;\n                    }\n                }\n            }\n            handleOnKeyDown && handleOnKeyDown(event);\n        };\n        _this.getYearClassNames = function (y) {\n            var _a = _this.props, date = _a.date, disabled = _a.disabled, minDate = _a.minDate, maxDate = _a.maxDate, excludeDates = _a.excludeDates, includeDates = _a.includeDates, filterDate = _a.filterDate, yearClassName = _a.yearClassName;\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__year-text\", \"react-datepicker__year-\".concat(y), date ? yearClassName === null || yearClassName === void 0 ? void 0 : yearClassName((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(date, y)) : undefined, {\n                \"react-datepicker__year-text--selected\": _this.isSelectedYear(y),\n                \"react-datepicker__year-text--disabled\": (minDate ||\n                    maxDate ||\n                    excludeDates ||\n                    includeDates ||\n                    filterDate ||\n                    disabled) &&\n                    isYearDisabled(y, _this.props),\n                \"react-datepicker__year-text--keyboard-selected\": _this.isKeyboardSelected(y),\n                \"react-datepicker__year-text--range-start\": _this.isRangeStart(y),\n                \"react-datepicker__year-text--range-end\": _this.isRangeEnd(y),\n                \"react-datepicker__year-text--in-range\": _this.isInRange(y),\n                \"react-datepicker__year-text--in-selecting-range\": _this.isInSelectingRange(y),\n                \"react-datepicker__year-text--selecting-range-start\": _this.isSelectingRangeStart(y),\n                \"react-datepicker__year-text--selecting-range-end\": _this.isSelectingRangeEnd(y),\n                \"react-datepicker__year-text--today\": _this.isCurrentYear(y),\n            });\n        };\n        _this.getYearTabIndex = function (y) {\n            if (_this.props.disabledKeyboardNavigation ||\n                _this.props.preSelection == null) {\n                return \"-1\";\n            }\n            var preSelected = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.props.preSelection);\n            var isPreSelectedYearDisabled = isYearDisabled(y, _this.props);\n            return y === preSelected && !isPreSelectedYearDisabled ? \"0\" : \"-1\";\n        };\n        _this.getYearContent = function (y) {\n            return _this.props.renderYearContent ? _this.props.renderYearContent(y) : y;\n        };\n        return _this;\n    }\n    Year.prototype.render = function () {\n        var _this = this;\n        var yearsList = [];\n        var _a = this.props, date = _a.date, yearItemNumber = _a.yearItemNumber, onYearMouseEnter = _a.onYearMouseEnter, onYearMouseLeave = _a.onYearMouseLeave;\n        if (date === undefined) {\n            return null;\n        }\n        var _b = getYearsPeriod(date, yearItemNumber), startPeriod = _b.startPeriod, endPeriod = _b.endPeriod;\n        var _loop_1 = function (y) {\n            yearsList.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: this_1.YEAR_REFS[y - startPeriod], onClick: function (event) {\n                    _this.onYearClick(event, y);\n                }, onKeyDown: function (event) {\n                    if (isSpaceKeyDown(event)) {\n                        event.preventDefault();\n                        event.key = KeyType.Enter;\n                    }\n                    _this.onYearKeyDown(event, y);\n                }, tabIndex: Number(this_1.getYearTabIndex(y)), className: this_1.getYearClassNames(y), onMouseEnter: !this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseEnter(event, y); }\n                    : undefined, onPointerEnter: this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseEnter(event, y); }\n                    : undefined, onMouseLeave: !this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseLeave(event, y); }\n                    : undefined, onPointerLeave: this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseLeave(event, y); }\n                    : undefined, key: y, \"aria-current\": this_1.isCurrentYear(y) ? \"date\" : undefined }, this_1.getYearContent(y)));\n        };\n        var this_1 = this;\n        for (var y = startPeriod; y <= endPeriod; y++) {\n            _loop_1(y);\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year\" },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-wrapper\", onMouseLeave: !this.props.usePointerEvent\n                    ? this.props.clearSelectingDate\n                    : undefined, onPointerLeave: this.props.usePointerEvent\n                    ? this.props.clearSelectingDate\n                    : undefined }, yearsList)));\n    };\n    return Year;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nfunction generateYears(year, noOfYear, minDate, maxDate) {\n    var list = [];\n    for (var i = 0; i < 2 * noOfYear + 1; i++) {\n        var newYear = year + noOfYear - i;\n        var isInRange = true;\n        if (minDate) {\n            isInRange = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(minDate) <= newYear;\n        }\n        if (maxDate && isInRange) {\n            isInRange = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(maxDate) >= newYear;\n        }\n        if (isInRange) {\n            list.push(newYear);\n        }\n    }\n    return list;\n}\nvar YearDropdownOptions = /** @class */ (function (_super) {\n    __extends(YearDropdownOptions, _super);\n    function YearDropdownOptions(props) {\n        var _this = _super.call(this, props) || this;\n        _this.yearOptionButtonsRef = {};\n        _this.handleOptionKeyDown = function (year, e) {\n            var _a;\n            switch (e.key) {\n                case \"Enter\":\n                    e.preventDefault();\n                    _this.onChange(year);\n                    break;\n                case \"Escape\":\n                    e.preventDefault();\n                    _this.props.onCancel();\n                    break;\n                case \"ArrowUp\":\n                case \"ArrowDown\": {\n                    e.preventDefault();\n                    var newYear = year + (e.key === \"ArrowUp\" ? 1 : -1);\n                    // Add bounds checking to ensure the year exists in our refs\n                    if (_this.yearOptionButtonsRef[newYear]) {\n                        (_a = _this.yearOptionButtonsRef[newYear]) === null || _a === void 0 ? void 0 : _a.focus();\n                    }\n                    break;\n                }\n            }\n        };\n        _this.renderOptions = function () {\n            // Clear refs to prevent memory leaks on re-render\n            _this.yearOptionButtonsRef = {};\n            var selectedYear = _this.props.year;\n            var options = _this.state.yearsList.map(function (year) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: function (el) {\n                    _this.yearOptionButtonsRef[year] = el;\n                    if (year === selectedYear) {\n                        el === null || el === void 0 ? void 0 : el.focus();\n                    }\n                }, role: \"button\", tabIndex: 0, className: selectedYear === year\n                    ? \"react-datepicker__year-option react-datepicker__year-option--selected_year\"\n                    : \"react-datepicker__year-option\", key: year, onClick: _this.onChange.bind(_this, year), onKeyDown: _this.handleOptionKeyDown.bind(_this, year), \"aria-selected\": selectedYear === year ? \"true\" : undefined },\n                selectedYear === year ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__year-option--selected\" }, \"\\u2713\")) : (\"\"),\n                year)); });\n            var minYear = _this.props.minDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.props.minDate) : null;\n            var maxYear = _this.props.maxDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.props.maxDate) : null;\n            if (!maxYear || !_this.state.yearsList.find(function (year) { return year === maxYear; })) {\n                options.unshift(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-option\", key: \"upcoming\", onClick: _this.incrementYears },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"a\", { className: \"react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming\" })));\n            }\n            if (!minYear || !_this.state.yearsList.find(function (year) { return year === minYear; })) {\n                options.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-option\", key: \"previous\", onClick: _this.decrementYears },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"a\", { className: \"react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous\" })));\n            }\n            return options;\n        };\n        _this.onChange = function (year) {\n            _this.props.onChange(year);\n        };\n        _this.handleClickOutside = function () {\n            _this.props.onCancel();\n        };\n        _this.shiftYears = function (amount) {\n            var years = _this.state.yearsList.map(function (year) {\n                return year + amount;\n            });\n            _this.setState({\n                yearsList: years,\n            });\n        };\n        _this.incrementYears = function () {\n            return _this.shiftYears(1);\n        };\n        _this.decrementYears = function () {\n            return _this.shiftYears(-1);\n        };\n        var yearDropdownItemNumber = props.yearDropdownItemNumber, scrollableYearDropdown = props.scrollableYearDropdown;\n        var noOfYear = yearDropdownItemNumber || (scrollableYearDropdown ? 10 : 5);\n        _this.state = {\n            yearsList: generateYears(_this.props.year, noOfYear, _this.props.minDate, _this.props.maxDate),\n        };\n        _this.dropdownRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    YearDropdownOptions.prototype.componentDidMount = function () {\n        var dropdownCurrent = this.dropdownRef.current;\n        if (dropdownCurrent) {\n            // Get array from HTMLCollection\n            var dropdownCurrentChildren = dropdownCurrent.children\n                ? Array.from(dropdownCurrent.children)\n                : null;\n            var selectedYearOptionEl = dropdownCurrentChildren\n                ? dropdownCurrentChildren.find(function (childEl) { return childEl.ariaSelected; })\n                : null;\n            dropdownCurrent.scrollTop =\n                selectedYearOptionEl && selectedYearOptionEl instanceof HTMLElement\n                    ? selectedYearOptionEl.offsetTop +\n                        (selectedYearOptionEl.clientHeight - dropdownCurrent.clientHeight) /\n                            2\n                    : (dropdownCurrent.scrollHeight - dropdownCurrent.clientHeight) / 2;\n        }\n    };\n    YearDropdownOptions.prototype.render = function () {\n        var dropdownClass = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)({\n            \"react-datepicker__year-dropdown\": true,\n            \"react-datepicker__year-dropdown--scrollable\": this.props.scrollableYearDropdown,\n        });\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { className: dropdownClass, containerRef: this.dropdownRef, onClickOutside: this.handleClickOutside }, this.renderOptions()));\n    };\n    return YearDropdownOptions;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar YearDropdown = /** @class */ (function (_super) {\n    __extends(YearDropdown, _super);\n    function YearDropdown() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            dropdownVisible: false,\n        };\n        _this.renderSelectOptions = function () {\n            var minYear = _this.props.minDate\n                ? (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.props.minDate)\n                : 1900;\n            var maxYear = _this.props.maxDate\n                ? (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.props.maxDate)\n                : 2100;\n            var options = [];\n            for (var i = minYear; i <= maxYear; i++) {\n                options.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"option\", { key: i, value: i }, i));\n            }\n            return options;\n        };\n        _this.onSelectChange = function (event) {\n            _this.onChange(parseInt(event.target.value));\n        };\n        _this.renderSelectMode = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"select\", { value: _this.props.year, className: \"react-datepicker__year-select\", onChange: _this.onSelectChange }, _this.renderSelectOptions())); };\n        _this.renderReadView = function (visible) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { key: \"read\", type: \"button\", style: { visibility: visible ? \"visible\" : \"hidden\" }, className: \"react-datepicker__year-read-view\", onClick: _this.toggleDropdown },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__year-read-view--down-arrow\" }),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__year-read-view--selected-year\" }, _this.props.year))); };\n        _this.renderDropdown = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(YearDropdownOptions, _assign({ key: \"dropdown\" }, _this.props, { onChange: _this.onChange, onCancel: _this.toggleDropdown }))); };\n        _this.renderScrollMode = function () {\n            var dropdownVisible = _this.state.dropdownVisible;\n            var result = [_this.renderReadView(!dropdownVisible)];\n            if (dropdownVisible) {\n                result.unshift(_this.renderDropdown());\n            }\n            return result;\n        };\n        _this.onChange = function (year) {\n            _this.toggleDropdown();\n            if (year === _this.props.year)\n                return;\n            _this.props.onChange(year);\n        };\n        _this.toggleDropdown = function (event) {\n            _this.setState({\n                dropdownVisible: !_this.state.dropdownVisible,\n            }, function () {\n                if (_this.props.adjustDateOnChange) {\n                    _this.handleYearChange(_this.props.date, event);\n                }\n            });\n        };\n        _this.handleYearChange = function (date, event) {\n            var _a;\n            (_a = _this.onSelect) === null || _a === void 0 ? void 0 : _a.call(_this, date, event);\n            _this.setOpen();\n        };\n        _this.onSelect = function (date, event) {\n            var _a, _b;\n            (_b = (_a = _this.props).onSelect) === null || _b === void 0 ? void 0 : _b.call(_a, date, event);\n        };\n        _this.setOpen = function () {\n            var _a, _b;\n            (_b = (_a = _this.props).setOpen) === null || _b === void 0 ? void 0 : _b.call(_a, true);\n        };\n        return _this;\n    }\n    YearDropdown.prototype.render = function () {\n        var renderedDropdown;\n        switch (this.props.dropdownMode) {\n            case \"scroll\":\n                renderedDropdown = this.renderScrollMode();\n                break;\n            case \"select\":\n                renderedDropdown = this.renderSelectMode();\n                break;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--\".concat(this.props.dropdownMode) }, renderedDropdown));\n    };\n    return YearDropdown;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar DROPDOWN_FOCUS_CLASSNAMES = [\n    \"react-datepicker__year-select\",\n    \"react-datepicker__month-select\",\n    \"react-datepicker__month-year-select\",\n];\nvar OUTSIDE_CLICK_IGNORE_CLASS = \"react-datepicker-ignore-onclickoutside\";\nvar isDropdownSelect = function (element) {\n    var classNames = (element.className || \"\").split(/\\s+/);\n    return DROPDOWN_FOCUS_CLASSNAMES.some(function (testClassname) { return classNames.indexOf(testClassname) >= 0; });\n};\nvar Calendar = /** @class */ (function (_super) {\n    __extends(Calendar, _super);\n    function Calendar(props) {\n        var _this = _super.call(this, props) || this;\n        _this.monthContainer = undefined;\n        _this.handleClickOutside = function (event) {\n            _this.props.onClickOutside(event);\n        };\n        _this.setClickOutsideRef = function () {\n            return _this.containerRef.current;\n        };\n        _this.handleDropdownFocus = function (event) {\n            var _a, _b;\n            if (isDropdownSelect(event.target)) {\n                (_b = (_a = _this.props).onDropdownFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            }\n        };\n        _this.getDateInView = function () {\n            var _a = _this.props, preSelection = _a.preSelection, selected = _a.selected, openToDate = _a.openToDate;\n            var minDate = getEffectiveMinDate(_this.props);\n            var maxDate = getEffectiveMaxDate(_this.props);\n            var current = newDate();\n            var initialDate = openToDate || selected || preSelection;\n            if (initialDate) {\n                return initialDate;\n            }\n            else {\n                if (minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(current, minDate)) {\n                    return minDate;\n                }\n                else if (maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(current, maxDate)) {\n                    return maxDate;\n                }\n            }\n            return current;\n        };\n        _this.increaseMonth = function () {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(date, 1),\n                });\n            }, function () { return _this.handleMonthChange(_this.state.date); });\n        };\n        _this.decreaseMonth = function () {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.subMonths)(date, 1),\n                });\n            }, function () { return _this.handleMonthChange(_this.state.date); });\n        };\n        _this.handleDayClick = function (day, event, monthSelectedIn) {\n            _this.props.onSelect(day, event, monthSelectedIn);\n            _this.props.setPreSelection && _this.props.setPreSelection(day);\n        };\n        _this.handleDayMouseEnter = function (day) {\n            _this.setState({ selectingDate: day });\n            _this.props.onDayMouseEnter && _this.props.onDayMouseEnter(day);\n        };\n        _this.handleMonthMouseLeave = function () {\n            _this.setState({ selectingDate: undefined });\n            _this.props.onMonthMouseLeave && _this.props.onMonthMouseLeave();\n        };\n        _this.handleYearMouseEnter = function (event, year) {\n            _this.setState({ selectingDate: (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), year) });\n            !!_this.props.onYearMouseEnter && _this.props.onYearMouseEnter(event, year);\n        };\n        _this.handleYearMouseLeave = function (event, year) {\n            !!_this.props.onYearMouseLeave && _this.props.onYearMouseLeave(event, year);\n        };\n        _this.handleYearChange = function (date) {\n            var _a, _b, _c, _d;\n            (_b = (_a = _this.props).onYearChange) === null || _b === void 0 ? void 0 : _b.call(_a, date);\n            _this.setState({ isRenderAriaLiveMessage: true });\n            if (_this.props.adjustDateOnChange) {\n                _this.props.onSelect(date);\n                (_d = (_c = _this.props).setOpen) === null || _d === void 0 ? void 0 : _d.call(_c, true);\n            }\n            _this.props.setPreSelection && _this.props.setPreSelection(date);\n        };\n        _this.getEnabledPreSelectionDateForMonth = function (date) {\n            if (!isDayDisabled(date, _this.props)) {\n                return date;\n            }\n            var startOfMonth = getStartOfMonth(date);\n            var endOfMonth = getEndOfMonth(date);\n            var totalDays = (0,date_fns__WEBPACK_IMPORTED_MODULE_59__.differenceInDays)(endOfMonth, startOfMonth);\n            var preSelectedDate = null;\n            for (var dayIdx = 0; dayIdx <= totalDays; dayIdx++) {\n                var processingDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfMonth, dayIdx);\n                if (!isDayDisabled(processingDate, _this.props)) {\n                    preSelectedDate = processingDate;\n                    break;\n                }\n            }\n            return preSelectedDate;\n        };\n        _this.handleMonthChange = function (date) {\n            var _a, _b, _c;\n            var enabledPreSelectionDate = (_a = _this.getEnabledPreSelectionDateForMonth(date)) !== null && _a !== void 0 ? _a : date;\n            _this.handleCustomMonthChange(enabledPreSelectionDate);\n            if (_this.props.adjustDateOnChange) {\n                _this.props.onSelect(enabledPreSelectionDate);\n                (_c = (_b = _this.props).setOpen) === null || _c === void 0 ? void 0 : _c.call(_b, true);\n            }\n            _this.props.setPreSelection &&\n                _this.props.setPreSelection(enabledPreSelectionDate);\n        };\n        _this.handleCustomMonthChange = function (date) {\n            var _a, _b;\n            (_b = (_a = _this.props).onMonthChange) === null || _b === void 0 ? void 0 : _b.call(_a, date);\n            _this.setState({ isRenderAriaLiveMessage: true });\n        };\n        _this.handleMonthYearChange = function (date) {\n            _this.handleYearChange(date);\n            _this.handleMonthChange(date);\n        };\n        _this.changeYear = function (year) {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(date, Number(year)),\n                });\n            }, function () { return _this.handleYearChange(_this.state.date); });\n        };\n        _this.changeMonth = function (month) {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(date, Number(month)),\n                });\n            }, function () {\n                var _a, _b;\n                _this.handleMonthChange(_this.state.date);\n                // Reset monthSelectedIn to 0 so the target month appears in the leftmost position\n                // This ensures consistent behavior when using changeMonth in custom headers\n                (_b = (_a = _this.props).onMonthSelectedInChange) === null || _b === void 0 ? void 0 : _b.call(_a, 0);\n            });\n        };\n        _this.changeMonthYear = function (monthYear) {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)((0,date_fns__WEBPACK_IMPORTED_MODULE_26__.setMonth)(date, (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(monthYear)), (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(monthYear)),\n                });\n            }, function () { return _this.handleMonthYearChange(_this.state.date); });\n        };\n        _this.header = function (date, customDayNameCount) {\n            if (date === void 0) { date = _this.state.date; }\n            if (customDayNameCount === void 0) { customDayNameCount = 0; }\n            // Return empty array if date is invalid\n            if (!isValid(date)) {\n                return [];\n            }\n            var disabled = _this.props.disabled;\n            var startOfWeek = getStartOfWeek(date, _this.props.locale, _this.props.calendarStartDay);\n            var dayNames = [];\n            if (_this.props.showWeekNumbers) {\n                dayNames.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: \"W\", className: \"react-datepicker__day-name \".concat(disabled ? \"react-datepicker__day-name--disabled\" : \"\"), role: \"columnheader\" },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__sr-only\" }, \"Week number\"),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { \"aria-hidden\": \"true\" }, _this.props.weekLabel || \"#\")));\n            }\n            return dayNames.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {\n                var day = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, offset);\n                var weekDayName = _this.formatWeekday(day, _this.props.locale);\n                var fullDayName = formatDate(day, \"EEEE\", _this.props.locale);\n                var weekDayClassName = _this.props.weekDayClassName\n                    ? _this.props.weekDayClassName(day)\n                    : undefined;\n                // Use custom render if provided\n                if (_this.props.renderCustomDayName) {\n                    var customContent = _this.props.renderCustomDayName({\n                        day: day,\n                        shortName: weekDayName,\n                        fullName: fullDayName,\n                        locale: _this.props.locale,\n                        customDayNameCount: customDayNameCount,\n                    });\n                    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: offset, role: \"columnheader\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__day-name\", weekDayClassName, disabled ? \"react-datepicker__day-name--disabled\" : \"\") }, customContent));\n                }\n                // Default render\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: offset, role: \"columnheader\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__day-name\", weekDayClassName, disabled ? \"react-datepicker__day-name--disabled\" : \"\") },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__sr-only\" }, fullDayName),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { \"aria-hidden\": \"true\" }, weekDayName)));\n            }));\n        };\n        _this.formatWeekday = function (day, locale) {\n            if (_this.props.formatWeekDay) {\n                return getFormattedWeekdayInLocale(day, _this.props.formatWeekDay, locale);\n            }\n            return _this.props.useWeekdaysShort\n                ? getWeekdayShortInLocale(day, locale)\n                : getWeekdayMinInLocale(day, locale);\n        };\n        _this.decreaseYear = function () {\n            _this.setState(function (_a) {\n                var _b;\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_42__.subYears)(date, _this.props.showYearPicker\n                        ? ((_b = _this.props.yearItemNumber) !== null && _b !== void 0 ? _b : Calendar.defaultProps.yearItemNumber)\n                        : 1),\n                });\n            }, function () { return _this.handleYearChange(_this.state.date); });\n        };\n        _this.clearSelectingDate = function () {\n            _this.setState({ selectingDate: undefined });\n        };\n        _this.renderPreviousButton = function () {\n            var _a, _b, _c;\n            if (_this.props.renderCustomHeader) {\n                return;\n            }\n            var monthsShown = (_a = _this.props.monthsShown) !== null && _a !== void 0 ? _a : Calendar.defaultProps.monthsShown;\n            var monthsToSubtract = _this.props.showPreviousMonths\n                ? monthsShown - 1\n                : 0;\n            var monthSelectedIn = (_b = _this.props.monthSelectedIn) !== null && _b !== void 0 ? _b : monthsToSubtract;\n            var fromMonthDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.subMonths)(_this.state.date, monthSelectedIn);\n            var allPrevDaysDisabled;\n            switch (true) {\n                case _this.props.disabled:\n                    allPrevDaysDisabled = true;\n                    break;\n                case _this.props.showMonthYearPicker:\n                    allPrevDaysDisabled = yearDisabledBefore(_this.state.date, _this.props);\n                    break;\n                case _this.props.showYearPicker:\n                    allPrevDaysDisabled = yearsDisabledBefore(_this.state.date, _this.props);\n                    break;\n                case _this.props.showQuarterYearPicker:\n                    allPrevDaysDisabled = quarterDisabledBefore(_this.state.date, _this.props);\n                    break;\n                default:\n                    allPrevDaysDisabled = monthDisabledBefore(fromMonthDate, _this.props);\n                    break;\n            }\n            if ((!((_c = _this.props.forceShowMonthNavigation) !== null && _c !== void 0 ? _c : Calendar.defaultProps.forceShowMonthNavigation) &&\n                !_this.props.showDisabledMonthNavigation &&\n                allPrevDaysDisabled) ||\n                _this.props.showTimeSelectOnly) {\n                return;\n            }\n            var iconClasses = [\n                \"react-datepicker__navigation-icon\",\n                \"react-datepicker__navigation-icon--previous\",\n            ];\n            var classes = [\n                \"react-datepicker__navigation\",\n                \"react-datepicker__navigation--previous\",\n            ];\n            var clickHandler = _this.decreaseMonth;\n            if (_this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker) {\n                clickHandler = _this.decreaseYear;\n            }\n            if (allPrevDaysDisabled && _this.props.showDisabledMonthNavigation) {\n                classes.push(\"react-datepicker__navigation--previous--disabled\");\n                clickHandler = undefined;\n            }\n            var isForYear = _this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker;\n            var _d = _this.props, _e = _d.previousMonthButtonLabel, previousMonthButtonLabel = _e === void 0 ? Calendar.defaultProps.previousMonthButtonLabel : _e, _f = _d.previousYearButtonLabel, previousYearButtonLabel = _f === void 0 ? Calendar.defaultProps.previousYearButtonLabel : _f;\n            var _g = _this.props, _h = _g.previousMonthAriaLabel, previousMonthAriaLabel = _h === void 0 ? typeof previousMonthButtonLabel === \"string\"\n                ? previousMonthButtonLabel\n                : \"Previous Month\" : _h, _j = _g.previousYearAriaLabel, previousYearAriaLabel = _j === void 0 ? typeof previousYearButtonLabel === \"string\"\n                ? previousYearButtonLabel\n                : \"Previous Year\" : _j;\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { type: \"button\", className: classes.join(\" \"), onClick: clickHandler, onKeyDown: _this.props.handleOnKeyDown, \"aria-label\": isForYear ? previousYearAriaLabel : previousMonthAriaLabel },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: iconClasses.join(\" \") }, isForYear ? previousYearButtonLabel : previousMonthButtonLabel)));\n        };\n        _this.increaseYear = function () {\n            _this.setState(function (_a) {\n                var _b;\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(date, _this.props.showYearPicker\n                        ? ((_b = _this.props.yearItemNumber) !== null && _b !== void 0 ? _b : Calendar.defaultProps.yearItemNumber)\n                        : 1),\n                });\n            }, function () { return _this.handleYearChange(_this.state.date); });\n        };\n        _this.renderNextButton = function () {\n            var _a;\n            if (_this.props.renderCustomHeader) {\n                return;\n            }\n            var allNextDaysDisabled;\n            switch (true) {\n                case _this.props.disabled:\n                    allNextDaysDisabled = true;\n                    break;\n                case _this.props.showMonthYearPicker:\n                    allNextDaysDisabled = yearDisabledAfter(_this.state.date, _this.props);\n                    break;\n                case _this.props.showYearPicker:\n                    allNextDaysDisabled = yearsDisabledAfter(_this.state.date, _this.props);\n                    break;\n                case _this.props.showQuarterYearPicker:\n                    allNextDaysDisabled = quarterDisabledAfter(_this.state.date, _this.props);\n                    break;\n                default:\n                    allNextDaysDisabled = monthDisabledAfter(_this.state.date, _this.props);\n                    break;\n            }\n            if ((!((_a = _this.props.forceShowMonthNavigation) !== null && _a !== void 0 ? _a : Calendar.defaultProps.forceShowMonthNavigation) &&\n                !_this.props.showDisabledMonthNavigation &&\n                allNextDaysDisabled) ||\n                _this.props.showTimeSelectOnly) {\n                return;\n            }\n            var classes = [\n                \"react-datepicker__navigation\",\n                \"react-datepicker__navigation--next\",\n            ];\n            var iconClasses = [\n                \"react-datepicker__navigation-icon\",\n                \"react-datepicker__navigation-icon--next\",\n            ];\n            if (_this.props.showTimeSelect) {\n                classes.push(\"react-datepicker__navigation--next--with-time\");\n            }\n            if (_this.props.todayButton) {\n                classes.push(\"react-datepicker__navigation--next--with-today-button\");\n            }\n            var clickHandler = _this.increaseMonth;\n            if (_this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker) {\n                clickHandler = _this.increaseYear;\n            }\n            if (allNextDaysDisabled && _this.props.showDisabledMonthNavigation) {\n                classes.push(\"react-datepicker__navigation--next--disabled\");\n                clickHandler = undefined;\n            }\n            var isForYear = _this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker;\n            var _b = _this.props, _c = _b.nextMonthButtonLabel, nextMonthButtonLabel = _c === void 0 ? Calendar.defaultProps.nextMonthButtonLabel : _c, _d = _b.nextYearButtonLabel, nextYearButtonLabel = _d === void 0 ? Calendar.defaultProps.nextYearButtonLabel : _d;\n            var _e = _this.props, _f = _e.nextMonthAriaLabel, nextMonthAriaLabel = _f === void 0 ? typeof nextMonthButtonLabel === \"string\"\n                ? nextMonthButtonLabel\n                : \"Next Month\" : _f, _g = _e.nextYearAriaLabel, nextYearAriaLabel = _g === void 0 ? typeof nextYearButtonLabel === \"string\"\n                ? nextYearButtonLabel\n                : \"Next Year\" : _g;\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { type: \"button\", className: classes.join(\" \"), onClick: clickHandler, onKeyDown: _this.props.handleOnKeyDown, \"aria-label\": isForYear ? nextYearAriaLabel : nextMonthAriaLabel },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: iconClasses.join(\" \") }, isForYear ? nextYearButtonLabel : nextMonthButtonLabel)));\n        };\n        _this.renderCurrentMonth = function (date) {\n            if (date === void 0) { date = _this.state.date; }\n            var classes = [\"react-datepicker__current-month\"];\n            if (_this.props.showYearDropdown) {\n                classes.push(\"react-datepicker__current-month--hasYearDropdown\");\n            }\n            if (_this.props.showMonthDropdown) {\n                classes.push(\"react-datepicker__current-month--hasMonthDropdown\");\n            }\n            if (_this.props.showMonthYearDropdown) {\n                classes.push(\"react-datepicker__current-month--hasMonthYearDropdown\");\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"h2\", { className: classes.join(\" \") }, isValid(date)\n                ? formatDate(date, _this.props.dateFormat, _this.props.locale)\n                : \"\"));\n        };\n        _this.renderYearDropdown = function (overrideHide) {\n            if (overrideHide === void 0) { overrideHide = false; }\n            if (!_this.props.showYearDropdown || overrideHide) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(YearDropdown, _assign({}, Calendar.defaultProps, _this.props, { date: _this.state.date, onChange: _this.changeYear, year: (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.state.date) })));\n        };\n        _this.renderMonthDropdown = function (overrideHide) {\n            if (overrideHide === void 0) { overrideHide = false; }\n            if (!_this.props.showMonthDropdown || overrideHide) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthDropdown, _assign({}, Calendar.defaultProps, _this.props, { month: (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(_this.state.date), onChange: _this.changeMonth })));\n        };\n        _this.renderMonthYearDropdown = function (overrideHide) {\n            if (overrideHide === void 0) { overrideHide = false; }\n            if (!_this.props.showMonthYearDropdown || overrideHide) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthYearDropdown, _assign({}, Calendar.defaultProps, _this.props, { date: _this.state.date, onChange: _this.changeMonthYear })));\n        };\n        _this.handleTodayButtonClick = function (event) {\n            _this.props.onSelect(getStartOfToday(), event);\n            _this.props.setPreSelection && _this.props.setPreSelection(getStartOfToday());\n        };\n        _this.renderTodayButton = function () {\n            if (!_this.props.todayButton || _this.props.showTimeSelectOnly) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__today-button\", onClick: _this.handleTodayButtonClick }, _this.props.todayButton));\n        };\n        _this.renderDayNamesHeader = function (monthDate, customDayNameCount) {\n            if (customDayNameCount === void 0) { customDayNameCount = 0; }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__day-names\", role: \"row\" }, _this.header(monthDate, customDayNameCount)));\n        };\n        _this.renderDefaultHeader = function (_a) {\n            var monthDate = _a.monthDate, i = _a.i;\n            var headerContent = (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__header\", {\n                    \"react-datepicker__header--has-time-select\": _this.props.showTimeSelect,\n                    \"react-datepicker__header--middle\": _this.props.monthHeaderPosition === \"middle\",\n                    \"react-datepicker__header--bottom\": _this.props.monthHeaderPosition === \"bottom\",\n                }) },\n                _this.renderCurrentMonth(monthDate),\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header__dropdown react-datepicker__header__dropdown--\".concat(_this.props.dropdownMode), onFocus: _this.handleDropdownFocus },\n                    _this.renderMonthDropdown(i !== 0),\n                    _this.renderMonthYearDropdown(i !== 0),\n                    _this.renderYearDropdown(i !== 0))));\n            // Top position: render header directly in default location\n            if (_this.props.monthHeaderPosition === \"top\") {\n                return headerContent;\n            }\n            // Middle/bottom positions: wrap with navigation buttons\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header-wrapper\" },\n                _this.renderPreviousButton() || null,\n                _this.renderNextButton() || null,\n                headerContent));\n        };\n        _this.renderCustomHeader = function (headerArgs) {\n            var _a, _b;\n            var monthDate = headerArgs.monthDate, i = headerArgs.i;\n            if ((_this.props.showTimeSelect && !_this.state.monthContainer) ||\n                _this.props.showTimeSelectOnly) {\n                return null;\n            }\n            var _c = _this.props, showYearPicker = _c.showYearPicker, yearItemNumber = _c.yearItemNumber;\n            var visibleYearsRange;\n            if (showYearPicker) {\n                var _d = getYearsPeriod(monthDate, yearItemNumber), startYear = _d.startPeriod, endYear = _d.endPeriod;\n                visibleYearsRange = {\n                    startYear: startYear,\n                    endYear: endYear,\n                };\n            }\n            var prevMonthButtonDisabled = monthDisabledBefore(_this.state.date, _this.props);\n            var nextMonthButtonDisabled = monthDisabledAfter(_this.state.date, _this.props);\n            var prevYearButtonDisabled = yearDisabledBefore(_this.state.date, _this.props);\n            var nextYearButtonDisabled = yearDisabledAfter(_this.state.date, _this.props);\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header react-datepicker__header--custom\", onFocus: _this.props.onDropdownFocus }, (_b = (_a = _this.props).renderCustomHeader) === null || _b === void 0 ? void 0 : _b.call(_a, _assign(_assign(_assign({}, _this.state), (showYearPicker && { visibleYearsRange: visibleYearsRange })), { customHeaderCount: i, monthDate: monthDate, changeMonth: _this.changeMonth, changeYear: _this.changeYear, decreaseMonth: _this.decreaseMonth, increaseMonth: _this.increaseMonth, decreaseYear: _this.decreaseYear, increaseYear: _this.increaseYear, prevMonthButtonDisabled: prevMonthButtonDisabled, nextMonthButtonDisabled: nextMonthButtonDisabled, prevYearButtonDisabled: prevYearButtonDisabled, nextYearButtonDisabled: nextYearButtonDisabled }))));\n        };\n        _this.renderYearHeader = function (_a) {\n            var monthDate = _a.monthDate;\n            var _b = _this.props, showYearPicker = _b.showYearPicker, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? Calendar.defaultProps.yearItemNumber : _c;\n            var _d = getYearsPeriod(monthDate, yearItemNumber), startPeriod = _d.startPeriod, endPeriod = _d.endPeriod;\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header react-datepicker-year-header\" }, showYearPicker ? \"\".concat(startPeriod, \" - \").concat(endPeriod) : (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(monthDate)));\n        };\n        _this.renderHeader = function (_a) {\n            var monthDate = _a.monthDate, _b = _a.i, i = _b === void 0 ? 0 : _b;\n            var headerArgs = { monthDate: monthDate, i: i };\n            switch (true) {\n                case _this.props.renderCustomHeader !== undefined:\n                    return _this.renderCustomHeader(headerArgs);\n                case _this.props.showMonthYearPicker ||\n                    _this.props.showQuarterYearPicker ||\n                    _this.props.showYearPicker:\n                    return _this.renderYearHeader(headerArgs);\n                default:\n                    return _this.renderDefaultHeader(headerArgs);\n            }\n        };\n        _this.renderMonths = function () {\n            var _a, _b;\n            if (_this.props.showTimeSelectOnly || _this.props.showYearPicker) {\n                return;\n            }\n            var monthList = [];\n            var monthsShown = (_a = _this.props.monthsShown) !== null && _a !== void 0 ? _a : Calendar.defaultProps.monthsShown;\n            var monthsToSubtract = _this.props.showPreviousMonths\n                ? monthsShown - 1\n                : 0;\n            var fromMonthDate = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker\n                ? (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(_this.state.date, monthsToSubtract)\n                : (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.subMonths)(_this.state.date, monthsToSubtract);\n            var monthSelectedIn = (_b = _this.props.monthSelectedIn) !== null && _b !== void 0 ? _b : monthsToSubtract;\n            for (var i = 0; i < monthsShown; ++i) {\n                var monthsToAdd = i - monthSelectedIn + monthsToSubtract;\n                var monthDate = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker\n                    ? (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(fromMonthDate, monthsToAdd)\n                    : (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(fromMonthDate, monthsToAdd);\n                var monthKey = \"month-\".concat(i);\n                var monthShowsDuplicateDaysEnd = i < monthsShown - 1;\n                var monthShowsDuplicateDaysStart = i > 0;\n                monthList.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: monthKey, ref: function (div) {\n                        _this.monthContainer = div !== null && div !== void 0 ? div : undefined;\n                    }, className: \"react-datepicker__month-container\" },\n                    _this.props.monthHeaderPosition === \"top\" &&\n                        _this.renderHeader({ monthDate: monthDate, i: i }),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Month, _assign({}, Calendar.defaultProps, _this.props, { containerRef: _this.containerRef, ariaLabelPrefix: _this.props.monthAriaLabelPrefix, day: monthDate, onDayClick: _this.handleDayClick, handleOnKeyDown: _this.props.handleOnDayKeyDown, handleOnMonthKeyDown: _this.props.handleOnKeyDown, onDayMouseEnter: _this.handleDayMouseEnter, onMouseLeave: _this.handleMonthMouseLeave, orderInDisplay: i, selectingDate: _this.state.selectingDate, monthShowsDuplicateDaysEnd: monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: monthShowsDuplicateDaysStart, dayNamesHeader: _this.renderDayNamesHeader(monthDate, i), monthHeader: _this.props.monthHeaderPosition === \"middle\"\n                            ? _this.renderHeader({ monthDate: monthDate, i: i })\n                            : undefined, monthFooter: _this.props.monthHeaderPosition === \"bottom\"\n                            ? _this.renderHeader({ monthDate: monthDate, i: i })\n                            : undefined }))));\n            }\n            return monthList;\n        };\n        _this.renderYears = function () {\n            if (_this.props.showTimeSelectOnly) {\n                return;\n            }\n            if (_this.props.showYearPicker) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year--container\" },\n                    _this.renderHeader({ monthDate: _this.state.date }),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Year, _assign({}, Calendar.defaultProps, _this.props, { selectingDate: _this.state.selectingDate, date: _this.state.date, onDayClick: _this.handleDayClick, clearSelectingDate: _this.clearSelectingDate, onYearMouseEnter: _this.handleYearMouseEnter, onYearMouseLeave: _this.handleYearMouseLeave }))));\n            }\n            return;\n        };\n        _this.renderTimeSection = function () {\n            if (_this.props.showTimeSelect &&\n                (_this.state.monthContainer || _this.props.showTimeSelectOnly)) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Time, _assign({}, Calendar.defaultProps, _this.props, { onChange: _this.props.onTimeChange, format: _this.props.timeFormat, intervals: _this.props.timeIntervals, monthRef: _this.state.monthContainer })));\n            }\n            return;\n        };\n        _this.renderInputTimeSection = function () {\n            var _a, _b;\n            if (!_this.props.showTimeInput) {\n                return;\n            }\n            // Handle selectsRange mode - render two time inputs\n            if (_this.props.selectsRange) {\n                var _c = _this.props, startDate = _c.startDate, endDate = _c.endDate;\n                var startTime = startDate ? new Date(startDate) : undefined;\n                var startTimeValid = startTime && isValid(startTime) && Boolean(startDate);\n                var startTimeString = startTimeValid\n                    ? \"\".concat(addZero(startTime.getHours()), \":\").concat(addZero(startTime.getMinutes()))\n                    : \"\";\n                var endTime = endDate ? new Date(endDate) : undefined;\n                var endTimeValid = endTime && isValid(endTime) && Boolean(endDate);\n                var endTimeString = endTimeValid\n                    ? \"\".concat(addZero(endTime.getHours()), \":\").concat(addZero(endTime.getMinutes()))\n                    : \"\";\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null,\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(InputTime, _assign({}, Calendar.defaultProps, _this.props, { date: startTime, timeString: startTimeString, onChange: function (time) {\n                            var _a, _b;\n                            (_b = (_a = _this.props).onTimeChange) === null || _b === void 0 ? void 0 : _b.call(_a, time, \"start\");\n                        }, timeInputLabel: ((_a = _this.props.timeInputLabel) !== null && _a !== void 0 ? _a : \"Time\") + \" (Start)\" })),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(InputTime, _assign({}, Calendar.defaultProps, _this.props, { date: endTime, timeString: endTimeString, onChange: function (time) {\n                            var _a, _b;\n                            (_b = (_a = _this.props).onTimeChange) === null || _b === void 0 ? void 0 : _b.call(_a, time, \"end\");\n                        }, timeInputLabel: ((_b = _this.props.timeInputLabel) !== null && _b !== void 0 ? _b : \"Time\") + \" (End)\" }))));\n            }\n            // Single date mode (original behavior)\n            var time = _this.props.selected\n                ? new Date(_this.props.selected)\n                : undefined;\n            var timeValid = time && isValid(time) && Boolean(_this.props.selected);\n            var timeString = timeValid\n                ? \"\".concat(addZero(time.getHours()), \":\").concat(addZero(time.getMinutes()))\n                : \"\";\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(InputTime, _assign({}, Calendar.defaultProps, _this.props, { date: time, timeString: timeString, onChange: function (time) {\n                    var _a, _b;\n                    (_b = (_a = _this.props).onTimeChange) === null || _b === void 0 ? void 0 : _b.call(_a, time);\n                } })));\n        };\n        _this.renderAriaLiveRegion = function () {\n            var _a;\n            // Don't render aria-live message if date is invalid\n            if (!isValid(_this.state.date)) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { role: \"alert\", \"aria-live\": \"polite\", className: \"react-datepicker__aria-live\" }));\n            }\n            var _b = getYearsPeriod(_this.state.date, (_a = _this.props.yearItemNumber) !== null && _a !== void 0 ? _a : Calendar.defaultProps.yearItemNumber), startPeriod = _b.startPeriod, endPeriod = _b.endPeriod;\n            var ariaLiveMessage;\n            if (_this.props.showYearPicker) {\n                ariaLiveMessage = \"\".concat(startPeriod, \" - \").concat(endPeriod);\n            }\n            else if (_this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker) {\n                ariaLiveMessage = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.state.date);\n            }\n            else {\n                ariaLiveMessage = \"\".concat(getMonthInLocale((0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(_this.state.date), _this.props.locale), \" \").concat((0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(_this.state.date));\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { role: \"alert\", \"aria-live\": \"polite\", className: \"react-datepicker__aria-live\" }, _this.state.isRenderAriaLiveMessage && ariaLiveMessage));\n        };\n        _this.renderChildren = function () {\n            if (_this.props.children) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__children-container\" }, _this.props.children));\n            }\n            return;\n        };\n        _this.containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            date: _this.getDateInView(),\n            selectingDate: undefined,\n            monthContainer: undefined,\n            isRenderAriaLiveMessage: false,\n        };\n        return _this;\n    }\n    Object.defineProperty(Calendar, \"defaultProps\", {\n        get: function () {\n            return {\n                monthsShown: 1,\n                forceShowMonthNavigation: false,\n                outsideClickIgnoreClass: OUTSIDE_CLICK_IGNORE_CLASS,\n                timeCaption: \"Time\",\n                previousYearButtonLabel: \"Previous Year\",\n                nextYearButtonLabel: \"Next Year\",\n                previousMonthButtonLabel: \"Previous Month\",\n                nextMonthButtonLabel: \"Next Month\",\n                yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER,\n                monthHeaderPosition: \"top\",\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Calendar.prototype.componentDidMount = function () {\n        var _this = this;\n        // monthContainer height is needed in time component\n        // to determine the height for the ul in the time component\n        // setState here so height is given after final component\n        // layout is rendered\n        if (this.props.showTimeSelect) {\n            this.assignMonthContainer = (function () {\n                _this.setState({ monthContainer: _this.monthContainer });\n            })();\n        }\n    };\n    Calendar.prototype.componentDidUpdate = function (prevProps) {\n        var _this = this;\n        if (this.props.preSelection &&\n            isValid(this.props.preSelection) &&\n            (!isSameDay(this.props.preSelection, prevProps.preSelection) ||\n                this.props.monthSelectedIn !== prevProps.monthSelectedIn)) {\n            var hasMonthChanged_1 = !isSameMonth(this.state.date, this.props.preSelection);\n            this.setState({\n                date: this.props.preSelection,\n            }, function () { return hasMonthChanged_1 && _this.handleCustomMonthChange(_this.state.date); });\n        }\n        else if (this.props.openToDate &&\n            !isSameDay(this.props.openToDate, prevProps.openToDate)) {\n            this.setState({\n                date: this.props.openToDate,\n            });\n        }\n    };\n    Calendar.prototype.render = function () {\n        var Container = this.props.container || CalendarContainer;\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { onClickOutside: this.handleClickOutside, style: { display: \"contents\" }, ignoreClass: this.props.outsideClickIgnoreClass },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { style: { display: \"contents\" }, ref: this.containerRef },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Container, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker\", this.props.className, {\n                        \"react-datepicker--time-only\": this.props.showTimeSelectOnly,\n                    }), showTime: this.props.showTimeSelect || this.props.showTimeInput, showTimeSelectOnly: this.props.showTimeSelectOnly, inline: this.props.inline },\n                    this.renderAriaLiveRegion(),\n                    this.props.monthHeaderPosition === \"top\" &&\n                        this.renderPreviousButton(),\n                    this.props.monthHeaderPosition === \"top\" &&\n                        this.renderNextButton(),\n                    this.renderMonths(),\n                    this.renderYears(),\n                    this.renderTodayButton(),\n                    this.renderTimeSection(),\n                    this.renderInputTimeSection(),\n                    this.renderChildren()))));\n    };\n    return Calendar;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\n/**\n * `CalendarIcon` is a React component that renders an icon for a calendar.\n * The icon can be a string representing a CSS class, a React node, or a default SVG icon.\n *\n * @component\n * @prop  icon - The icon to be displayed. This can be a string representing a CSS class or a React node.\n * @prop  className - An optional string representing additional CSS classes to be applied to the icon.\n * @prop  onClick - An optional function to be called when the icon is clicked.\n *\n * @example\n * // To use a CSS class as the icon\n * <CalendarIcon icon=\"my-icon-class\" onClick={myClickHandler} />\n *\n * @example\n * // To use a React node as the icon\n * <CalendarIcon icon={<MyIconComponent />} onClick={myClickHandler} />\n *\n * @returns  The `CalendarIcon` component.\n */\nvar CalendarIcon = function (_a) {\n    var icon = _a.icon, _b = _a.className, className = _b === void 0 ? \"\" : _b, onClick = _a.onClick;\n    var defaultClass = \"react-datepicker__calendar-icon\";\n    if (typeof icon === \"string\") {\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"i\", { className: \"\".concat(defaultClass, \" \").concat(icon, \" \").concat(className), \"aria-hidden\": \"true\", onClick: onClick }));\n    }\n    if (react__WEBPACK_IMPORTED_MODULE_1___default().isValidElement(icon)) {\n        // Because we are checking that typeof icon is string first, we can safely cast icon as React.ReactElement on types level and code level\n        var iconElement_1 = icon;\n        return react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(iconElement_1, {\n            className: \"\".concat(iconElement_1.props.className || \"\", \" \").concat(defaultClass, \" \").concat(className),\n            onClick: function (event) {\n                if (typeof iconElement_1.props.onClick === \"function\") {\n                    iconElement_1.props.onClick(event);\n                }\n                if (typeof onClick === \"function\") {\n                    onClick(event);\n                }\n            },\n        });\n    }\n    // Default SVG Icon\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"svg\", { className: \"\".concat(defaultClass, \" \").concat(className), xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 448 512\", onClick: onClick },\n        react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"path\", { d: \"M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z\" })));\n};\n\n/**\n * `Portal` is a React component that allows you to render children into a DOM node\n * that exists outside the DOM hierarchy of the parent component.\n *\n * @class\n * @param {PortalProps} props - The properties that define the `Portal` component.\n * @property {React.ReactNode} props.children - The children to be rendered into the `Portal`.\n * @property {string} props.portalId - The id of the DOM node into which the `Portal` will render.\n * @property {ShadowRoot} [props.portalHost] - The DOM node to host the `Portal`.\n */\nvar Portal = /** @class */ (function (_super) {\n    __extends(Portal, _super);\n    function Portal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.portalRoot = null;\n        _this.el = document.createElement(\"div\");\n        return _this;\n    }\n    Portal.prototype.componentDidMount = function () {\n        this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId);\n        if (!this.portalRoot) {\n            this.portalRoot = document.createElement(\"div\");\n            this.portalRoot.setAttribute(\"id\", this.props.portalId);\n            (this.props.portalHost || document.body).appendChild(this.portalRoot);\n        }\n        this.portalRoot.appendChild(this.el);\n    };\n    Portal.prototype.componentWillUnmount = function () {\n        if (this.portalRoot) {\n            this.portalRoot.removeChild(this.el);\n        }\n    };\n    Portal.prototype.render = function () {\n        return react_dom__WEBPACK_IMPORTED_MODULE_2___default().createPortal(this.props.children, this.el);\n    };\n    return Portal;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar focusableElementsSelector = \"[tabindex], a, button, input, select, textarea\";\nvar focusableFilter = function (node) {\n    if (node instanceof HTMLAnchorElement) {\n        return node.tabIndex !== -1;\n    }\n    return !node.disabled && node.tabIndex !== -1;\n};\n/**\n * `TabLoop` is a React component that manages tabbing behavior for its children.\n *\n * TabLoop prevents the user from tabbing outside of the popper\n * It creates a tabindex loop so that \"Tab\" on the last element will focus the first element\n * and \"Shift Tab\" on the first element will focus the last element\n *\n * @component\n * @example\n * <TabLoop enableTabLoop={true}>\n *   <ChildComponent />\n * </TabLoop>\n *\n * @param props - The properties that define the `TabLoop` component.\n * @param props.children - The child components.\n * @param props.enableTabLoop - Whether to enable the tab loop.\n *\n * @returns The `TabLoop` component.\n */\nvar TabLoop = /** @class */ (function (_super) {\n    __extends(TabLoop, _super);\n    function TabLoop(props) {\n        var _this = _super.call(this, props) || this;\n        /**\n         * `getTabChildren` is a method of the `TabLoop` class that retrieves all tabbable children of the component.\n         *\n         * This method uses the `tabbable` library to find all tabbable elements within the `TabLoop` component.\n         * It then filters out any elements that are not visible.\n         *\n         * @returns An array of all tabbable and visible children of the `TabLoop` component.\n         */\n        _this.getTabChildren = function () {\n            var _a;\n            return Array.prototype.slice\n                .call((_a = _this.tabLoopRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll(focusableElementsSelector), 1, -1)\n                .filter(focusableFilter);\n        };\n        _this.handleFocusStart = function () {\n            var tabChildren = _this.getTabChildren();\n            tabChildren &&\n                tabChildren.length > 1 &&\n                tabChildren[tabChildren.length - 1].focus();\n        };\n        _this.handleFocusEnd = function () {\n            var tabChildren = _this.getTabChildren();\n            tabChildren && tabChildren.length > 1 && tabChildren[0].focus();\n        };\n        _this.tabLoopRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    TabLoop.prototype.render = function () {\n        var _a;\n        if (!((_a = this.props.enableTabLoop) !== null && _a !== void 0 ? _a : TabLoop.defaultProps.enableTabLoop)) {\n            return this.props.children;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__tab-loop\", ref: this.tabLoopRef },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__tab-loop__start\", tabIndex: 0, onFocus: this.handleFocusStart }),\n            this.props.children,\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__tab-loop__end\", tabIndex: 0, onFocus: this.handleFocusEnd })));\n    };\n    TabLoop.defaultProps = {\n        enableTabLoop: true,\n    };\n    return TabLoop;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\n/**\n * `withFloating` is a higher-order component that adds floating behavior to a component.\n *\n * @param Component - The component to enhance.\n *\n * @example\n * const FloatingComponent = withFloating(MyComponent);\n * <FloatingComponent popperModifiers={[]} popperProps={{}} hidePopper={true} />\n *\n * @param popperModifiers - The modifiers to use for the popper.\n * @param popperProps - The props to pass to the popper.\n * @param hidePopper - Whether to hide the popper.\n * @param popperPlacement - The placement of the popper.\n *\n * @returns A new component with floating behavior.\n */\nfunction withFloating(Component) {\n    function WithFloating(props) {\n        var _a;\n        var hidePopper = typeof props.hidePopper === \"boolean\" ? props.hidePopper : true;\n        var arrowRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n        var floatingProps = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_60__.useFloating)(_assign({ open: !hidePopper, whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_61__.autoUpdate, placement: props.popperPlacement, middleware: __spreadArray([\n                (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_62__.flip)({ padding: 15 }),\n                (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_62__.offset)(10),\n                // eslint-disable-next-line react-hooks/refs -- Floating UI requires refs to be passed during render\n                (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_62__.arrow)({ element: arrowRef })\n            ], ((_a = props.popperModifiers) !== null && _a !== void 0 ? _a : []), true) }, props.popperProps));\n        var componentProps = _assign(_assign({}, props), { hidePopper: hidePopper, popperProps: _assign(_assign({}, floatingProps), { arrowRef: arrowRef }) });\n        return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Component, _assign({}, componentProps));\n    }\n    WithFloating.displayName = \"withFloating(\".concat(Component.displayName || Component.name || \"Component\", \")\");\n    return WithFloating;\n}\n\n// Exported for testing purposes\nvar PopperComponent$1 = function (props) {\n    var className = props.className, wrapperClassName = props.wrapperClassName, _a = props.hidePopper, hidePopper = _a === void 0 ? true : _a, popperComponent = props.popperComponent, targetComponent = props.targetComponent, enableTabLoop = props.enableTabLoop, popperOnKeyDown = props.popperOnKeyDown, portalId = props.portalId, portalHost = props.portalHost, popperProps = props.popperProps, showArrow = props.showArrow, popperTargetRef = props.popperTargetRef, monthHeaderPosition = props.monthHeaderPosition;\n    // When a custom popperTargetRef is provided, use it as the position reference\n    // This allows the popper to be positioned relative to a specific element\n    // within the custom input, rather than the wrapper div\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (popperTargetRef === null || popperTargetRef === void 0 ? void 0 : popperTargetRef.current) {\n            popperProps.refs.setPositionReference(popperTargetRef.current);\n        }\n    }, [popperTargetRef, popperProps.refs]);\n    var popper = undefined;\n    if (!hidePopper) {\n        var classes = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker-popper\", !showArrow && \"react-datepicker-popper-offset\", monthHeaderPosition === \"middle\" &&\n            \"react-datepicker-popper--header-middle\", monthHeaderPosition === \"bottom\" &&\n            \"react-datepicker-popper--header-bottom\", className);\n        popper = (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(TabLoop, { enableTabLoop: enableTabLoop },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: popperProps.refs.setFloating, style: popperProps.floatingStyles, className: classes, \"data-placement\": popperProps.placement, onKeyDown: popperOnKeyDown },\n                popperComponent,\n                showArrow && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_floating_ui_react__WEBPACK_IMPORTED_MODULE_60__.FloatingArrow, { ref: popperProps.arrowRef, context: popperProps.context, fill: \"currentColor\", strokeWidth: 1, height: 8, width: 16, style: { transform: \"translateY(-1px)\" }, className: \"react-datepicker__triangle\" })))));\n    }\n    if (props.popperContainer) {\n        popper = (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(props.popperContainer, {}, popper);\n    }\n    if (portalId && !hidePopper) {\n        popper = (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Portal, { portalId: portalId, portalHost: portalHost }, popper));\n    }\n    var wrapperClasses = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker-wrapper\", wrapperClassName);\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null,\n        react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: popperProps.refs.setReference, className: wrapperClasses }, targetComponent),\n        popper));\n};\nvar PopperComponent = withFloating(PopperComponent$1);\n\n// Compares dates year+month combinations\nfunction hasPreSelectionChanged(date1, date2) {\n    if (date1 && date2) {\n        return ((0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(date1) !== (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getMonth)(date2) || (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(date1) !== (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(date2));\n    }\n    return date1 !== date2;\n}\n/**\n * General datepicker component.\n */\nvar INPUT_ERR_1 = \"Date input not valid.\";\nvar DatePicker = /** @class */ (function (_super) {\n    __extends(DatePicker, _super);\n    function DatePicker(props) {\n        var _this = _super.call(this, props) || this;\n        _this.calendar = null;\n        _this.input = null;\n        _this.getPreSelection = function () {\n            var timeZone = _this.props.timeZone;\n            var baseDate = _this.props.openToDate\n                ? _this.props.openToDate\n                : _this.props.selectsEnd && _this.props.startDate\n                    ? _this.props.startDate\n                    : _this.props.selectsStart && _this.props.endDate\n                        ? _this.props.endDate\n                        : newDate();\n            // Convert to the specified timezone for display\n            return timeZone ? toZonedTime(baseDate, timeZone) : baseDate;\n        };\n        // Convert the date from string format to standard Date format\n        // Uses parseDate with ISO format to parse as local time, preventing\n        // dates from shifting in timezones west of UTC. See issue #6105.\n        _this.modifyHolidays = function () {\n            var _a;\n            return (_a = _this.props.holidays) === null || _a === void 0 ? void 0 : _a.reduce(function (accumulator, holiday) {\n                var date = parseDate(holiday.date, \"yyyy-MM-dd\", undefined, false);\n                if (!date) {\n                    return accumulator;\n                }\n                return __spreadArray(__spreadArray([], accumulator, true), [_assign(_assign({}, holiday), { date: date })], false);\n            }, []);\n        };\n        _this.calcInitialState = function () {\n            var timeZone = _this.props.timeZone;\n            var defaultPreSelection = _this.getPreSelection();\n            var minDate = getEffectiveMinDate(_this.props);\n            var maxDate = getEffectiveMaxDate(_this.props);\n            var boundedPreSelection = minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(defaultPreSelection, getStartOfDay(minDate))\n                ? minDate\n                : maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(defaultPreSelection, getEndOfDay(maxDate))\n                    ? maxDate\n                    : defaultPreSelection;\n            // Convert selected/startDate to zoned time for display if timezone is specified\n            var initialPreSelection = _this.props.selectsRange\n                ? _this.props.startDate\n                : _this.props.selected;\n            if (initialPreSelection && timeZone) {\n                initialPreSelection = toZonedTime(initialPreSelection, timeZone);\n            }\n            return {\n                open: _this.props.startOpen || false,\n                preventFocus: false,\n                inputValue: null,\n                preSelection: initialPreSelection !== null && initialPreSelection !== void 0 ? initialPreSelection : boundedPreSelection,\n                // transforming highlighted days (perhaps nested array)\n                // to flat Map for faster access in day.jsx\n                highlightDates: getHighLightDaysMap(_this.props.highlightDates),\n                focused: false,\n                // used to focus day in inline version after month has changed, but not on\n                // initial render\n                shouldFocusDayInline: false,\n                isRenderAriaLiveMessage: false,\n                wasHidden: false,\n            };\n        };\n        _this.getInputValue = function () {\n            var _a;\n            var _b = _this.props, locale = _b.locale, startDate = _b.startDate, endDate = _b.endDate, rangeSeparator = _b.rangeSeparator, selected = _b.selected, selectedDates = _b.selectedDates, selectsMultiple = _b.selectsMultiple, selectsRange = _b.selectsRange, formatMultipleDates = _b.formatMultipleDates, value = _b.value;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var inputValue = _this.state.inputValue;\n            if (typeof value === \"string\") {\n                return value;\n            }\n            else if (typeof inputValue === \"string\") {\n                return inputValue;\n            }\n            else if (selectsRange) {\n                return safeDateRangeFormat(startDate, endDate, {\n                    dateFormat: dateFormat,\n                    locale: locale,\n                    rangeSeparator: rangeSeparator,\n                });\n            }\n            else if (selectsMultiple) {\n                if (formatMultipleDates) {\n                    var formatDateFn = function (date) {\n                        return safeDateFormat(date, { dateFormat: dateFormat, locale: locale });\n                    };\n                    return formatMultipleDates(selectedDates !== null && selectedDates !== void 0 ? selectedDates : [], formatDateFn);\n                }\n                return safeMultipleDatesFormat(selectedDates !== null && selectedDates !== void 0 ? selectedDates : [], {\n                    dateFormat: dateFormat,\n                    locale: locale,\n                });\n            }\n            return safeDateFormat(selected, {\n                dateFormat: dateFormat,\n                locale: locale,\n            });\n        };\n        _this.resetHiddenStatus = function () {\n            _this.setState(_assign(_assign({}, _this.state), { wasHidden: false }));\n        };\n        _this.setHiddenStatus = function () {\n            _this.setState(_assign(_assign({}, _this.state), { wasHidden: true }));\n        };\n        _this.setHiddenStateOnVisibilityHidden = function () {\n            if (document.visibilityState !== \"hidden\") {\n                return;\n            }\n            _this.setHiddenStatus();\n        };\n        _this.clearPreventFocusTimeout = function () {\n            if (_this.preventFocusTimeout) {\n                clearTimeout(_this.preventFocusTimeout);\n            }\n        };\n        _this.setFocus = function () {\n            var _a, _b;\n            (_b = (_a = _this.input) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a, { preventScroll: true });\n        };\n        _this.setBlur = function () {\n            var _a, _b;\n            (_b = (_a = _this.input) === null || _a === void 0 ? void 0 : _a.blur) === null || _b === void 0 ? void 0 : _b.call(_a);\n            _this.cancelFocusInput();\n        };\n        _this.deferBlur = function () {\n            requestAnimationFrame(function () {\n                _this.setBlur();\n            });\n        };\n        _this.setOpen = function (open, skipSetBlur) {\n            if (skipSetBlur === void 0) { skipSetBlur = false; }\n            _this.setState({\n                open: open,\n                preSelection: open && _this.state.open\n                    ? _this.state.preSelection\n                    : _this.calcInitialState().preSelection,\n                lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE,\n            }, function () {\n                if (!open) {\n                    _this.setState(function (prev) { return ({\n                        focused: skipSetBlur ? prev.focused : false,\n                    }); }, function () {\n                        !skipSetBlur && _this.deferBlur();\n                        _this.setState({ inputValue: null });\n                    });\n                }\n            });\n        };\n        _this.inputOk = function () { return (0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(_this.state.preSelection); };\n        _this.isCalendarOpen = function () {\n            return _this.props.open === undefined\n                ? _this.state.open && !_this.props.disabled && !_this.props.readOnly\n                : _this.props.open;\n        };\n        _this.handleFocus = function (event) {\n            var _a, _b;\n            var isAutoReFocus = _this.state.wasHidden;\n            var isOpenAllowed = isAutoReFocus ? _this.state.open : true;\n            if (isAutoReFocus) {\n                _this.resetHiddenStatus();\n            }\n            if (!_this.state.preventFocus) {\n                (_b = (_a = _this.props).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n                if (isOpenAllowed &&\n                    !_this.props.preventOpenOnFocus &&\n                    !_this.props.readOnly) {\n                    _this.setOpen(true);\n                }\n            }\n            _this.setState({ focused: true });\n        };\n        _this.sendFocusBackToInput = function () {\n            // Clear previous timeout if it exists\n            if (_this.preventFocusTimeout) {\n                _this.clearPreventFocusTimeout();\n            }\n            // close the popper and refocus the input\n            // stop the input from auto opening onFocus\n            // setFocus to the input\n            _this.setState({ preventFocus: true }, function () {\n                _this.preventFocusTimeout = setTimeout(function () {\n                    _this.setFocus();\n                    _this.setState({ preventFocus: false });\n                });\n            });\n        };\n        _this.cancelFocusInput = function () {\n            clearTimeout(_this.inputFocusTimeout);\n            _this.inputFocusTimeout = undefined;\n        };\n        _this.deferFocusInput = function () {\n            _this.cancelFocusInput();\n            _this.inputFocusTimeout = setTimeout(function () { return _this.setFocus(); }, 1);\n        };\n        _this.handleDropdownFocus = function () {\n            _this.cancelFocusInput();\n        };\n        _this.resetInputValue = function () {\n            _this.setState(_assign(_assign({}, _this.state), { inputValue: null }));\n        };\n        _this.handleBlur = function (event) {\n            var _a, _b;\n            if (!_this.state.open || _this.props.withPortal || _this.props.showTimeInput) {\n                (_b = (_a = _this.props).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            }\n            _this.resetInputValue();\n            if (_this.state.open && _this.props.open === false) {\n                _this.setOpen(false);\n            }\n            _this.setState({ focused: false });\n        };\n        _this.handleCalendarClickOutside = function (event) {\n            var _a, _b;\n            if (!_this.props.inline) {\n                _this.setOpen(false);\n            }\n            (_b = (_a = _this.props).onClickOutside) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            if (_this.props.withPortal) {\n                event.preventDefault();\n            }\n        };\n        // handleChange is called when user types in the textbox\n        _this.handleChange = function () {\n            var _a, _b, _c, _d, _e, _f;\n            var allArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                allArgs[_i] = arguments[_i];\n            }\n            var event = allArgs[0];\n            if (_this.props.onChangeRaw) {\n                _this.props.onChangeRaw.apply(_this, allArgs);\n                if (!event ||\n                    typeof event.isDefaultPrevented !== \"function\" ||\n                    event.isDefaultPrevented()) {\n                    return;\n                }\n            }\n            _this.setState({\n                inputValue: (event === null || event === void 0 ? void 0 : event.target) instanceof HTMLInputElement ? event.target.value : null,\n                lastPreSelectChange: PRESELECT_CHANGE_VIA_INPUT,\n            });\n            var _g = _this.props, selectsRange = _g.selectsRange, startDate = _g.startDate, endDate = _g.endDate;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var strictParsing = (_b = _this.props.strictParsing) !== null && _b !== void 0 ? _b : DatePicker.defaultProps.strictParsing;\n            var value = (event === null || event === void 0 ? void 0 : event.target) instanceof HTMLInputElement ? event.target.value : \"\";\n            if (selectsRange) {\n                var rangeSeparator = _this.props.rangeSeparator;\n                var trimmedRangeSeparator = rangeSeparator.trim();\n                var _h = value\n                    .split(dateFormat.includes(trimmedRangeSeparator)\n                    ? rangeSeparator\n                    : trimmedRangeSeparator, 2)\n                    .map(function (val) { return val.trim(); }), valueStart = _h[0], valueEnd = _h[1];\n                var startDateNew = parseDate(valueStart !== null && valueStart !== void 0 ? valueStart : \"\", dateFormat, _this.props.locale, strictParsing);\n                var endDateNew = startDateNew\n                    ? parseDate(valueEnd !== null && valueEnd !== void 0 ? valueEnd : \"\", dateFormat, _this.props.locale, strictParsing)\n                    : null;\n                var startChanged = (startDate === null || startDate === void 0 ? void 0 : startDate.getTime()) !== (startDateNew === null || startDateNew === void 0 ? void 0 : startDateNew.getTime());\n                var endChanged = (endDate === null || endDate === void 0 ? void 0 : endDate.getTime()) !== (endDateNew === null || endDateNew === void 0 ? void 0 : endDateNew.getTime());\n                if (!startChanged && !endChanged) {\n                    return;\n                }\n                if (startDateNew && isDayDisabled(startDateNew, _this.props)) {\n                    return;\n                }\n                if (endDateNew && isDayDisabled(endDateNew, _this.props)) {\n                    return;\n                }\n                // Update preSelection to keep calendar viewport consistent when reopening\n                // Use startDate for preSelection to match calcInitialState behavior\n                if (startDateNew) {\n                    _this.setState({ preSelection: startDateNew });\n                }\n                (_d = (_c = _this.props).onChange) === null || _d === void 0 ? void 0 : _d.call(_c, [startDateNew, endDateNew], event);\n            }\n            else {\n                // not selectsRange\n                var date = parseDate(value, dateFormat, _this.props.locale, strictParsing, (_e = _this.props.selected) !== null && _e !== void 0 ? _e : undefined);\n                // Update selection if either (1) date was successfully parsed, or (2) input field is empty\n                if (date || !value) {\n                    _this.setSelected(date, event, true);\n                }\n                else if (!_this.props.inline) {\n                    // If full date parsing failed but we have partial input,\n                    // try to extract date info for calendar navigation\n                    var navDate = parseDateForNavigation(value, (_f = _this.state.preSelection) !== null && _f !== void 0 ? _f : undefined);\n                    // Only update preSelection if navDate is valid and within min/max bounds\n                    if (navDate &&\n                        (!_this.props.minDate || !(0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(navDate, _this.props.minDate)) &&\n                        (!_this.props.maxDate || !(0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(navDate, _this.props.maxDate))) {\n                        _this.setState({ preSelection: navDate });\n                    }\n                }\n            }\n        };\n        _this.handleSelect = function (date, event, monthSelectedIn) {\n            var _a;\n            if (_this.props.readOnly)\n                return;\n            var _b = _this.props, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate, locale = _b.locale, swapRange = _b.swapRange;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var isDateSelectionComplete = !selectsRange ||\n                (startDate && !endDate && (swapRange || !isDateBefore(date, startDate)));\n            if (_this.props.shouldCloseOnSelect &&\n                !_this.props.showTimeSelect &&\n                isDateSelectionComplete) {\n                // Preventing onFocus event to fix issue\n                // https://github.com/Hacker0x01/react-datepicker/issues/628\n                _this.sendFocusBackToInput();\n            }\n            if (_this.props.onChangeRaw) {\n                var formattedDate = safeDateFormat(date, {\n                    dateFormat: dateFormat,\n                    locale: locale,\n                });\n                _this.props.onChangeRaw(event, { date: date, formattedDate: formattedDate });\n            }\n            _this.setSelected(date, event, false, monthSelectedIn);\n            if (_this.props.showDateSelect) {\n                _this.setState({ isRenderAriaLiveMessage: true });\n            }\n            if (!_this.props.shouldCloseOnSelect || _this.props.showTimeSelect) {\n                _this.setPreSelection(date);\n            }\n            else if (isDateSelectionComplete) {\n                _this.setOpen(false);\n            }\n        };\n        // setSelected is called either from handleChange (user typed date into textbox and it was parsed) or handleSelect (user selected date from calendar using mouse or keyboard)\n        _this.setSelected = function (date, event, keepInput, monthSelectedIn) {\n            var _a, _b;\n            var timeZone = _this.props.timeZone;\n            // If timezone is specified, convert the selected date from zoned time to UTC\n            // This ensures the onChange callback receives a proper UTC Date object\n            var changedDate = date;\n            if (changedDate && timeZone) {\n                changedDate = fromZonedTime(changedDate, timeZone);\n            }\n            // Early return if selected year/month/day is disabled\n            if (_this.props.showYearPicker) {\n                if (changedDate !== null &&\n                    isYearDisabled((0,date_fns__WEBPACK_IMPORTED_MODULE_28__.getYear)(changedDate), _this.props)) {\n                    return;\n                }\n            }\n            else if (_this.props.showMonthYearPicker) {\n                if (changedDate !== null && isMonthDisabled(changedDate, _this.props)) {\n                    return;\n                }\n            }\n            else {\n                if (changedDate !== null && isDayDisabled(changedDate, _this.props)) {\n                    return;\n                }\n            }\n            var _c = _this.props, onChange = _c.onChange, selectsRange = _c.selectsRange, startDate = _c.startDate, endDate = _c.endDate, selectsMultiple = _c.selectsMultiple, selectedDates = _c.selectedDates, minTime = _c.minTime, swapRange = _c.swapRange;\n            if (!isEqual(_this.props.selected, changedDate) ||\n                _this.props.allowSameDay ||\n                selectsRange ||\n                selectsMultiple) {\n                if (changedDate !== null) {\n                    // Preserve previously selected time if only date is currently being changed\n                    if (_this.props.selected &&\n                        (!keepInput ||\n                            (!_this.props.showTimeSelect &&\n                                !_this.props.showTimeSelectOnly &&\n                                !_this.props.showTimeInput))) {\n                        changedDate = setTime(changedDate, {\n                            hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(_this.props.selected),\n                            minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(_this.props.selected),\n                            second: (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getSeconds)(_this.props.selected),\n                        });\n                    }\n                    // If minTime is present then set the time to minTime\n                    if (!keepInput &&\n                        (_this.props.showTimeSelect || _this.props.showTimeSelectOnly)) {\n                        if (minTime) {\n                            changedDate = setTime(changedDate, {\n                                hour: minTime.getHours(),\n                                minute: minTime.getMinutes(),\n                                second: minTime.getSeconds(),\n                            });\n                        }\n                    }\n                    if (!_this.props.inline) {\n                        _this.setState({\n                            preSelection: changedDate,\n                        });\n                    }\n                    if (!_this.props.focusSelectedMonth) {\n                        _this.setState({ monthSelectedIn: monthSelectedIn });\n                    }\n                }\n                if (selectsRange) {\n                    var noRanges = !startDate && !endDate;\n                    var hasStartRange = startDate && !endDate;\n                    var hasOnlyEndRange = !startDate && !!endDate;\n                    var isRangeFilled = startDate && endDate;\n                    if (noRanges) {\n                        onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                    }\n                    else if (hasStartRange) {\n                        if (changedDate === null) {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([null, null], event);\n                        }\n                        else if (isDateBefore(changedDate, startDate)) {\n                            if (swapRange) {\n                                onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, startDate], event);\n                            }\n                            else {\n                                onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                            }\n                        }\n                        else {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([startDate, changedDate], event);\n                        }\n                    }\n                    else if (hasOnlyEndRange) {\n                        if (changedDate && isDateBefore(changedDate, endDate)) {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, endDate], event);\n                        }\n                        else {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                        }\n                    }\n                    if (isRangeFilled) {\n                        onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                    }\n                }\n                else if (selectsMultiple) {\n                    if (changedDate !== null) {\n                        if (!(selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.length)) {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate], event);\n                        }\n                        else {\n                            var isChangedDateAlreadySelected = selectedDates.some(function (selectedDate) { return isSameDay(selectedDate, changedDate); });\n                            if (isChangedDateAlreadySelected) {\n                                var nextDates = selectedDates.filter(function (selectedDate) { return !isSameDay(selectedDate, changedDate); });\n                                onChange === null || onChange === void 0 ? void 0 : onChange(nextDates, event);\n                            }\n                            else {\n                                onChange === null || onChange === void 0 ? void 0 : onChange(__spreadArray(__spreadArray([], selectedDates, true), [changedDate], false), event);\n                            }\n                        }\n                    }\n                }\n                else {\n                    onChange === null || onChange === void 0 ? void 0 : onChange(changedDate, event);\n                }\n            }\n            if (!keepInput) {\n                (_b = (_a = _this.props).onSelect) === null || _b === void 0 ? void 0 : _b.call(_a, changedDate, event);\n                _this.setState({ inputValue: null });\n            }\n        };\n        // When checking preSelection via min/maxDate, times need to be manipulated via getStartOfDay/getEndOfDay\n        _this.setPreSelection = function (date) {\n            if (_this.props.readOnly)\n                return;\n            var hasMinDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(_this.props.minDate);\n            var hasMaxDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_47__.isDate)(_this.props.maxDate);\n            var isValidDateSelection = true;\n            if (date) {\n                var dateStartOfDay = getStartOfDay(date);\n                if (hasMinDate && hasMaxDate) {\n                    // isDayInRange uses getStartOfDay internally, so not necessary to manipulate times here\n                    isValidDateSelection = isDayInRange(date, _this.props.minDate, _this.props.maxDate);\n                }\n                else if (hasMinDate) {\n                    var minDateStartOfDay = getStartOfDay(_this.props.minDate);\n                    isValidDateSelection =\n                        (0,date_fns__WEBPACK_IMPORTED_MODULE_51__.isAfter)(date, minDateStartOfDay) ||\n                            isEqual(dateStartOfDay, minDateStartOfDay);\n                }\n                else if (hasMaxDate) {\n                    var maxDateEndOfDay = getEndOfDay(_this.props.maxDate);\n                    isValidDateSelection =\n                        (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isBefore)(date, maxDateEndOfDay) ||\n                            isEqual(dateStartOfDay, maxDateEndOfDay);\n                }\n            }\n            if (isValidDateSelection) {\n                _this.setState({\n                    preSelection: date,\n                });\n            }\n        };\n        _this.toggleCalendar = function () {\n            _this.setOpen(!_this.state.open);\n        };\n        _this.handleTimeChange = function (time, modifyDateType) {\n            var _a, _b;\n            if (_this.props.selectsMultiple) {\n                return;\n            }\n            var _c = _this.props, selectsRange = _c.selectsRange, startDate = _c.startDate, endDate = _c.endDate, onChange = _c.onChange, timeZone = _c.timeZone;\n            if (selectsRange) {\n                // In range mode, apply time to the appropriate date\n                // If modifyDateType is specified, use that to determine which date to modify\n                // Otherwise, use the legacy behavior:\n                // - If we have a startDate but no endDate, apply time to startDate\n                // - If we have both, apply time to endDate\n                if (modifyDateType === \"start\") {\n                    // Explicitly modify start date\n                    if (startDate) {\n                        var changedStartDate = setTime(startDate, {\n                            hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time),\n                            minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time),\n                        });\n                        _this.setState({\n                            preSelection: changedStartDate,\n                        });\n                        // Convert from zoned time to UTC if timezone is specified\n                        if (timeZone) {\n                            changedStartDate = fromZonedTime(changedStartDate, timeZone);\n                        }\n                        onChange === null || onChange === void 0 ? void 0 : onChange([\n                            changedStartDate,\n                            endDate\n                                ? timeZone\n                                    ? fromZonedTime(endDate, timeZone)\n                                    : endDate\n                                : null,\n                        ], undefined);\n                    }\n                }\n                else if (modifyDateType === \"end\") {\n                    // Explicitly modify end date\n                    if (endDate) {\n                        var changedEndDate = setTime(endDate, {\n                            hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time),\n                            minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time),\n                        });\n                        _this.setState({\n                            preSelection: changedEndDate,\n                        });\n                        // Convert from zoned time to UTC if timezone is specified\n                        if (timeZone) {\n                            changedEndDate = fromZonedTime(changedEndDate, timeZone);\n                        }\n                        onChange === null || onChange === void 0 ? void 0 : onChange([\n                            startDate\n                                ? timeZone\n                                    ? fromZonedTime(startDate, timeZone)\n                                    : startDate\n                                : null,\n                            changedEndDate,\n                        ], undefined);\n                    }\n                }\n                else {\n                    // Legacy behavior for showTimeSelect (single time picker)\n                    var hasStartRange = startDate && !endDate;\n                    if (hasStartRange) {\n                        // Apply time to startDate\n                        var changedStartDate = setTime(startDate, {\n                            hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time),\n                            minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time),\n                        });\n                        _this.setState({\n                            preSelection: changedStartDate,\n                        });\n                        // Convert from zoned time to UTC if timezone is specified\n                        if (timeZone) {\n                            changedStartDate = fromZonedTime(changedStartDate, timeZone);\n                        }\n                        onChange === null || onChange === void 0 ? void 0 : onChange([changedStartDate, null], undefined);\n                    }\n                    else if (startDate && endDate) {\n                        // Apply time to endDate\n                        var changedEndDate = setTime(endDate, {\n                            hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time),\n                            minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time),\n                        });\n                        _this.setState({\n                            preSelection: changedEndDate,\n                        });\n                        // Convert from zoned time to UTC if timezone is specified\n                        if (timeZone) {\n                            changedEndDate = fromZonedTime(changedEndDate, timeZone);\n                        }\n                        onChange === null || onChange === void 0 ? void 0 : onChange([\n                            timeZone ? fromZonedTime(startDate, timeZone) : startDate,\n                            changedEndDate,\n                        ], undefined);\n                    }\n                    else {\n                        // No dates selected yet, just update preSelection\n                        var changedDate = setTime(_this.getPreSelection(), {\n                            hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time),\n                            minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time),\n                        });\n                        _this.setState({\n                            preSelection: changedDate,\n                        });\n                    }\n                }\n            }\n            else {\n                // Single date mode (original behavior)\n                var selected = _this.props.selected\n                    ? _this.props.selected\n                    : _this.getPreSelection();\n                var changedDate = _this.props.selected\n                    ? time\n                    : setTime(selected, {\n                        hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(time),\n                        minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(time),\n                    });\n                _this.setState({\n                    preSelection: changedDate,\n                });\n                // Convert from zoned time to UTC if timezone is specified\n                if (changedDate && timeZone) {\n                    changedDate = fromZonedTime(changedDate, timeZone);\n                }\n                (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, changedDate);\n            }\n            if (_this.props.shouldCloseOnSelect && !_this.props.showTimeInput) {\n                _this.sendFocusBackToInput();\n                _this.setOpen(false);\n            }\n            if (_this.props.showTimeInput) {\n                _this.setOpen(true);\n            }\n            if (_this.props.showTimeSelectOnly || _this.props.showTimeSelect) {\n                _this.setState({ isRenderAriaLiveMessage: true });\n            }\n            _this.setState({ inputValue: null });\n        };\n        _this.onInputClick = function () {\n            var _a, _b;\n            if (!_this.props.disabled && !_this.props.readOnly) {\n                _this.setOpen(true);\n            }\n            (_b = (_a = _this.props).onInputClick) === null || _b === void 0 ? void 0 : _b.call(_a);\n        };\n        _this.handleTimeOnlyArrowKey = function (eventKey) {\n            var _a, _b, _c, _d;\n            var currentTime = _this.props.selected || _this.state.preSelection || newDate();\n            var timeIntervals = (_a = _this.props.timeIntervals) !== null && _a !== void 0 ? _a : 30;\n            var dateFormat = (_b = _this.props.dateFormat) !== null && _b !== void 0 ? _b : DatePicker.defaultProps.dateFormat;\n            var formatStr = Array.isArray(dateFormat) ? dateFormat[0] : dateFormat;\n            var baseDate = getStartOfDay(currentTime);\n            var currentMinutes = (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(currentTime) * 60 + (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(currentTime);\n            var maxMinutes = 23 * 60 + 60 - timeIntervals; // Cap at last valid interval of the day\n            var newTime;\n            if (eventKey === KeyType.ArrowUp) {\n                var newMinutes = Math.max(0, currentMinutes - timeIntervals);\n                newTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_49__.addMinutes)(baseDate, newMinutes);\n            }\n            else {\n                var newMinutes = Math.min(maxMinutes, currentMinutes + timeIntervals);\n                newTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_49__.addMinutes)(baseDate, newMinutes);\n            }\n            var formattedTime = formatDate(newTime, formatStr || DatePicker.defaultProps.dateFormat, _this.props.locale);\n            _this.setState({\n                preSelection: newTime,\n                inputValue: formattedTime,\n            });\n            if (_this.props.selectsRange || _this.props.selectsMultiple) {\n                return;\n            }\n            var selected = _this.props.selected\n                ? _this.props.selected\n                : _this.getPreSelection();\n            var changedDate = _this.props.selected\n                ? newTime\n                : setTime(selected, {\n                    hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.getHours)(newTime),\n                    minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getMinutes)(newTime),\n                });\n            (_d = (_c = _this.props).onChange) === null || _d === void 0 ? void 0 : _d.call(_c, changedDate);\n            if (_this.props.showTimeSelectOnly || _this.props.showTimeSelect) {\n                _this.setState({ isRenderAriaLiveMessage: true });\n            }\n            requestAnimationFrame(function () {\n                _this.scrollToTimeOption(newTime);\n            });\n        };\n        _this.handleTimeOnlyEnterKey = function (event) {\n            var _a, _b, _c, _d;\n            var inputElement = event.target;\n            var inputValue = inputElement.value;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var timeFormat = _this.props.timeFormat || \"p\";\n            var defaultTime = _this.state.preSelection || _this.props.selected || newDate();\n            var parsedDate = parseDate(inputValue, dateFormat, _this.props.locale, (_b = _this.props.strictParsing) !== null && _b !== void 0 ? _b : false, defaultTime);\n            var timeToCommit = defaultTime;\n            if (parsedDate && isValid(parsedDate)) {\n                timeToCommit = parsedDate;\n            }\n            else {\n                var highlightedItem = ((_c = _this.calendar) === null || _c === void 0 ? void 0 : _c.containerRef.current) instanceof Element &&\n                    _this.calendar.containerRef.current.querySelector(\".react-datepicker__time-list-item[tabindex='0']\");\n                if (highlightedItem instanceof HTMLElement) {\n                    var itemText = (_d = highlightedItem.textContent) === null || _d === void 0 ? void 0 : _d.trim();\n                    if (itemText) {\n                        var itemTime = parseDate(itemText, timeFormat, _this.props.locale, false, defaultTime);\n                        if (itemTime && isValid(itemTime)) {\n                            timeToCommit = itemTime;\n                        }\n                    }\n                }\n            }\n            _this.handleTimeChange(timeToCommit);\n            _this.setOpen(false);\n            _this.sendFocusBackToInput();\n        };\n        _this.scrollToTimeOption = function (time) {\n            var _a, _b;\n            if (!((_a = _this.calendar) === null || _a === void 0 ? void 0 : _a.containerRef.current)) {\n                return;\n            }\n            var container = _this.calendar.containerRef.current;\n            var timeListItems = Array.from(container.querySelectorAll(\".react-datepicker__time-list-item\"));\n            var targetItem = null;\n            var closestTimeDiff = Infinity;\n            var timeFormat = _this.props.timeFormat || \"p\";\n            for (var _i = 0, timeListItems_1 = timeListItems; _i < timeListItems_1.length; _i++) {\n                var item = timeListItems_1[_i];\n                var itemText = (_b = item.textContent) === null || _b === void 0 ? void 0 : _b.trim();\n                if (itemText) {\n                    var itemTime = parseDate(itemText, timeFormat, _this.props.locale, false, time);\n                    if (itemTime && isValid(itemTime)) {\n                        if (isSameMinute(itemTime, time)) {\n                            targetItem = item;\n                            break;\n                        }\n                        var timeDiff = Math.abs(itemTime.getTime() - time.getTime());\n                        if (timeDiff < closestTimeDiff) {\n                            closestTimeDiff = timeDiff;\n                            targetItem = item;\n                        }\n                    }\n                }\n            }\n            if (targetItem) {\n                timeListItems.forEach(function (item) {\n                    item.setAttribute(\"tabindex\", \"-1\");\n                });\n                targetItem.setAttribute(\"tabindex\", \"0\");\n                targetItem.scrollIntoView({\n                    behavior: \"smooth\",\n                    block: \"center\",\n                });\n            }\n        };\n        _this.onInputKeyDown = function (event) {\n            var _a, _b, _c, _d, _e, _f;\n            (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            var eventKey = event.key;\n            if (!_this.state.open &&\n                !_this.props.inline &&\n                !_this.props.preventOpenOnFocus) {\n                if (eventKey === KeyType.ArrowDown ||\n                    eventKey === KeyType.ArrowUp ||\n                    eventKey === KeyType.Enter) {\n                    (_c = _this.onInputClick) === null || _c === void 0 ? void 0 : _c.call(_this);\n                }\n                return;\n            }\n            if (_this.state.open && _this.props.showTimeSelectOnly) {\n                if (eventKey === KeyType.ArrowDown || eventKey === KeyType.ArrowUp) {\n                    event.preventDefault();\n                    _this.handleTimeOnlyArrowKey(eventKey);\n                    return;\n                }\n                if (eventKey === KeyType.Enter) {\n                    event.preventDefault();\n                    _this.handleTimeOnlyEnterKey(event);\n                    return;\n                }\n            }\n            // if calendar is open, these keys will focus the selected item\n            if (_this.state.open) {\n                if (eventKey === KeyType.ArrowDown || eventKey === KeyType.ArrowUp) {\n                    event.preventDefault();\n                    var selectorString = _this.props.showTimeSelectOnly\n                        ? \".react-datepicker__time-list-item[tabindex='0']\"\n                        : _this.props.showWeekPicker && _this.props.showWeekNumbers\n                            ? '.react-datepicker__week-number[tabindex=\"0\"]'\n                            : _this.props.showFullMonthYearPicker ||\n                                _this.props.showMonthYearPicker\n                                ? '.react-datepicker__month-text[tabindex=\"0\"]'\n                                : '.react-datepicker__day[tabindex=\"0\"]';\n                    var selectedItem = ((_d = _this.calendar) === null || _d === void 0 ? void 0 : _d.containerRef.current) instanceof Element &&\n                        _this.calendar.containerRef.current.querySelector(selectorString);\n                    selectedItem instanceof HTMLElement &&\n                        selectedItem.focus({ preventScroll: true });\n                    return;\n                }\n                var copy = newDate(_this.state.preSelection);\n                if (eventKey === KeyType.Enter) {\n                    event.preventDefault();\n                    event.target.blur();\n                    if (_this.inputOk() &&\n                        _this.state.lastPreSelectChange === PRESELECT_CHANGE_VIA_NAVIGATE) {\n                        _this.handleSelect(copy, event);\n                        !_this.props.shouldCloseOnSelect && _this.setPreSelection(copy);\n                    }\n                    else {\n                        _this.setOpen(false);\n                    }\n                }\n                else if (eventKey === KeyType.Escape) {\n                    event.preventDefault();\n                    event.target.blur();\n                    _this.sendFocusBackToInput();\n                    _this.setOpen(false);\n                }\n                else if (eventKey === KeyType.Tab) {\n                    _this.setOpen(false);\n                }\n                if (!_this.inputOk()) {\n                    (_f = (_e = _this.props).onInputError) === null || _f === void 0 ? void 0 : _f.call(_e, { code: 1, msg: INPUT_ERR_1 });\n                }\n            }\n        };\n        _this.onPortalKeyDown = function (event) {\n            var eventKey = event.key;\n            if (eventKey === KeyType.Escape) {\n                event.preventDefault();\n                _this.setState({\n                    preventFocus: true,\n                }, function () {\n                    _this.setOpen(false);\n                    setTimeout(function () {\n                        _this.setFocus();\n                        _this.setState({ preventFocus: false });\n                    });\n                });\n            }\n        };\n        // keyDown events passed down to day.jsx\n        _this.onDayKeyDown = function (event) {\n            var _a, _b, _c, _d, _e, _f;\n            var _g = _this.props, minDate = _g.minDate, maxDate = _g.maxDate, disabledKeyboardNavigation = _g.disabledKeyboardNavigation, showWeekPicker = _g.showWeekPicker, shouldCloseOnSelect = _g.shouldCloseOnSelect, locale = _g.locale, calendarStartDay = _g.calendarStartDay, adjustDateOnChange = _g.adjustDateOnChange, inline = _g.inline;\n            (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            if (disabledKeyboardNavigation)\n                return;\n            var eventKey = event.key;\n            var isShiftKeyActive = event.shiftKey;\n            var copy = newDate(_this.state.preSelection);\n            var calculateNewDate = function (eventKey, date) {\n                var newCalculatedDate = date;\n                switch (eventKey) {\n                    case KeyType.ArrowRight:\n                        newCalculatedDate = showWeekPicker\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_56__.addWeeks)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(date, 1);\n                        break;\n                    case KeyType.ArrowLeft:\n                        newCalculatedDate = showWeekPicker\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_63__.subWeeks)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_64__.subDays)(date, 1);\n                        break;\n                    case KeyType.ArrowUp:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_63__.subWeeks)(date, 1);\n                        break;\n                    case KeyType.ArrowDown:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_56__.addWeeks)(date, 1);\n                        break;\n                    case KeyType.PageUp:\n                        newCalculatedDate = isShiftKeyActive\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_42__.subYears)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.subMonths)(date, 1);\n                        break;\n                    case KeyType.PageDown:\n                        newCalculatedDate = isShiftKeyActive\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.addYears)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.addMonths)(date, 1);\n                        break;\n                    case KeyType.Home:\n                        newCalculatedDate = getStartOfWeek(date, locale, calendarStartDay);\n                        break;\n                    case KeyType.End:\n                        newCalculatedDate = getEndOfWeek(date);\n                        break;\n                }\n                return newCalculatedDate;\n            };\n            var getNewDate = function (eventKey, date) {\n                var MAX_ITERATIONS = 40;\n                var eventKeyCopy = eventKey;\n                var validDateFound = false;\n                var iterations = 0;\n                var newSelection = calculateNewDate(eventKey, date);\n                while (!validDateFound) {\n                    if (iterations >= MAX_ITERATIONS) {\n                        newSelection = date;\n                        break;\n                    }\n                    // if minDate exists and the new selection is before the min date, get the nearest date that isn't disabled\n                    if (minDate && newSelection < minDate) {\n                        eventKeyCopy = KeyType.ArrowRight;\n                        newSelection = isDayDisabled(minDate, _this.props)\n                            ? calculateNewDate(eventKeyCopy, newSelection)\n                            : minDate;\n                    }\n                    // if maxDate exists and the new selection is after the max date, get the nearest date that isn't disabled\n                    if (maxDate && newSelection > maxDate) {\n                        eventKeyCopy = KeyType.ArrowLeft;\n                        newSelection = isDayDisabled(maxDate, _this.props)\n                            ? calculateNewDate(eventKeyCopy, newSelection)\n                            : maxDate;\n                    }\n                    if (isDayDisabled(newSelection, _this.props)) {\n                        // if PageUp and Home is pressed to a disabled date, it will try to find the next available date after\n                        if (eventKeyCopy === KeyType.PageUp ||\n                            eventKeyCopy === KeyType.Home) {\n                            eventKeyCopy = KeyType.ArrowRight;\n                        }\n                        // if PageDown and End is pressed to a disabled date, it will try to find the next available date before\n                        if (eventKeyCopy === KeyType.PageDown ||\n                            eventKeyCopy === KeyType.End) {\n                            eventKeyCopy = KeyType.ArrowLeft;\n                        }\n                        newSelection = calculateNewDate(eventKeyCopy, newSelection);\n                    }\n                    else {\n                        validDateFound = true;\n                    }\n                    iterations++;\n                }\n                return newSelection;\n            };\n            if (eventKey === KeyType.Enter) {\n                event.preventDefault();\n                _this.handleSelect(copy, event);\n                !shouldCloseOnSelect && _this.setPreSelection(copy);\n                return;\n            }\n            else if (eventKey === KeyType.Escape) {\n                event.preventDefault();\n                _this.setOpen(false);\n                if (!_this.inputOk()) {\n                    (_d = (_c = _this.props).onInputError) === null || _d === void 0 ? void 0 : _d.call(_c, { code: 1, msg: INPUT_ERR_1 });\n                }\n                return;\n            }\n            var newSelection = null;\n            switch (eventKey) {\n                case KeyType.ArrowLeft:\n                case KeyType.ArrowRight:\n                case KeyType.ArrowUp:\n                case KeyType.ArrowDown:\n                case KeyType.PageUp:\n                case KeyType.PageDown:\n                case KeyType.Home:\n                case KeyType.End:\n                    newSelection = getNewDate(eventKey, copy);\n                    break;\n            }\n            if (!newSelection) {\n                (_f = (_e = _this.props).onInputError) === null || _f === void 0 ? void 0 : _f.call(_e, { code: 1, msg: INPUT_ERR_1 });\n                return;\n            }\n            event.preventDefault();\n            _this.setState({ lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE });\n            if (adjustDateOnChange) {\n                _this.setSelected(newSelection);\n            }\n            _this.setPreSelection(newSelection);\n            // In inline mode, always set shouldFocusDayInline to true when navigating via keyboard.\n            // This ensures focus is properly transferred to the new day element regardless of\n            // whether the month changed. The user initiated this navigation from a focused day,\n            // so we should always focus the destination day.\n            if (inline) {\n                _this.setState({ shouldFocusDayInline: true });\n            }\n        };\n        // handle generic key down events in the popper that do not adjust or select dates\n        // ex: while focusing prev and next month buttons\n        _this.onPopperKeyDown = function (event) {\n            var eventKey = event.key;\n            if (eventKey === KeyType.Escape) {\n                event.preventDefault();\n                _this.sendFocusBackToInput();\n                _this.setOpen(false);\n            }\n        };\n        _this.onClearClick = function (event) {\n            if (event) {\n                if (event.preventDefault) {\n                    event.preventDefault();\n                }\n            }\n            _this.sendFocusBackToInput();\n            var _a = _this.props, selectsRange = _a.selectsRange, onChange = _a.onChange;\n            if (selectsRange) {\n                onChange === null || onChange === void 0 ? void 0 : onChange([null, null], event);\n            }\n            else {\n                onChange === null || onChange === void 0 ? void 0 : onChange(null, event);\n            }\n            _this.setState({ inputValue: null });\n        };\n        _this.clear = function () {\n            _this.onClearClick();\n        };\n        _this.onScroll = function (event) {\n            if (typeof _this.props.closeOnScroll === \"boolean\" &&\n                _this.props.closeOnScroll) {\n                if (event.target === document ||\n                    event.target === document.documentElement ||\n                    event.target === document.body) {\n                    _this.setOpen(false);\n                }\n            }\n            else if (typeof _this.props.closeOnScroll === \"function\") {\n                if (_this.props.closeOnScroll(event)) {\n                    _this.setOpen(false);\n                }\n            }\n        };\n        _this.handleMonthSelectedInChange = function (monthSelectedIn) {\n            _this.setState({ monthSelectedIn: monthSelectedIn });\n        };\n        _this.renderCalendar = function () {\n            var _a, _b;\n            if (!_this.props.inline && !_this.isCalendarOpen()) {\n                return null;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Calendar, _assign({ showMonthYearDropdown: undefined, ref: function (elem) {\n                    _this.calendar = elem;\n                } }, _this.props, _this.state, { setOpen: _this.setOpen, dateFormat: (_a = _this.props.dateFormatCalendar) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormatCalendar, onSelect: _this.handleSelect, onClickOutside: _this.handleCalendarClickOutside, holidays: getHolidaysMap(_this.modifyHolidays()), outsideClickIgnoreClass: _this.props.outsideClickIgnoreClass, onDropdownFocus: _this.handleDropdownFocus, onTimeChange: _this.handleTimeChange, className: _this.props.calendarClassName, container: _this.props.calendarContainer, handleOnKeyDown: _this.props.onKeyDown, handleOnDayKeyDown: _this.onDayKeyDown, setPreSelection: _this.setPreSelection, dropdownMode: (_b = _this.props.dropdownMode) !== null && _b !== void 0 ? _b : DatePicker.defaultProps.dropdownMode, onMonthSelectedInChange: _this.handleMonthSelectedInChange }), _this.props.children));\n        };\n        _this.renderAriaLiveRegion = function () {\n            var _a;\n            var locale = _this.props.locale;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var isContainsTime = _this.props.showTimeInput || _this.props.showTimeSelect;\n            var longDateFormat = isContainsTime ? \"PPPPp\" : \"PPPP\";\n            var ariaLiveMessage;\n            if (_this.props.selectsRange) {\n                ariaLiveMessage = \"Selected start date: \".concat(safeDateFormat(_this.props.startDate, {\n                    dateFormat: longDateFormat,\n                    locale: locale,\n                }), \". \").concat(_this.props.endDate\n                    ? \"End date: \" +\n                        safeDateFormat(_this.props.endDate, {\n                            dateFormat: longDateFormat,\n                            locale: locale,\n                        })\n                    : \"\");\n            }\n            else {\n                if (_this.props.showTimeSelectOnly) {\n                    ariaLiveMessage = \"Selected time: \".concat(safeDateFormat(_this.props.selected, { dateFormat: dateFormat, locale: locale }));\n                }\n                else if (_this.props.showYearPicker) {\n                    ariaLiveMessage = \"Selected year: \".concat(safeDateFormat(_this.props.selected, { dateFormat: \"yyyy\", locale: locale }));\n                }\n                else if (_this.props.showMonthYearPicker) {\n                    ariaLiveMessage = \"Selected month: \".concat(safeDateFormat(_this.props.selected, { dateFormat: \"MMMM yyyy\", locale: locale }));\n                }\n                else if (_this.props.showQuarterYearPicker) {\n                    ariaLiveMessage = \"Selected quarter: \".concat(safeDateFormat(_this.props.selected, {\n                        dateFormat: \"yyyy, QQQ\",\n                        locale: locale,\n                    }));\n                }\n                else {\n                    ariaLiveMessage = \"Selected date: \".concat(safeDateFormat(_this.props.selected, {\n                        dateFormat: longDateFormat,\n                        locale: locale,\n                    }));\n                }\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { role: \"alert\", \"aria-live\": \"polite\", className: \"react-datepicker__aria-live\" }, ariaLiveMessage));\n        };\n        _this.renderDateInput = function () {\n            var _a, _b;\n            var _c, _d, _e, _f, _g;\n            var className = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(_this.props.className, (_a = {},\n                _a[_this.props.outsideClickIgnoreClass ||\n                    DatePicker.defaultProps.outsideClickIgnoreClass] = _this.state.open,\n                _a));\n            var customInput = _this.props.customInput || react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"input\", { type: \"text\" });\n            var customInputRef = _this.props.customInputRef || \"ref\";\n            // Build aria props object, only including defined values to avoid\n            // overwriting aria attributes that may be set on the custom input\n            var ariaProps = {};\n            var ariaDescribedBy = (_c = _this.props[\"aria-describedby\"]) !== null && _c !== void 0 ? _c : _this.props.ariaDescribedBy;\n            var ariaInvalid = (_d = _this.props[\"aria-invalid\"]) !== null && _d !== void 0 ? _d : _this.props.ariaInvalid;\n            var ariaLabel = (_e = _this.props[\"aria-label\"]) !== null && _e !== void 0 ? _e : _this.props.ariaLabel;\n            var ariaLabelledBy = (_f = _this.props[\"aria-labelledby\"]) !== null && _f !== void 0 ? _f : _this.props.ariaLabelledBy;\n            var ariaRequired = (_g = _this.props[\"aria-required\"]) !== null && _g !== void 0 ? _g : _this.props.ariaRequired;\n            if (ariaDescribedBy != null)\n                ariaProps[\"aria-describedby\"] = ariaDescribedBy;\n            if (ariaInvalid != null)\n                ariaProps[\"aria-invalid\"] = ariaInvalid;\n            if (ariaLabel != null)\n                ariaProps[\"aria-label\"] = ariaLabel;\n            if (ariaLabelledBy != null)\n                ariaProps[\"aria-labelledby\"] = ariaLabelledBy;\n            if (ariaRequired != null)\n                ariaProps[\"aria-required\"] = ariaRequired;\n            return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(customInput, _assign((_b = {}, _b[customInputRef] = function (input) {\n                _this.input = input;\n            }, _b.value = _this.getInputValue(), _b.onBlur = _this.handleBlur, _b.onChange = _this.handleChange, _b.onClick = _this.onInputClick, _b.onFocus = _this.handleFocus, _b.onKeyDown = _this.onInputKeyDown, _b.id = _this.props.id, _b.name = _this.props.name, _b.form = _this.props.form, _b.autoFocus = _this.props.autoFocus, _b.placeholder = _this.props.placeholderText, _b.disabled = _this.props.disabled, _b.autoComplete = _this.props.autoComplete, _b.className = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(customInput.props.className, className), _b.title = _this.props.title, _b.readOnly = _this.props.readOnly, _b.required = _this.props.required, _b.tabIndex = _this.props.tabIndex, _b), ariaProps));\n        };\n        _this.renderClearButton = function () {\n            var _a = _this.props, isClearable = _a.isClearable, disabled = _a.disabled, selected = _a.selected, startDate = _a.startDate, endDate = _a.endDate, clearButtonTitle = _a.clearButtonTitle, _b = _a.clearButtonClassName, clearButtonClassName = _b === void 0 ? \"\" : _b, _c = _a.ariaLabelClose, ariaLabelClose = _c === void 0 ? \"Close\" : _c, selectedDates = _a.selectedDates, readOnly = _a.readOnly;\n            if (isClearable &&\n                !readOnly &&\n                (selected != null ||\n                    startDate != null ||\n                    endDate != null ||\n                    (selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.length))) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { type: \"button\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__close-icon\", clearButtonClassName, { \"react-datepicker__close-icon--disabled\": disabled }), disabled: disabled, \"aria-label\": ariaLabelClose, onClick: _this.onClearClick, title: clearButtonTitle, tabIndex: -1 }));\n            }\n            else {\n                return null;\n            }\n        };\n        _this.state = _this.calcInitialState();\n        _this.preventFocusTimeout = undefined;\n        return _this;\n    }\n    Object.defineProperty(DatePicker, \"defaultProps\", {\n        get: function () {\n            return {\n                allowSameDay: false,\n                dateFormat: \"MM/dd/yyyy\",\n                dateFormatCalendar: \"LLLL yyyy\",\n                disabled: false,\n                disabledKeyboardNavigation: false,\n                dropdownMode: \"scroll\",\n                preventOpenOnFocus: false,\n                monthsShown: 1,\n                outsideClickIgnoreClass: OUTSIDE_CLICK_IGNORE_CLASS,\n                readOnly: false,\n                rangeSeparator: DATE_RANGE_SEPARATOR,\n                withPortal: false,\n                selectsDisabledDaysInRange: false,\n                shouldCloseOnSelect: true,\n                showTimeSelect: false,\n                showTimeInput: false,\n                showPreviousMonths: false,\n                showMonthYearPicker: false,\n                showFullMonthYearPicker: false,\n                showTwoColumnMonthYearPicker: false,\n                showFourColumnMonthYearPicker: false,\n                showYearPicker: false,\n                showQuarterYearPicker: false,\n                showWeekPicker: false,\n                strictParsing: false,\n                swapRange: false,\n                timeIntervals: 30,\n                timeCaption: \"Time\",\n                previousMonthAriaLabel: \"Previous Month\",\n                previousMonthButtonLabel: \"Previous Month\",\n                nextMonthAriaLabel: \"Next Month\",\n                nextMonthButtonLabel: \"Next Month\",\n                previousYearAriaLabel: \"Previous Year\",\n                previousYearButtonLabel: \"Previous Year\",\n                nextYearAriaLabel: \"Next Year\",\n                nextYearButtonLabel: \"Next Year\",\n                timeInputLabel: \"Time\",\n                enableTabLoop: true,\n                yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER,\n                focusSelectedMonth: false,\n                showPopperArrow: true,\n                excludeScrollbar: true,\n                customTimeInput: null,\n                calendarStartDay: undefined,\n                toggleCalendarOnIconClick: false,\n                usePointerEvent: false,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DatePicker.prototype.componentDidMount = function () {\n        window.addEventListener(\"scroll\", this.onScroll, true);\n        document.addEventListener(\"visibilitychange\", this.setHiddenStateOnVisibilityHidden);\n    };\n    DatePicker.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a, _b, _c, _d;\n        // Update preSelection when selected/startDate prop changes to a different month/year.\n        // This ensures the calendar view updates when dates are programmatically set\n        // (e.g., via \"Today\" or \"This Week\" buttons). (Fix for #3367)\n        if (this.props.selectsRange &&\n            hasPreSelectionChanged(prevProps.startDate, this.props.startDate)) {\n            this.setPreSelection(this.props.startDate);\n        }\n        else if (hasPreSelectionChanged(prevProps.selected, this.props.selected)) {\n            this.setPreSelection(this.props.selected);\n        }\n        if (this.state.monthSelectedIn !== undefined &&\n            prevProps.monthsShown !== this.props.monthsShown) {\n            this.setState({ monthSelectedIn: 0 });\n        }\n        // Reset monthSelectedIn when calendar opens for range selection\n        // This ensures startDate is displayed as the first month when reopening\n        // (Fix for #5939), but we don't reset during active selection to avoid\n        // the view jumping when clicking dates in the second calendar (Fix for #5275)\n        if (this.props.selectsRange &&\n            prevState.open === false &&\n            this.state.open === true &&\n            this.state.monthSelectedIn !== 0) {\n            this.setState({ monthSelectedIn: 0 });\n        }\n        if (prevProps.highlightDates !== this.props.highlightDates) {\n            this.setState({\n                highlightDates: getHighLightDaysMap(this.props.highlightDates),\n            });\n        }\n        if (!prevState.focused &&\n            !isEqual(prevProps.selected, this.props.selected)) {\n            this.setState({ inputValue: null });\n        }\n        if (prevState.open !== this.state.open) {\n            if (prevState.open === false && this.state.open === true) {\n                (_b = (_a = this.props).onCalendarOpen) === null || _b === void 0 ? void 0 : _b.call(_a);\n            }\n            if (prevState.open === true && this.state.open === false) {\n                (_d = (_c = this.props).onCalendarClose) === null || _d === void 0 ? void 0 : _d.call(_c);\n            }\n        }\n    };\n    DatePicker.prototype.componentWillUnmount = function () {\n        this.clearPreventFocusTimeout();\n        window.removeEventListener(\"scroll\", this.onScroll, true);\n        document.removeEventListener(\"visibilitychange\", this.setHiddenStateOnVisibilityHidden);\n    };\n    DatePicker.prototype.renderInputContainer = function () {\n        var _a = this.props, showIcon = _a.showIcon, icon = _a.icon, calendarIconClassname = _a.calendarIconClassname, calendarIconClassName = _a.calendarIconClassName, toggleCalendarOnIconClick = _a.toggleCalendarOnIconClick;\n        var open = this.state.open;\n        if (calendarIconClassname) {\n            console.warn(\"calendarIconClassname props is deprecated. should use calendarIconClassName props.\");\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__input-container\".concat(showIcon ? \" react-datepicker__view-calendar-icon\" : \"\") },\n            showIcon && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(CalendarIcon, _assign({ icon: icon, className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(calendarIconClassName, !calendarIconClassName && calendarIconClassname, open && \"react-datepicker-ignore-onclickoutside\") }, (toggleCalendarOnIconClick\n                ? {\n                    onClick: this.toggleCalendar,\n                }\n                : null)))),\n            this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(),\n            this.renderDateInput(),\n            this.renderClearButton()));\n    };\n    DatePicker.prototype.render = function () {\n        var calendar = this.renderCalendar();\n        if (this.props.inline)\n            return calendar;\n        if (this.props.withPortal) {\n            var portalContainer = this.state.open ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(TabLoop, { enableTabLoop: this.props.enableTabLoop },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__portal\", tabIndex: -1, onKeyDown: this.onPortalKeyDown }, calendar))) : null;\n            if (this.state.open && this.props.portalId) {\n                portalContainer = (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Portal, _assign({ portalId: this.props.portalId }, this.props), portalContainer));\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", null,\n                this.renderInputContainer(),\n                portalContainer));\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(PopperComponent, _assign({}, this.props, { className: this.props.popperClassName, hidePopper: !this.isCalendarOpen(), targetComponent: this.renderInputContainer(), popperComponent: calendar, popperOnKeyDown: this.onPopperKeyDown, showArrow: this.props.showPopperArrow, monthHeaderPosition: this.props.monthHeaderPosition })));\n    };\n    return DatePicker;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\nvar PRESELECT_CHANGE_VIA_INPUT = \"input\";\nvar PRESELECT_CHANGE_VIA_NAVIGATE = \"navigate\";\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRCO0FBQ3FGO0FBQ3dzQjtBQUN4dEI7QUFDaEU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFtQixVQUFVLCtIQUErSDtBQUN4Szs7QUFFQTtBQUNBLGNBQWMsNkNBQU07QUFDcEIsNEJBQTRCLDZDQUFNO0FBQ2xDLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsa0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQW1CLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsdUVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBUSxVQUFVLGdEQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0EseUJBQXlCLCtDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEVBQUUsS0FBSyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnREFBTTtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQVEsQ0FBQyxvREFBVSxDQUFDLHFEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5REFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscURBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyw0Q0FBUzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQW1CLFVBQVUsbUNBQW1DLDBDQUFJLDhNQUE4TTtBQUNsUztBQUNBO0FBQ0EsQ0FBQyxDQUFDLDRDQUFTOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFtQixVQUFVLGdIQUFnSDtBQUM3Six5QkFBeUIsMERBQW1CLHlCQUF5Qix1QkFBdUIsMENBQUksNEhBQTRIO0FBQzVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBEQUFtQixZQUFZLHlDQUF5QztBQUM3SCxnQkFBZ0IsMERBQW1CLFVBQVUsc0ZBQXNGO0FBQ25JO0FBQ0EsbUNBQW1DLDBEQUFtQixtQkFBbUIsK0JBQStCO0FBQ3hHO0FBQ0Esb0JBQW9CLDBEQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQW1CLDRCQUE0QixnQkFBZ0IsdVJBQXVSO0FBQ3RXO0FBQ0E7QUFDQSxDQUFDLENBQUMsNENBQVM7QUFDWDtBQUNBOztBQUVvSDtBQUNwSCIsInNvdXJjZXMiOlsid2VicGFjazovL2FubmFwdXJuYS1ob3NwaXRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRlcGlja2VyL2Rpc3QvaW5kZXguZXMuanM/ZDRiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgcmVhY3QtZGF0ZXBpY2tlciB2OS4wLjBcbiAgaHR0cHM6Ly9naXRodWIuY29tL0hhY2tlcjB4MDEvcmVhY3QtZGF0ZXBpY2tlclxuICBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgY2xzeCB9IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgY2xvbmVFbGVtZW50LCBDb21wb25lbnQsIGNyZWF0ZVJlZiwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzU2FtZURheSBhcyBpc1NhbWVEYXkkMSwgaXNXaXRoaW5JbnRlcnZhbCwgc3RhcnRPZldlZWssIGZvcm1hdCwgc3RhcnRPZkRheSwgZW5kT2ZEYXksIGlzRXF1YWwgYXMgaXNFcXVhbCQxLCBwYXJzZUlTTywgdG9EYXRlLCBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMsIGlzVmFsaWQgYXMgaXNWYWxpZCQxLCBnZXRJU09XZWVrLCBpc1NhbWVNb250aCBhcyBpc1NhbWVNb250aCQxLCBpc1NhbWVRdWFydGVyIGFzIGlzU2FtZVF1YXJ0ZXIkMSwgZ2V0WWVhciwgZ2V0TW9udGgsIGdldFF1YXJ0ZXIsIHN0YXJ0T2ZNb250aCwgc3RhcnRPZlF1YXJ0ZXIsIGVuZE9mTW9udGgsIHNldE1vbnRoLCBzZXRRdWFydGVyLCBpc1NhbWVZZWFyIGFzIGlzU2FtZVllYXIkMSwgc2V0SG91cnMsIGdldEhvdXJzLCBzZXRNaW51dGVzLCBnZXRNaW51dGVzLCBzZXRTZWNvbmRzLCBnZXRTZWNvbmRzLCBhZGRIb3VycywgYWRkTWludXRlcywgYWRkU2Vjb25kcywgaXNBZnRlciwgaXNCZWZvcmUsIHN0YXJ0T2ZZZWFyLCBlbmRPZlllYXIsIG1pbiwgbWF4LCBzdWJNb250aHMsIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzLCBzdWJRdWFydGVycywgZGlmZmVyZW5jZUluQ2FsZW5kYXJRdWFydGVycywgc3ViWWVhcnMsIGRpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMsIGFkZE1vbnRocywgYWRkUXVhcnRlcnMsIGFkZFllYXJzLCBwYXJzZSwgaXNEYXRlLCBlbmRPZldlZWssIGdldERheSwgZ2V0RGF0ZSwgYWRkRGF5cywgYWRkV2Vla3MsIGdldFRpbWUsIHNldFllYXIsIGRpZmZlcmVuY2VJbkRheXMsIHN1YldlZWtzLCBzdWJEYXlzIH0gZnJvbSAnZGF0ZS1mbnMnO1xuaW1wb3J0IHsgdXNlRmxvYXRpbmcsIGF1dG9VcGRhdGUsIGZsaXAsIG9mZnNldCwgYXJyb3csIEZsb2F0aW5nQXJyb3cgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgX2V4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfYXNzaWduID0gZnVuY3Rpb24gX19hc3NpZ24oKSB7XG4gIF9hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG52YXIgQ2FsZW5kYXJDb250YWluZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5zaG93VGltZVNlbGVjdE9ubHksIHNob3dUaW1lU2VsZWN0T25seSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IF9hLnNob3dUaW1lLCBzaG93VGltZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGlubGluZSA9IF9hLmlubGluZTtcbiAgICB2YXIgYXJpYUxhYmVsID0gc2hvd1RpbWVTZWxlY3RPbmx5XG4gICAgICAgID8gXCJDaG9vc2UgVGltZVwiXG4gICAgICAgIDogXCJDaG9vc2UgRGF0ZVwiLmNvbmNhdChzaG93VGltZSA/IFwiIGFuZCBUaW1lXCIgOiBcIlwiKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCwgcm9sZTogaW5saW5lID8gdW5kZWZpbmVkIDogXCJkaWFsb2dcIiwgXCJhcmlhLW1vZGFsXCI6IGlubGluZSA/IHVuZGVmaW5lZCA6IFwidHJ1ZVwiIH0sIGNoaWxkcmVuKSk7XG59O1xuXG52YXIgdXNlRGV0ZWN0Q2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gKG9uQ2xpY2tPdXRzaWRlLCBpZ25vcmVDbGFzcykge1xuICAgIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIG9uQ2xpY2tPdXRzaWRlUmVmID0gdXNlUmVmKG9uQ2xpY2tPdXRzaWRlKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkNsaWNrT3V0c2lkZVJlZi5jdXJyZW50ID0gb25DbGlja091dHNpZGU7XG4gICAgfSwgW29uQ2xpY2tPdXRzaWRlXSk7XG4gICAgdmFyIGhhbmRsZUNsaWNrT3V0c2lkZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB0YXJnZXQgPSAoZXZlbnQuY29tcG9zZWQgJiZcbiAgICAgICAgICAgIGV2ZW50LmNvbXBvc2VkUGF0aCAmJlxuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAuY29tcG9zZWRQYXRoKClcbiAgICAgICAgICAgICAgICAuZmluZChmdW5jdGlvbiAoZXZlbnRUYXJnZXQpIHsgcmV0dXJuIGV2ZW50VGFyZ2V0IGluc3RhbmNlb2YgTm9kZTsgfSkpIHx8XG4gICAgICAgICAgICBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCAmJiAhcmVmLmN1cnJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKCEoaWdub3JlQ2xhc3MgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoaWdub3JlQ2xhc3MpKSkge1xuICAgICAgICAgICAgICAgIChfYSA9IG9uQ2xpY2tPdXRzaWRlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9uQ2xpY2tPdXRzaWRlUmVmLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbaWdub3JlQ2xhc3NdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgICAgIH07XG4gICAgfSwgW2hhbmRsZUNsaWNrT3V0c2lkZV0pO1xuICAgIHJldHVybiByZWY7XG59O1xudmFyIENsaWNrT3V0c2lkZVdyYXBwZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgb25DbGlja091dHNpZGUgPSBfYS5vbkNsaWNrT3V0c2lkZSwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBjb250YWluZXJSZWYgPSBfYS5jb250YWluZXJSZWYsIHN0eWxlID0gX2Euc3R5bGUsIGlnbm9yZUNsYXNzID0gX2EuaWdub3JlQ2xhc3M7XG4gICAgdmFyIGRldGVjdFJlZiA9IHVzZURldGVjdENsaWNrT3V0c2lkZShvbkNsaWNrT3V0c2lkZSwgaWdub3JlQ2xhc3MpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGUsIHJlZjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGRldGVjdFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJSZWYpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gfSwgY2hpbGRyZW4pKTtcbn07XG5cbi8vIENhY2hlIGZvciB0aGUgZGF0ZS1mbnMtdHogbW9kdWxlXG52YXIgZGF0ZUZuc1R6ID0gbnVsbDtcbnZhciBkYXRlRm5zVHpMb2FkQXR0ZW1wdGVkID0gZmFsc2U7XG4vKipcbiAqIEF0dGVtcHRzIHRvIGxvYWQgZGF0ZS1mbnMtdHogbW9kdWxlLlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBtb2R1bGUgaXMgbm90IGluc3RhbGxlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0ZUZuc1R6KCkge1xuICAgIGlmIChkYXRlRm5zVHpMb2FkQXR0ZW1wdGVkKSB7XG4gICAgICAgIHJldHVybiBkYXRlRm5zVHo7XG4gICAgfVxuICAgIGRhdGVGbnNUekxvYWRBdHRlbXB0ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIER5bmFtaWMgcmVxdWlyZSBmb3IgZGF0ZS1mbnMtdHpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgZGF0ZUZuc1R6ID0gcmVxdWlyZShcImRhdGUtZm5zLXR6XCIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBvbmx5IGV4ZWN1dGVzIHdoZW4gZGF0ZS1mbnMtdHogaXMgbm90IGluc3RhbGxlZCAqL1xuICAgICAgICBkYXRlRm5zVHogPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUZuc1R6O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gdGhlIHNwZWNpZmllZCB0aW1lem9uZS5cbiAqIElmIG5vIHRpbWV6b25lIGlzIHNwZWNpZmllZCBvciBkYXRlLWZucy10eiBpcyBub3QgaW5zdGFsbGVkLCByZXR1cm5zIHRoZSBvcmlnaW5hbCBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY29udmVydFxuICogQHBhcmFtIHRpbWVab25lIC0gVGhlIElBTkEgdGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiwgXCJBbWVyaWNhL05ld19Zb3JrXCIsIFwiVVRDXCIpXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIHRpbWV6b25lXG4gKi9cbmZ1bmN0aW9uIHRvWm9uZWRUaW1lKGRhdGUsIHRpbWVab25lKSB7XG4gICAgaWYgKCF0aW1lWm9uZSkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgdmFyIHR6ID0gZ2V0RGF0ZUZuc1R6KCk7XG4gICAgaWYgKCF0eikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3JlYWN0LWRhdGVwaWNrZXI6IHRpbWVab25lIHByb3AgcmVxdWlyZXMgXCJkYXRlLWZucy10elwiIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIGluc3RhbGwgaXQ6IG5wbSBpbnN0YWxsIGRhdGUtZm5zLXR6XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gdHoudG9ab25lZFRpbWUoZGF0ZSwgdGltZVpvbmUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgZnJvbSB0aGUgc3BlY2lmaWVkIHRpbWV6b25lIHRvIFVUQy5cbiAqIElmIG5vIHRpbWV6b25lIGlzIHNwZWNpZmllZCBvciBkYXRlLWZucy10eiBpcyBub3QgaW5zdGFsbGVkLCByZXR1cm5zIHRoZSBvcmlnaW5hbCBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgaW4gdGhlIHNwZWNpZmllZCB0aW1lem9uZVxuICogQHBhcmFtIHRpbWVab25lIC0gVGhlIElBTkEgdGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiwgXCJBbWVyaWNhL05ld19Zb3JrXCIsIFwiVVRDXCIpXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpbiBVVENcbiAqL1xuZnVuY3Rpb24gZnJvbVpvbmVkVGltZShkYXRlLCB0aW1lWm9uZSkge1xuICAgIGlmICghdGltZVpvbmUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHZhciB0eiA9IGdldERhdGVGbnNUeigpO1xuICAgIGlmICghdHopIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdyZWFjdC1kYXRlcGlja2VyOiB0aW1lWm9uZSBwcm9wIHJlcXVpcmVzIFwiZGF0ZS1mbnMtdHpcIiBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSBpbnN0YWxsIGl0OiBucG0gaW5zdGFsbCBkYXRlLWZucy10elwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR6LmZyb21ab25lZFRpbWUoZGF0ZSwgdGltZVpvbmUpO1xufVxudmFyIEtleVR5cGU7XG4oZnVuY3Rpb24gKEtleVR5cGUpIHtcbiAgICBLZXlUeXBlW1wiQXJyb3dVcFwiXSA9IFwiQXJyb3dVcFwiO1xuICAgIEtleVR5cGVbXCJBcnJvd0Rvd25cIl0gPSBcIkFycm93RG93blwiO1xuICAgIEtleVR5cGVbXCJBcnJvd0xlZnRcIl0gPSBcIkFycm93TGVmdFwiO1xuICAgIEtleVR5cGVbXCJBcnJvd1JpZ2h0XCJdID0gXCJBcnJvd1JpZ2h0XCI7XG4gICAgS2V5VHlwZVtcIlBhZ2VVcFwiXSA9IFwiUGFnZVVwXCI7XG4gICAgS2V5VHlwZVtcIlBhZ2VEb3duXCJdID0gXCJQYWdlRG93blwiO1xuICAgIEtleVR5cGVbXCJIb21lXCJdID0gXCJIb21lXCI7XG4gICAgS2V5VHlwZVtcIkVuZFwiXSA9IFwiRW5kXCI7XG4gICAgS2V5VHlwZVtcIkVudGVyXCJdID0gXCJFbnRlclwiO1xuICAgIEtleVR5cGVbXCJTcGFjZVwiXSA9IFwiIFwiO1xuICAgIEtleVR5cGVbXCJUYWJcIl0gPSBcIlRhYlwiO1xuICAgIEtleVR5cGVbXCJFc2NhcGVcIl0gPSBcIkVzY2FwZVwiO1xuICAgIEtleVR5cGVbXCJCYWNrc3BhY2VcIl0gPSBcIkJhY2tzcGFjZVwiO1xuICAgIEtleVR5cGVbXCJYXCJdID0gXCJ4XCI7XG59KShLZXlUeXBlIHx8IChLZXlUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldExvY2FsZVNjb3BlKCkge1xuICAgIC8vIFVzZSB0aGlzIGNhc3QgdG8gYXZvaWQgbWVzc2luZyB3aXRoIHVzZXJzIGdsb2JhbFRoaXMgKGxpa2Ugd2luZG93KSBhbmQgdGhlIHJlc3Qgb2Yga2V5cyBpbiB0aGUgZ2xvYmFsVGhpcyBvYmplY3Qgd2UgZG9uJ3QgY2FyZSBhYm91dFxuICAgIHZhciBzY29wZSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgID8gd2luZG93XG4gICAgICAgIDogZ2xvYmFsVGhpcyk7XG4gICAgcmV0dXJuIHNjb3BlO1xufVxudmFyIERFRkFVTFRfWUVBUl9JVEVNX05VTUJFUiA9IDEyO1xuLy8gKiogRGF0ZSBDb25zdHJ1Y3RvcnMgKipcbmZ1bmN0aW9uIG5ld0RhdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgdmFyIGQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBwYXJzZUlTTyh2YWx1ZSkgOiB0b0RhdGUodmFsdWUpO1xuICAgIHJldHVybiBpc1ZhbGlkKGQpID8gZCA6IG5ldyBEYXRlKCk7XG59XG4vKipcbiAqIFBhcnNlcyBhIGRhdGUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIERhdGUgaW4gYSBwYXJzYWJsZSBmb3JtLCBlLmcuLCBJU08gMTg2MVxuICogQHBhcmFtIGRhdGVGb3JtYXQgLSBUaGUgZGF0ZSBmb3JtYXQuXG4gKiBAcGFyYW0gbG9jYWxlIC0gVGhlIGxvY2FsZS5cbiAqIEBwYXJhbSBzdHJpY3RQYXJzaW5nIC0gVGhlIHN0cmljdCBwYXJzaW5nIGZsYWcuXG4gKiBAcGFyYW0gcmVmRGF0ZSAtIFRoZSBiYXNlIGRhdGUgdG8gYmUgcGFzc2VkIHRvIGRhdGUtZm5zIHBhcnNlKCkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyAtIFRoZSBwYXJzZWQgZGF0ZSBvciBudWxsLlxuICovXG5mdW5jdGlvbiBwYXJzZURhdGUodmFsdWUsIGRhdGVGb3JtYXQsIGxvY2FsZSwgc3RyaWN0UGFyc2luZywgcmVmRGF0ZSkge1xuICAgIGlmIChyZWZEYXRlID09PSB2b2lkIDApIHsgcmVmRGF0ZSA9IG5ld0RhdGUoKTsgfVxuICAgIHZhciBsb2NhbGVPYmplY3QgPSBnZXRMb2NhbGVPYmplY3QobG9jYWxlKSB8fCBnZXRMb2NhbGVPYmplY3QoZ2V0RGVmYXVsdExvY2FsZSgpKTtcbiAgICB2YXIgZm9ybWF0cyA9IEFycmF5LmlzQXJyYXkoZGF0ZUZvcm1hdCkgPyBkYXRlRm9ybWF0IDogW2RhdGVGb3JtYXRdO1xuICAgIGZvciAodmFyIF9pID0gMCwgZm9ybWF0c18xID0gZm9ybWF0czsgX2kgPCBmb3JtYXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBmb3JtYXRfMSA9IGZvcm1hdHNfMVtfaV07XG4gICAgICAgIHZhciBwYXJzZWREYXRlID0gcGFyc2UodmFsdWUsIGZvcm1hdF8xLCByZWZEYXRlLCB7XG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZU9iamVjdCxcbiAgICAgICAgICAgIHVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VuczogdHJ1ZSxcbiAgICAgICAgICAgIHVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNWYWxpZChwYXJzZWREYXRlKSAmJlxuICAgICAgICAgICAgKCFzdHJpY3RQYXJzaW5nIHx8IHZhbHVlID09PSBmb3JtYXREYXRlKHBhcnNlZERhdGUsIGZvcm1hdF8xLCBsb2NhbGUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZERhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFBhcnNlcyBhIHBhcnRpYWwgZGF0ZSBzdHJpbmcgZm9yIGNhbGVuZGFyIG5hdmlnYXRpb24gcHVycG9zZXMuXG4gKiBVbmxpa2UgcGFyc2VEYXRlLCB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIGV4dHJhY3Qgd2hhdGV2ZXIgZGF0ZVxuICogaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlICh5ZWFyLCBtb250aCkgZnJvbSBhIHBhcnRpYWwgaW5wdXQsXG4gKiByZXR1cm5pbmcgYSBkYXRlIHN1aXRhYmxlIGZvciBuYXZpZ2F0aW5nIHRoZSBjYWxlbmRhciB2aWV3LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHN0cmluZyB0byBwYXJzZS5cbiAqIEBwYXJhbSByZWZEYXRlIC0gVGhlIHJlZmVyZW5jZSBkYXRlIHRvIHVzZSBmb3IgbWlzc2luZyBjb21wb25lbnRzLlxuICogQHJldHVybnMgLSBBIGRhdGUgZm9yIG5hdmlnYXRpb24gb3IgbnVsbCBpZiBubyBkYXRlIGluZm8gY291bGQgYmUgZXh0cmFjdGVkLlxuICovXG5mdW5jdGlvbiBwYXJzZURhdGVGb3JOYXZpZ2F0aW9uKHZhbHVlLCByZWZEYXRlKSB7XG4gICAgaWYgKHJlZkRhdGUgPT09IHZvaWQgMCkgeyByZWZEYXRlID0gbmV3RGF0ZSgpOyB9XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgYSA0LWRpZ2l0IHllYXIgZnJvbSB0aGUgaW5wdXRcbiAgICB2YXIgeWVhck1hdGNoID0gdmFsdWUubWF0Y2goL1xcYigxXFxkezN9fDJcXGR7M30pXFxiLyk7XG4gICAgaWYgKCF5ZWFyTWF0Y2ggfHwgIXllYXJNYXRjaFsxXSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyTWF0Y2hbMV0sIDEwKTtcbiAgICAvLyBUcnkgdG8gZXh0cmFjdCBhIG1vbnRoICgxLTEyKSBmcm9tIHRoZSBpbnB1dFxuICAgIC8vIExvb2sgZm9yIHBhdHRlcm5zIGxpa2UgXCIwMy9cIiwgXCIvMDNcIiwgXCIwMy1cIiwgXCItMDNcIiBvciBzdGFuZGFsb25lIFwiMDNcIiBhdCBzdGFydFxuICAgIHZhciBtb250aE1hdGNoID0gdmFsdWUubWF0Y2goLyg/Ol58Wy9cXC1cXHNdKT8oMD9bMS05XXwxWzAtMl0pKD86Wy9cXC1cXHNdfCQpLyk7XG4gICAgdmFyIG1vbnRoID0gbW9udGhNYXRjaCAmJiBtb250aE1hdGNoWzFdXG4gICAgICAgID8gcGFyc2VJbnQobW9udGhNYXRjaFsxXSwgMTApIC0gMVxuICAgICAgICA6IHJlZkRhdGUuZ2V0TW9udGgoKTtcbiAgICAvLyBSZXR1cm4gYSBkYXRlIHdpdGggdGhlIGV4dHJhY3RlZCB5ZWFyIGFuZCBtb250aCwgdXNpbmcgZGF5IDFcbiAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBkYXRlIGlzIGEgdmFsaWQgRGF0ZSBvYmplY3QuXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkYXRlIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkKGRhdGUpIHtcbiAgICByZXR1cm4gaXNWYWxpZCQxKGRhdGUpO1xufVxuLy8gKiogRGF0ZSBGb3JtYXR0aW5nICoqXG4vKipcbiAqIEZvcm1hdHMgYSBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUuXG4gKiBAcGFyYW0gZm9ybWF0U3RyIC0gVGhlIGZvcm1hdCBzdHJpbmcuXG4gKiBAcGFyYW0gbG9jYWxlIC0gVGhlIGxvY2FsZS5cbiAqIEByZXR1cm5zIC0gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICovXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0ciwgbG9jYWxlKSB7XG4gICAgaWYgKGxvY2FsZSA9PT0gXCJlblwiKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQoZGF0ZSwgZm9ybWF0U3RyLCB7XG4gICAgICAgICAgICB1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM6IHRydWUsXG4gICAgICAgICAgICB1c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGxvY2FsZU9iaiA9IGxvY2FsZSA/IGdldExvY2FsZU9iamVjdChsb2NhbGUpIDogdW5kZWZpbmVkO1xuICAgIGlmIChsb2NhbGUgJiYgIWxvY2FsZU9iaikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJBIGxvY2FsZSBvYmplY3Qgd2FzIG5vdCBmb3VuZCBmb3IgdGhlIHByb3ZpZGVkIHN0cmluZyBbXFxcIlwiLmNvbmNhdChsb2NhbGUsIFwiXFxcIl0uXCIpKTtcbiAgICB9XG4gICAgbG9jYWxlT2JqID0gbG9jYWxlT2JqIHx8IGdldExvY2FsZU9iamVjdChnZXREZWZhdWx0TG9jYWxlKCkpO1xuICAgIHJldHVybiBmb3JtYXQoZGF0ZSwgZm9ybWF0U3RyLCB7XG4gICAgICAgIGxvY2FsZTogbG9jYWxlT2JqLFxuICAgICAgICB1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM6IHRydWUsXG4gICAgICAgIHVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM6IHRydWUsXG4gICAgfSk7XG59XG4vKipcbiAqIFNhZmVseSBmb3JtYXRzIGEgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0ZUZvcm1hdCBhbmQgbG9jYWxlLlxuICogQHJldHVybnMgLSBUaGUgZm9ybWF0dGVkIGRhdGUgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzYWZlRGF0ZUZvcm1hdChkYXRlLCBfYSkge1xuICAgIHZhciBkYXRlRm9ybWF0ID0gX2EuZGF0ZUZvcm1hdCwgbG9jYWxlID0gX2EubG9jYWxlO1xuICAgIHZhciBmb3JtYXRTdHIgPSAoQXJyYXkuaXNBcnJheShkYXRlRm9ybWF0KSAmJiBkYXRlRm9ybWF0Lmxlbmd0aCA+IDBcbiAgICAgICAgPyBkYXRlRm9ybWF0WzBdXG4gICAgICAgIDogZGF0ZUZvcm1hdCk7IC8vIENhc3QgdG8gc3RyaW5nIGJlY2F1c2UgaXQncyBpbXBvc3NpYmxlIHRvIGdldCBgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWRgIGhlcmUgYW5kIHR5cGVzY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICByZXR1cm4gKGRhdGUgJiYgZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXRTdHIsIGxvY2FsZSkpIHx8IFwiXCI7XG59XG4vKipcbiAqIFVzZWQgYXMgYSBkZWxpbWl0ZXIgdG8gc2VwYXJhdGUgdHdvIGRhdGVzIHdoZW4gZm9ybWF0dGluZyBhIGRhdGUgcmFuZ2VcbiAqL1xudmFyIERBVEVfUkFOR0VfU0VQQVJBVE9SID0gXCIgLSBcIjtcbi8qKlxuICogU2FmZWx5IGZvcm1hdHMgYSBkYXRlIHJhbmdlLlxuICpcbiAqIEBwYXJhbSBzdGFydERhdGUgLSBUaGUgc3RhcnQgZGF0ZS5cbiAqIEBwYXJhbSBlbmREYXRlIC0gVGhlIGVuZCBkYXRlLlxuICogQHBhcmFtIHByb3BzIC0gVGhlIHByb3BzLlxuICogQHJldHVybnMgLSBUaGUgZm9ybWF0dGVkIGRhdGUgcmFuZ2Ugb3IgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzYWZlRGF0ZVJhbmdlRm9ybWF0KHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgcHJvcHMpIHtcbiAgICBpZiAoIXN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlZFN0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZSA/IHNhZmVEYXRlRm9ybWF0KHN0YXJ0RGF0ZSwgcHJvcHMpIDogXCJcIjtcbiAgICB2YXIgZm9ybWF0dGVkRW5kRGF0ZSA9IGVuZERhdGUgPyBzYWZlRGF0ZUZvcm1hdChlbmREYXRlLCBwcm9wcykgOiBcIlwiO1xuICAgIHZhciBkYXRlUmFuZ2VTZXBhcmF0b3IgPSBwcm9wcy5yYW5nZVNlcGFyYXRvciB8fCBEQVRFX1JBTkdFX1NFUEFSQVRPUjtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoZm9ybWF0dGVkU3RhcnREYXRlKS5jb25jYXQoZGF0ZVJhbmdlU2VwYXJhdG9yKS5jb25jYXQoZm9ybWF0dGVkRW5kRGF0ZSk7XG59XG4vKipcbiAqIFNhZmVseSBmb3JtYXRzIG11bHRpcGxlIGRhdGVzLlxuICpcbiAqIEBwYXJhbSBkYXRlcyAtIFRoZSBkYXRlcy5cbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBwcm9wcy5cbiAqIEByZXR1cm5zIC0gVGhlIGZvcm1hdHRlZCBkYXRlcyBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHNhZmVNdWx0aXBsZURhdGVzRm9ybWF0KGRhdGVzLCBwcm9wcykge1xuICAgIGlmICghKGRhdGVzID09PSBudWxsIHx8IGRhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRlcy5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVkRmlyc3REYXRlID0gZGF0ZXNbMF0gPyBzYWZlRGF0ZUZvcm1hdChkYXRlc1swXSwgcHJvcHMpIDogXCJcIjtcbiAgICBpZiAoZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRGaXJzdERhdGU7XG4gICAgfVxuICAgIGlmIChkYXRlcy5sZW5ndGggPT09IDIgJiYgZGF0ZXNbMV0pIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFNlY29uZERhdGUgPSBzYWZlRGF0ZUZvcm1hdChkYXRlc1sxXSwgcHJvcHMpO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZm9ybWF0dGVkRmlyc3REYXRlLCBcIiwgXCIpLmNvbmNhdChmb3JtYXR0ZWRTZWNvbmREYXRlKTtcbiAgICB9XG4gICAgdmFyIGV4dHJhRGF0ZXNDb3VudCA9IGRhdGVzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGZvcm1hdHRlZEZpcnN0RGF0ZSwgXCIgKCtcIikuY29uY2F0KGV4dHJhRGF0ZXNDb3VudCwgXCIpXCIpO1xufVxuLy8gKiogRGF0ZSBTZXR0ZXJzICoqXG4vKipcbiAqIFNldHMgdGhlIHRpbWUgZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHBhcmFtIHRpbWUgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgaG91ciwgbWludXRlLCBhbmQgc2Vjb25kLlxuICogQHJldHVybnMgLSBUaGUgZGF0ZSB3aXRoIHRoZSB0aW1lIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0VGltZShkYXRlLCBfYSkge1xuICAgIHZhciBfYiA9IF9hLmhvdXIsIGhvdXIgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IF9hLm1pbnV0ZSwgbWludXRlID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgX2QgPSBfYS5zZWNvbmQsIHNlY29uZCA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgcmV0dXJuIHNldEhvdXJzKHNldE1pbnV0ZXMoc2V0U2Vjb25kcyhkYXRlLCBzZWNvbmQpLCBtaW51dGUpLCBob3VyKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgd2VlayBvZiB0aGUgeWVhciBmb3IgYSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRoZSB3ZWVrIG9mIHRoZSB5ZWFyLlxuICovXG5mdW5jdGlvbiBnZXRXZWVrKGRhdGUpIHtcbiAgICByZXR1cm4gZ2V0SVNPV2VlayhkYXRlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgZGF5IG9mIHRoZSB3ZWVrIGNvZGUgZm9yIGEgZ2l2ZW4gZGF5LlxuICpcbiAqIEBwYXJhbSBkYXkgLSBUaGUgZGF5LlxuICogQHBhcmFtIGxvY2FsZSAtIFRoZSBsb2NhbGUuXG4gKiBAcmV0dXJucyAtIFRoZSBkYXkgb2YgdGhlIHdlZWsgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF5T2ZXZWVrQ29kZShkYXksIGxvY2FsZSkge1xuICAgIHJldHVybiBmb3JtYXREYXRlKGRheSwgXCJkZGRcIiwgbG9jYWxlKTtcbn1cbi8vICoqKiBTdGFydCBvZiAqKipcbi8qKlxuICogR2V0cyB0aGUgc3RhcnQgb2YgdGhlIGRheSBmb3IgYSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRoZSBzdGFydCBvZiB0aGUgZGF5LlxuICovXG5mdW5jdGlvbiBnZXRTdGFydE9mRGF5KGRhdGUpIHtcbiAgICByZXR1cm4gc3RhcnRPZkRheShkYXRlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHBhcmFtIGxvY2FsZSAtIFRoZSBsb2NhbGUuXG4gKiBAcGFyYW0gY2FsZW5kYXJTdGFydERheSAtIFRoZSBkYXkgdGhlIGNhbGVuZGFyIHN0YXJ0cyBvbi5cbiAqIEByZXR1cm5zIC0gVGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLlxuICovXG5mdW5jdGlvbiBnZXRTdGFydE9mV2VlayhkYXRlLCBsb2NhbGUsIGNhbGVuZGFyU3RhcnREYXkpIHtcbiAgICB2YXIgbG9jYWxlT2JqID0gbG9jYWxlXG4gICAgICAgID8gZ2V0TG9jYWxlT2JqZWN0KGxvY2FsZSlcbiAgICAgICAgOiBnZXRMb2NhbGVPYmplY3QoZ2V0RGVmYXVsdExvY2FsZSgpKTtcbiAgICByZXR1cm4gc3RhcnRPZldlZWsoZGF0ZSwge1xuICAgICAgICBsb2NhbGU6IGxvY2FsZU9iaixcbiAgICAgICAgd2Vla1N0YXJ0c09uOiBjYWxlbmRhclN0YXJ0RGF5LFxuICAgIH0pO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBzdGFydCBvZiB0aGUgbW9udGggZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHJldHVybnMgLSBUaGUgc3RhcnQgb2YgdGhlIG1vbnRoLlxuICovXG5mdW5jdGlvbiBnZXRTdGFydE9mTW9udGgoZGF0ZSkge1xuICAgIHJldHVybiBzdGFydE9mTW9udGgoZGF0ZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHN0YXJ0IG9mIHRoZSB5ZWFyIGZvciBhIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIHN0YXJ0IG9mIHRoZSB5ZWFyLlxuICovXG5mdW5jdGlvbiBnZXRTdGFydE9mWWVhcihkYXRlKSB7XG4gICAgcmV0dXJuIHN0YXJ0T2ZZZWFyKGRhdGUpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBzdGFydCBvZiB0aGUgcXVhcnRlciBmb3IgYSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRoZSBzdGFydCBvZiB0aGUgcXVhcnRlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhcnRPZlF1YXJ0ZXIoZGF0ZSkge1xuICAgIHJldHVybiBzdGFydE9mUXVhcnRlcihkYXRlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgc3RhcnQgb2YgdG9kYXkuXG4gKlxuICogQHJldHVybnMgLSBUaGUgc3RhcnQgb2YgdG9kYXkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXJ0T2ZUb2RheSgpIHtcbiAgICByZXR1cm4gc3RhcnRPZkRheShuZXdEYXRlKCkpO1xufVxuLy8gKioqIEVuZCBvZiAqKipcbi8qKlxuICogR2V0cyB0aGUgZW5kIG9mIHRoZSBkYXkgZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHJldHVybnMgLSBUaGUgZW5kIG9mIHRoZSBkYXkuXG4gKi9cbmZ1bmN0aW9uIGdldEVuZE9mRGF5KGRhdGUpIHtcbiAgICByZXR1cm4gZW5kT2ZEYXkoZGF0ZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIGVuZCBvZiB0aGUgd2VlayBmb3IgYSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRoZSBlbmQgb2YgdGhlIHdlZWsuXG4gKi9cbmZ1bmN0aW9uIGdldEVuZE9mV2VlayhkYXRlKSB7XG4gICAgcmV0dXJuIGVuZE9mV2VlayhkYXRlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgZW5kIG9mIHRoZSBtb250aCBmb3IgYSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRoZSBlbmQgb2YgdGhlIG1vbnRoLlxuICovXG5mdW5jdGlvbiBnZXRFbmRPZk1vbnRoKGRhdGUpIHtcbiAgICByZXR1cm4gZW5kT2ZNb250aChkYXRlKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgeWVhci5cbiAqXG4gKiBAcGFyYW0gZGF0ZTEgLSBUaGUgZmlyc3QgZGF0ZS5cbiAqIEBwYXJhbSBkYXRlMiAtIFRoZSBzZWNvbmQgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIHllYXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNTYW1lWWVhcihkYXRlMSwgZGF0ZTIpIHtcbiAgICBpZiAoZGF0ZTEgJiYgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZVllYXIkMShkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFkYXRlMSAmJiAhZGF0ZTI7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGRhdGVzIGFyZSBpbiB0aGUgc2FtZSBtb250aC5cbiAqXG4gKiBAcGFyYW0gZGF0ZTEgLSBUaGUgZmlyc3QgZGF0ZS5cbiAqIEBwYXJhbSBkYXRlMiAtIFRoZSBzZWNvbmQgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIG1vbnRoLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZU1vbnRoKGRhdGUxLCBkYXRlMikge1xuICAgIGlmIChkYXRlMSAmJiBkYXRlMikge1xuICAgICAgICByZXR1cm4gaXNTYW1lTW9udGgkMShkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFkYXRlMSAmJiAhZGF0ZTI7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGRhdGVzIGFyZSBpbiB0aGUgc2FtZSBxdWFydGVyLlxuICpcbiAqIEBwYXJhbSBkYXRlMSAtIFRoZSBmaXJzdCBkYXRlLlxuICogQHBhcmFtIGRhdGUyIC0gVGhlIHNlY29uZCBkYXRlLlxuICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgcXVhcnRlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NhbWVRdWFydGVyKGRhdGUxLCBkYXRlMikge1xuICAgIGlmIChkYXRlMSAmJiBkYXRlMikge1xuICAgICAgICByZXR1cm4gaXNTYW1lUXVhcnRlciQxKGRhdGUxLCBkYXRlMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gIWRhdGUxICYmICFkYXRlMjtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28gZGF0ZXMgYXJlIG9uIHRoZSBzYW1lIGRheS5cbiAqXG4gKiBAcGFyYW0gZGF0ZTEgLSBUaGUgZmlyc3QgZGF0ZS5cbiAqIEBwYXJhbSBkYXRlMiAtIFRoZSBzZWNvbmQgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgZGF0ZXMgYXJlIG9uIHRoZSBzYW1lIGRheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NhbWVEYXkoZGF0ZTEsIGRhdGUyKSB7XG4gICAgaWYgKGRhdGUxICYmIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBpc1NhbWVEYXkkMShkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFkYXRlMSAmJiAhZGF0ZTI7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGRhdGVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0gZGF0ZTEgLSBUaGUgZmlyc3QgZGF0ZS5cbiAqIEBwYXJhbSBkYXRlMiAtIFRoZSBzZWNvbmQgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgZGF0ZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwoZGF0ZTEsIGRhdGUyKSB7XG4gICAgaWYgKGRhdGUxICYmIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBpc0VxdWFsJDEoZGF0ZTEsIGRhdGUyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhZGF0ZTEgJiYgIWRhdGUyO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgZGF5IGlzIHdpdGhpbiBhIGRhdGUgcmFuZ2UuXG4gKlxuICogQHBhcmFtIGRheSAtIFRoZSBkYXkgdG8gY2hlY2suXG4gKiBAcGFyYW0gc3RhcnREYXRlIC0gVGhlIHN0YXJ0IGRhdGUgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIGVuZERhdGUgLSBUaGUgZW5kIGRhdGUgb2YgdGhlIHJhbmdlLlxuICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBkYXkgaXMgd2l0aGluIHRoZSByYW5nZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0RheUluUmFuZ2UoZGF5LCBzdGFydERhdGUsIGVuZERhdGUpIHtcbiAgICB2YXIgdmFsaWQ7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydERhdGUpO1xuICAgIHZhciBlbmQgPSBlbmRPZkRheShlbmREYXRlKTtcbiAgICB0cnkge1xuICAgICAgICB2YWxpZCA9IGlzV2l0aGluSW50ZXJ2YWwoZGF5LCB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xufVxuLy8gKiogRGF0ZSBMb2NhbGl6YXRpb24gKipcbi8qKlxuICogUmVnaXN0ZXJzIGEgbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGxvY2FsZS5cbiAqIEBwYXJhbSBsb2NhbGVEYXRhIC0gVGhlIGRhdGEgb2YgdGhlIGxvY2FsZS5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJMb2NhbGUobG9jYWxlTmFtZSwgbG9jYWxlRGF0YSkge1xuICAgIHZhciBzY29wZSA9IGdldExvY2FsZVNjb3BlKCk7XG4gICAgaWYgKCFzY29wZS5fX2xvY2FsZURhdGFfXykge1xuICAgICAgICBzY29wZS5fX2xvY2FsZURhdGFfXyA9IHt9O1xuICAgIH1cbiAgICBzY29wZS5fX2xvY2FsZURhdGFfX1tsb2NhbGVOYW1lXSA9IGxvY2FsZURhdGE7XG59XG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBsb2NhbGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGxvY2FsZS5cbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdExvY2FsZShsb2NhbGVOYW1lKSB7XG4gICAgdmFyIHNjb3BlID0gZ2V0TG9jYWxlU2NvcGUoKTtcbiAgICBzY29wZS5fX2xvY2FsZUlkX18gPSBsb2NhbGVOYW1lO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBkZWZhdWx0IGxvY2FsZS5cbiAqXG4gKiBAcmV0dXJucyAtIFRoZSBkZWZhdWx0IGxvY2FsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdExvY2FsZSgpIHtcbiAgICB2YXIgc2NvcGUgPSBnZXRMb2NhbGVTY29wZSgpO1xuICAgIHJldHVybiBzY29wZS5fX2xvY2FsZUlkX187XG59XG4vKipcbiAqIEdldHMgdGhlIGxvY2FsZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGxvY2FsZVNwZWMgLSBUaGUgbG9jYWxlIHNwZWNpZmljYXRpb24uXG4gKiBAcmV0dXJucyAtIFRoZSBsb2NhbGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRMb2NhbGVPYmplY3QobG9jYWxlU3BlYykge1xuICAgIGlmICh0eXBlb2YgbG9jYWxlU3BlYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBUcmVhdCBpdCBhcyBhIGxvY2FsZSBuYW1lIHJlZ2lzdGVyZWQgYnkgcmVnaXN0ZXJMb2NhbGVcbiAgICAgICAgdmFyIHNjb3BlID0gZ2V0TG9jYWxlU2NvcGUoKTtcbiAgICAgICAgLy8gTnVsbCB3YXMgcmVwbGFjZWQgd2l0aCB1bmRlZmluZWQgdG8gYXZvaWQgdHlwZSBjb2VyY2lvblxuICAgICAgICByZXR1cm4gc2NvcGUuX19sb2NhbGVEYXRhX18gPyBzY29wZS5fX2xvY2FsZURhdGFfX1tsb2NhbGVTcGVjXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRyZWF0IGl0IGFzIGEgcmF3IGRhdGUtZm5zIGxvY2FsZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIGxvY2FsZVNwZWM7XG4gICAgfVxufVxuLyoqXG4gKiBGb3JtYXRzIHRoZSB3ZWVrZGF5IGluIGEgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICogQHBhcmFtIGZvcm1hdEZ1bmMgLSBUaGUgZm9ybWF0dGluZyBmdW5jdGlvbi5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIC0gVGhlIGZvcm1hdHRlZCB3ZWVrZGF5LlxuICovXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRXZWVrZGF5SW5Mb2NhbGUoZGF0ZSwgZm9ybWF0RnVuYywgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGZvcm1hdEZ1bmMoZm9ybWF0RGF0ZShkYXRlLCBcIkVFRUVcIiwgbG9jYWxlKSk7XG59XG4vKipcbiAqIEdldHMgdGhlIG1pbmltdW0gd2Vla2RheSBpbiBhIGdpdmVuIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIC0gVGhlIG1pbmltdW0gd2Vla2RheS5cbiAqL1xuZnVuY3Rpb24gZ2V0V2Vla2RheU1pbkluTG9jYWxlKGRhdGUsIGxvY2FsZSkge1xuICAgIHJldHVybiBmb3JtYXREYXRlKGRhdGUsIFwiRUVFRUVFXCIsIGxvY2FsZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHNob3J0IHdlZWtkYXkgaW4gYSBnaXZlbiBsb2NhbGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gKiBAcGFyYW0gbG9jYWxlIC0gVGhlIGxvY2FsZSB0byB1c2UgZm9yIGZvcm1hdHRpbmcuXG4gKiBAcmV0dXJucyAtIFRoZSBzaG9ydCB3ZWVrZGF5LlxuICovXG5mdW5jdGlvbiBnZXRXZWVrZGF5U2hvcnRJbkxvY2FsZShkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXRlLCBcIkVFRVwiLCBsb2NhbGUpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBtb250aCBpbiBhIGdpdmVuIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0gbW9udGggLSBUaGUgbW9udGggdG8gZm9ybWF0LlxuICogQHBhcmFtIGxvY2FsZSAtIFRoZSBsb2NhbGUgdG8gdXNlIGZvciBmb3JtYXR0aW5nLlxuICogQHJldHVybnMgLSBUaGUgbW9udGguXG4gKi9cbmZ1bmN0aW9uIGdldE1vbnRoSW5Mb2NhbGUobW9udGgsIGxvY2FsZSkge1xuICAgIHJldHVybiBmb3JtYXREYXRlKHNldE1vbnRoKG5ld0RhdGUoKSwgbW9udGgpLCBcIkxMTExcIiwgbG9jYWxlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgc2hvcnQgbW9udGggaW4gYSBnaXZlbiBsb2NhbGUuXG4gKlxuICogQHBhcmFtIG1vbnRoIC0gVGhlIG1vbnRoIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIC0gVGhlIHNob3J0IG1vbnRoLlxuICovXG5mdW5jdGlvbiBnZXRNb250aFNob3J0SW5Mb2NhbGUobW9udGgsIGxvY2FsZSkge1xuICAgIHJldHVybiBmb3JtYXREYXRlKHNldE1vbnRoKG5ld0RhdGUoKSwgbW9udGgpLCBcIkxMTFwiLCBsb2NhbGUpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBzaG9ydCBxdWFydGVyIGluIGEgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBxdWFydGVyIC0gVGhlIHF1YXJ0ZXIgdG8gZm9ybWF0LlxuICogQHBhcmFtIGxvY2FsZSAtIFRoZSBsb2NhbGUgdG8gdXNlIGZvciBmb3JtYXR0aW5nLlxuICogQHJldHVybnMgLSBUaGUgc2hvcnQgcXVhcnRlci5cbiAqL1xuZnVuY3Rpb24gZ2V0UXVhcnRlclNob3J0SW5Mb2NhbGUocXVhcnRlciwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGZvcm1hdERhdGUoc2V0UXVhcnRlcihuZXdEYXRlKCksIHF1YXJ0ZXIpLCBcIlFRUVwiLCBsb2NhbGUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBkYXkgaXMgZGlzYWJsZWQuXG4gKlxuICogQHBhcmFtIGRheSAtIFRoZSBkYXkgdG8gY2hlY2suXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcuXG4gKiBAcmV0dXJucyAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF5IGlzIGRpc2FibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRGF5RGlzYWJsZWQoZGF5LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9iLmV4Y2x1ZGVEYXRlcywgZXhjbHVkZURhdGVJbnRlcnZhbHMgPSBfYi5leGNsdWRlRGF0ZUludGVydmFscywgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzLCBpbmNsdWRlRGF0ZUludGVydmFscyA9IF9iLmluY2x1ZGVEYXRlSW50ZXJ2YWxzLCBmaWx0ZXJEYXRlID0gX2IuZmlsdGVyRGF0ZSwgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZDtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAoaXNPdXRPZkJvdW5kcyhkYXksIHsgbWluRGF0ZTogbWluRGF0ZSwgbWF4RGF0ZTogbWF4RGF0ZSB9KSB8fFxuICAgICAgICAoZXhjbHVkZURhdGVzICYmXG4gICAgICAgICAgICBleGNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZURhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBleGNsdWRlRGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgZXhjbHVkZURhdGUuZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIChleGNsdWRlRGF0ZUludGVydmFscyAmJlxuICAgICAgICAgICAgZXhjbHVkZURhdGVJbnRlcnZhbHMuc29tZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1dpdGhpbkludGVydmFsKGRheSwgeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0pO1xuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgICFpbmNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHsgcmV0dXJuIGlzU2FtZURheShkYXksIGluY2x1ZGVEYXRlKTsgfSkpIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZUludGVydmFscyAmJlxuICAgICAgICAgICAgIWluY2x1ZGVEYXRlSW50ZXJ2YWxzLnNvbWUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gX2Euc3RhcnQsIGVuZCA9IF9hLmVuZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNXaXRoaW5JbnRlcnZhbChkYXksIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KTtcbiAgICAgICAgICAgIH0pKSB8fFxuICAgICAgICAoZmlsdGVyRGF0ZSAmJiAhZmlsdGVyRGF0ZShuZXdEYXRlKGRheSkpKSB8fFxuICAgICAgICBmYWxzZSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIGRheSBpcyBleGNsdWRlZC5cbiAqXG4gKiBAcGFyYW0gZGF5IC0gVGhlIGRheSB0byBjaGVjay5cbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZy5cbiAqIEByZXR1cm5zIC0gUmV0dXJucyB0cnVlIGlmIHRoZSBkYXkgaXMgZXhjbHVkZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNEYXlFeGNsdWRlZChkYXksIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGV4Y2x1ZGVEYXRlcyA9IF9iLmV4Y2x1ZGVEYXRlcywgZXhjbHVkZURhdGVJbnRlcnZhbHMgPSBfYi5leGNsdWRlRGF0ZUludGVydmFscztcbiAgICBpZiAoZXhjbHVkZURhdGVJbnRlcnZhbHMgJiYgZXhjbHVkZURhdGVJbnRlcnZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZXhjbHVkZURhdGVJbnRlcnZhbHMuc29tZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQ7XG4gICAgICAgICAgICByZXR1cm4gaXNXaXRoaW5JbnRlcnZhbChkYXksIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKGV4Y2x1ZGVEYXRlcyAmJlxuICAgICAgICBleGNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlRGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgZXhjbHVkZURhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIChfYSA9IGV4Y2x1ZGVEYXRlLmRhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNNb250aERpc2FibGVkKG1vbnRoLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9iLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzLCBmaWx0ZXJEYXRlID0gX2IuZmlsdGVyRGF0ZTtcbiAgICByZXR1cm4gKGlzT3V0T2ZCb3VuZHMobW9udGgsIHtcbiAgICAgICAgbWluRGF0ZTogbWluRGF0ZSA/IHN0YXJ0T2ZNb250aChtaW5EYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4RGF0ZTogbWF4RGF0ZSA/IGVuZE9mTW9udGgobWF4RGF0ZSkgOiB1bmRlZmluZWQsXG4gICAgfSkgfHxcbiAgICAgICAgKGV4Y2x1ZGVEYXRlcyA9PT0gbnVsbCB8fCBleGNsdWRlRGF0ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4Y2x1ZGVEYXRlcy5zb21lKGZ1bmN0aW9uIChleGNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZU1vbnRoKG1vbnRoLCBleGNsdWRlRGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBleGNsdWRlRGF0ZSA6IGV4Y2x1ZGVEYXRlLmRhdGUpO1xuICAgICAgICB9KSkgfHxcbiAgICAgICAgKGluY2x1ZGVEYXRlcyAmJlxuICAgICAgICAgICAgIWluY2x1ZGVEYXRlcy5zb21lKGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkgeyByZXR1cm4gaXNTYW1lTW9udGgobW9udGgsIGluY2x1ZGVEYXRlKTsgfSkpIHx8XG4gICAgICAgIChmaWx0ZXJEYXRlICYmICFmaWx0ZXJEYXRlKG5ld0RhdGUobW9udGgpKSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNNb250aEluUmFuZ2Uoc3RhcnREYXRlLCBlbmREYXRlLCBtLCBkYXkpIHtcbiAgICB2YXIgc3RhcnREYXRlWWVhciA9IGdldFllYXIoc3RhcnREYXRlKTtcbiAgICB2YXIgc3RhcnREYXRlTW9udGggPSBnZXRNb250aChzdGFydERhdGUpO1xuICAgIHZhciBlbmREYXRlWWVhciA9IGdldFllYXIoZW5kRGF0ZSk7XG4gICAgdmFyIGVuZERhdGVNb250aCA9IGdldE1vbnRoKGVuZERhdGUpO1xuICAgIHZhciBkYXlZZWFyID0gZ2V0WWVhcihkYXkpO1xuICAgIGlmIChzdGFydERhdGVZZWFyID09PSBlbmREYXRlWWVhciAmJiBzdGFydERhdGVZZWFyID09PSBkYXlZZWFyKSB7XG4gICAgICAgIHJldHVybiBzdGFydERhdGVNb250aCA8PSBtICYmIG0gPD0gZW5kRGF0ZU1vbnRoO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGFydERhdGVZZWFyIDwgZW5kRGF0ZVllYXIpIHtcbiAgICAgICAgcmV0dXJuICgoZGF5WWVhciA9PT0gc3RhcnREYXRlWWVhciAmJiBzdGFydERhdGVNb250aCA8PSBtKSB8fFxuICAgICAgICAgICAgKGRheVllYXIgPT09IGVuZERhdGVZZWFyICYmIGVuZERhdGVNb250aCA+PSBtKSB8fFxuICAgICAgICAgICAgKGRheVllYXIgPCBlbmREYXRlWWVhciAmJiBkYXlZZWFyID4gc3RhcnREYXRlWWVhcikpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFRvIGNoZWNrIGlmIGEgZGF0ZSdzIG1vbnRoIGFuZCB5ZWFyIGFyZSBkaXNhYmxlZC9leGNsdWRlZFxuICogQHBhcmFtIGRhdGUgRGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbW9udGggYW5kIHllYXIgYXJlIGRpc2FibGVkL2V4Y2x1ZGVkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNNb250aFllYXJEaXNhYmxlZChkYXRlLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9iLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzO1xuICAgIHJldHVybiAoaXNPdXRPZkJvdW5kcyhkYXRlLCB7IG1pbkRhdGU6IG1pbkRhdGUsIG1heERhdGU6IG1heERhdGUgfSkgfHxcbiAgICAgICAgKGV4Y2x1ZGVEYXRlcyAmJlxuICAgICAgICAgICAgZXhjbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGV4Y2x1ZGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChleGNsdWRlZERhdGUgaW5zdGFuY2VvZiBEYXRlID8gZXhjbHVkZWREYXRlIDogZXhjbHVkZWREYXRlLmRhdGUsIGRhdGUpO1xuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgICFpbmNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoaW5jbHVkZWREYXRlKSB7IHJldHVybiBpc1NhbWVNb250aChpbmNsdWRlZERhdGUsIGRhdGUpOyB9KSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNRdWFydGVyRGlzYWJsZWQocXVhcnRlciwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9iLm1pbkRhdGUsIG1heERhdGUgPSBfYi5tYXhEYXRlLCBleGNsdWRlRGF0ZXMgPSBfYi5leGNsdWRlRGF0ZXMsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcywgZmlsdGVyRGF0ZSA9IF9iLmZpbHRlckRhdGUsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQ7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKGlzT3V0T2ZCb3VuZHMocXVhcnRlciwgeyBtaW5EYXRlOiBtaW5EYXRlLCBtYXhEYXRlOiBtYXhEYXRlIH0pIHx8XG4gICAgICAgIChleGNsdWRlRGF0ZXMgPT09IG51bGwgfHwgZXhjbHVkZURhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVRdWFydGVyKHF1YXJ0ZXIsIGV4Y2x1ZGVEYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGV4Y2x1ZGVEYXRlIDogZXhjbHVkZURhdGUuZGF0ZSk7XG4gICAgICAgIH0pKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICAhaW5jbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZVF1YXJ0ZXIocXVhcnRlciwgaW5jbHVkZURhdGUpO1xuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIChmaWx0ZXJEYXRlICYmICFmaWx0ZXJEYXRlKG5ld0RhdGUocXVhcnRlcikpKSB8fFxuICAgICAgICBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc1llYXJJblJhbmdlKHllYXIsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzVmFsaWQkMShzdGFydCkgfHwgIWlzVmFsaWQkMShlbmQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHN0YXJ0WWVhciA9IGdldFllYXIoc3RhcnQpO1xuICAgIHZhciBlbmRZZWFyID0gZ2V0WWVhcihlbmQpO1xuICAgIHJldHVybiBzdGFydFllYXIgPD0geWVhciAmJiBlbmRZZWFyID49IHllYXI7XG59XG5mdW5jdGlvbiBpc1llYXJEaXNhYmxlZCh5ZWFyLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9iLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzLCBmaWx0ZXJEYXRlID0gX2IuZmlsdGVyRGF0ZSwgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZDtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoeWVhciwgMCwgMSk7XG4gICAgcmV0dXJuIChpc091dE9mQm91bmRzKGRhdGUsIHtcbiAgICAgICAgbWluRGF0ZTogbWluRGF0ZSA/IHN0YXJ0T2ZZZWFyKG1pbkRhdGUpIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhEYXRlOiBtYXhEYXRlID8gZW5kT2ZZZWFyKG1heERhdGUpIDogdW5kZWZpbmVkLFxuICAgIH0pIHx8XG4gICAgICAgIChleGNsdWRlRGF0ZXMgPT09IG51bGwgfHwgZXhjbHVkZURhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVZZWFyKGRhdGUsIGV4Y2x1ZGVEYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGV4Y2x1ZGVEYXRlIDogZXhjbHVkZURhdGUuZGF0ZSk7XG4gICAgICAgIH0pKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICAhaW5jbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7IHJldHVybiBpc1NhbWVZZWFyKGRhdGUsIGluY2x1ZGVEYXRlKTsgfSkpIHx8XG4gICAgICAgIChmaWx0ZXJEYXRlICYmICFmaWx0ZXJEYXRlKG5ld0RhdGUoZGF0ZSkpKSB8fFxuICAgICAgICBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc1F1YXJ0ZXJJblJhbmdlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgcSwgZGF5KSB7XG4gICAgdmFyIHN0YXJ0RGF0ZVllYXIgPSBnZXRZZWFyKHN0YXJ0RGF0ZSk7XG4gICAgdmFyIHN0YXJ0RGF0ZVF1YXJ0ZXIgPSBnZXRRdWFydGVyKHN0YXJ0RGF0ZSk7XG4gICAgdmFyIGVuZERhdGVZZWFyID0gZ2V0WWVhcihlbmREYXRlKTtcbiAgICB2YXIgZW5kRGF0ZVF1YXJ0ZXIgPSBnZXRRdWFydGVyKGVuZERhdGUpO1xuICAgIHZhciBkYXlZZWFyID0gZ2V0WWVhcihkYXkpO1xuICAgIGlmIChzdGFydERhdGVZZWFyID09PSBlbmREYXRlWWVhciAmJiBzdGFydERhdGVZZWFyID09PSBkYXlZZWFyKSB7XG4gICAgICAgIHJldHVybiBzdGFydERhdGVRdWFydGVyIDw9IHEgJiYgcSA8PSBlbmREYXRlUXVhcnRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnREYXRlWWVhciA8IGVuZERhdGVZZWFyKSB7XG4gICAgICAgIHJldHVybiAoKGRheVllYXIgPT09IHN0YXJ0RGF0ZVllYXIgJiYgc3RhcnREYXRlUXVhcnRlciA8PSBxKSB8fFxuICAgICAgICAgICAgKGRheVllYXIgPT09IGVuZERhdGVZZWFyICYmIGVuZERhdGVRdWFydGVyID49IHEpIHx8XG4gICAgICAgICAgICAoZGF5WWVhciA8IGVuZERhdGVZZWFyICYmIGRheVllYXIgPiBzdGFydERhdGVZZWFyKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT3V0T2ZCb3VuZHMoZGF5LCBfYSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgX2MgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9jLm1pbkRhdGUsIG1heERhdGUgPSBfYy5tYXhEYXRlO1xuICAgIHJldHVybiAoKF9iID0gKChtaW5EYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhkYXksIG1pbkRhdGUpIDwgMCkgfHxcbiAgICAgICAgKG1heERhdGUgJiYgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKGRheSwgbWF4RGF0ZSkgPiAwKSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGlzVGltZUluTGlzdCh0aW1lLCB0aW1lcykge1xuICAgIHJldHVybiB0aW1lcy5zb21lKGZ1bmN0aW9uIChsaXN0VGltZSkge1xuICAgICAgICByZXR1cm4gZ2V0SG91cnMobGlzdFRpbWUpID09PSBnZXRIb3Vycyh0aW1lKSAmJlxuICAgICAgICAgICAgZ2V0TWludXRlcyhsaXN0VGltZSkgPT09IGdldE1pbnV0ZXModGltZSkgJiZcbiAgICAgICAgICAgIGdldFNlY29uZHMobGlzdFRpbWUpID09PSBnZXRTZWNvbmRzKHRpbWUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNUaW1lRGlzYWJsZWQodGltZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgZXhjbHVkZVRpbWVzID0gX2IuZXhjbHVkZVRpbWVzLCBpbmNsdWRlVGltZXMgPSBfYi5pbmNsdWRlVGltZXMsIGZpbHRlclRpbWUgPSBfYi5maWx0ZXJUaW1lO1xuICAgIHJldHVybiAoKGV4Y2x1ZGVUaW1lcyAmJiBpc1RpbWVJbkxpc3QodGltZSwgZXhjbHVkZVRpbWVzKSkgfHxcbiAgICAgICAgKGluY2x1ZGVUaW1lcyAmJiAhaXNUaW1lSW5MaXN0KHRpbWUsIGluY2x1ZGVUaW1lcykpIHx8XG4gICAgICAgIChmaWx0ZXJUaW1lICYmICFmaWx0ZXJUaW1lKHRpbWUpKSB8fFxuICAgICAgICBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc1RpbWVJbkRpc2FibGVkUmFuZ2UodGltZSwgX2EpIHtcbiAgICB2YXIgbWluVGltZSA9IF9hLm1pblRpbWUsIG1heFRpbWUgPSBfYS5tYXhUaW1lO1xuICAgIGlmICghbWluVGltZSB8fCAhbWF4VGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIG1pblRpbWUgYW5kIG1heFRpbWUgcHJvcHMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHZhciBiYXNlVGltZSA9IG5ld0RhdGUoKTtcbiAgICBiYXNlVGltZSA9IHNldEhvdXJzKGJhc2VUaW1lLCBnZXRIb3Vycyh0aW1lKSk7XG4gICAgYmFzZVRpbWUgPSBzZXRNaW51dGVzKGJhc2VUaW1lLCBnZXRNaW51dGVzKHRpbWUpKTtcbiAgICBiYXNlVGltZSA9IHNldFNlY29uZHMoYmFzZVRpbWUsIGdldFNlY29uZHModGltZSkpO1xuICAgIHZhciBtaW4gPSBuZXdEYXRlKCk7XG4gICAgbWluID0gc2V0SG91cnMobWluLCBnZXRIb3VycyhtaW5UaW1lKSk7XG4gICAgbWluID0gc2V0TWludXRlcyhtaW4sIGdldE1pbnV0ZXMobWluVGltZSkpO1xuICAgIG1pbiA9IHNldFNlY29uZHMobWluLCBnZXRTZWNvbmRzKG1pblRpbWUpKTtcbiAgICB2YXIgbWF4ID0gbmV3RGF0ZSgpO1xuICAgIG1heCA9IHNldEhvdXJzKG1heCwgZ2V0SG91cnMobWF4VGltZSkpO1xuICAgIG1heCA9IHNldE1pbnV0ZXMobWF4LCBnZXRNaW51dGVzKG1heFRpbWUpKTtcbiAgICBtYXggPSBzZXRTZWNvbmRzKG1heCwgZ2V0U2Vjb25kcyhtYXhUaW1lKSk7XG4gICAgdmFyIHZhbGlkO1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkID0gIWlzV2l0aGluSW50ZXJ2YWwoYmFzZVRpbWUsIHsgc3RhcnQ6IG1pbiwgZW5kOiBtYXggfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBkYXRlLWZucyBoaXN0b3JpY2FsbHkgdGhyZXcgb24gaW52YWxpZCBpbnRlcnZhbHMgKi9cbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xufVxuZnVuY3Rpb24gbW9udGhEaXNhYmxlZEJlZm9yZShkYXksIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbkRhdGUgPSBfYi5taW5EYXRlLCBpbmNsdWRlRGF0ZXMgPSBfYi5pbmNsdWRlRGF0ZXM7XG4gICAgdmFyIHByZXZpb3VzTW9udGggPSBzdWJNb250aHMoZGF5LCAxKTtcbiAgICByZXR1cm4gKChtaW5EYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKG1pbkRhdGUsIHByZXZpb3VzTW9udGgpID4gMCkgfHxcbiAgICAgICAgKGluY2x1ZGVEYXRlcyAmJlxuICAgICAgICAgICAgaW5jbHVkZURhdGVzLmV2ZXJ5KGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyhpbmNsdWRlRGF0ZSwgcHJldmlvdXNNb250aCkgPiAwO1xuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIG1vbnRoRGlzYWJsZWRBZnRlcihkYXksIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1heERhdGUgPSBfYi5tYXhEYXRlLCBpbmNsdWRlRGF0ZXMgPSBfYi5pbmNsdWRlRGF0ZXM7XG4gICAgdmFyIG5leHRNb250aCA9IGFkZE1vbnRocyhkYXksIDEpO1xuICAgIHJldHVybiAoKG1heERhdGUgJiYgZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMobmV4dE1vbnRoLCBtYXhEYXRlKSA+IDApIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgIGluY2x1ZGVEYXRlcy5ldmVyeShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHsgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKG5leHRNb250aCwgaW5jbHVkZURhdGUpID4gMDsgfSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0ZXJEaXNhYmxlZEJlZm9yZShkYXRlLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzO1xuICAgIHZhciBmaXJzdERhdGVPZlllYXIgPSBzdGFydE9mWWVhcihkYXRlKTtcbiAgICB2YXIgcHJldmlvdXNRdWFydGVyID0gc3ViUXVhcnRlcnMoZmlyc3REYXRlT2ZZZWFyLCAxKTtcbiAgICByZXR1cm4gKChtaW5EYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMobWluRGF0ZSwgcHJldmlvdXNRdWFydGVyKSA+IDApIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgIGluY2x1ZGVEYXRlcy5ldmVyeShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZmVyZW5jZUluQ2FsZW5kYXJRdWFydGVycyhpbmNsdWRlRGF0ZSwgcHJldmlvdXNRdWFydGVyKSA+IDA7XG4gICAgICAgICAgICB9KSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24gcXVhcnRlckRpc2FibGVkQWZ0ZXIoZGF0ZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcztcbiAgICB2YXIgbGFzdERhdGVPZlllYXIgPSBlbmRPZlllYXIoZGF0ZSk7XG4gICAgdmFyIG5leHRRdWFydGVyID0gYWRkUXVhcnRlcnMobGFzdERhdGVPZlllYXIsIDEpO1xuICAgIHJldHVybiAoKG1heERhdGUgJiYgZGlmZmVyZW5jZUluQ2FsZW5kYXJRdWFydGVycyhuZXh0UXVhcnRlciwgbWF4RGF0ZSkgPiAwKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICBpbmNsdWRlRGF0ZXMuZXZlcnkoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMobmV4dFF1YXJ0ZXIsIGluY2x1ZGVEYXRlKSA+IDA7XG4gICAgICAgICAgICB9KSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24geWVhckRpc2FibGVkQmVmb3JlKGRheSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9iLm1pbkRhdGUsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcztcbiAgICB2YXIgcHJldmlvdXNZZWFyID0gc3ViWWVhcnMoZGF5LCAxKTtcbiAgICByZXR1cm4gKChtaW5EYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMobWluRGF0ZSwgcHJldmlvdXNZZWFyKSA+IDApIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgIGluY2x1ZGVEYXRlcy5ldmVyeShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZmVyZW5jZUluQ2FsZW5kYXJZZWFycyhpbmNsdWRlRGF0ZSwgcHJldmlvdXNZZWFyKSA+IDA7XG4gICAgICAgICAgICB9KSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24geWVhcnNEaXNhYmxlZEJlZm9yZShkYXksIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbkRhdGUgPSBfYi5taW5EYXRlLCBfYyA9IF9iLnllYXJJdGVtTnVtYmVyLCB5ZWFySXRlbU51bWJlciA9IF9jID09PSB2b2lkIDAgPyBERUZBVUxUX1lFQVJfSVRFTV9OVU1CRVIgOiBfYztcbiAgICB2YXIgcHJldmlvdXNZZWFyID0gZ2V0U3RhcnRPZlllYXIoc3ViWWVhcnMoZGF5LCB5ZWFySXRlbU51bWJlcikpO1xuICAgIHZhciBlbmRQZXJpb2QgPSBnZXRZZWFyc1BlcmlvZChwcmV2aW91c1llYXIsIHllYXJJdGVtTnVtYmVyKS5lbmRQZXJpb2Q7XG4gICAgdmFyIG1pbkRhdGVZZWFyID0gbWluRGF0ZSAmJiBnZXRZZWFyKG1pbkRhdGUpO1xuICAgIHJldHVybiAobWluRGF0ZVllYXIgJiYgbWluRGF0ZVllYXIgPiBlbmRQZXJpb2QpIHx8IGZhbHNlO1xufVxuZnVuY3Rpb24geWVhckRpc2FibGVkQWZ0ZXIoZGF5LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtYXhEYXRlID0gX2IubWF4RGF0ZSwgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzO1xuICAgIHZhciBuZXh0WWVhciA9IGFkZFllYXJzKGRheSwgMSk7XG4gICAgcmV0dXJuICgobWF4RGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzKG5leHRZZWFyLCBtYXhEYXRlKSA+IDApIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgIGluY2x1ZGVEYXRlcy5ldmVyeShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHsgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMobmV4dFllYXIsIGluY2x1ZGVEYXRlKSA+IDA7IH0pKSB8fFxuICAgICAgICBmYWxzZSk7XG59XG5mdW5jdGlvbiB5ZWFyc0Rpc2FibGVkQWZ0ZXIoZGF5LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtYXhEYXRlID0gX2IubWF4RGF0ZSwgX2MgPSBfYi55ZWFySXRlbU51bWJlciwgeWVhckl0ZW1OdW1iZXIgPSBfYyA9PT0gdm9pZCAwID8gREVGQVVMVF9ZRUFSX0lURU1fTlVNQkVSIDogX2M7XG4gICAgdmFyIG5leHRZZWFyID0gYWRkWWVhcnMoZGF5LCB5ZWFySXRlbU51bWJlcik7XG4gICAgdmFyIHN0YXJ0UGVyaW9kID0gZ2V0WWVhcnNQZXJpb2QobmV4dFllYXIsIHllYXJJdGVtTnVtYmVyKS5zdGFydFBlcmlvZDtcbiAgICB2YXIgbWF4RGF0ZVllYXIgPSBtYXhEYXRlICYmIGdldFllYXIobWF4RGF0ZSk7XG4gICAgcmV0dXJuIChtYXhEYXRlWWVhciAmJiBtYXhEYXRlWWVhciA8IHN0YXJ0UGVyaW9kKSB8fCBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZU1pbkRhdGUoX2EpIHtcbiAgICB2YXIgbWluRGF0ZSA9IF9hLm1pbkRhdGUsIGluY2x1ZGVEYXRlcyA9IF9hLmluY2x1ZGVEYXRlcztcbiAgICBpZiAoaW5jbHVkZURhdGVzICYmIG1pbkRhdGUpIHtcbiAgICAgICAgdmFyIG1pbkRhdGVzID0gaW5jbHVkZURhdGVzLmZpbHRlcihmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHsgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhpbmNsdWRlRGF0ZSwgbWluRGF0ZSkgPj0gMDsgfSk7XG4gICAgICAgIHJldHVybiBtaW4obWluRGF0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmNsdWRlRGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG1pbihpbmNsdWRlRGF0ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pbkRhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RWZmZWN0aXZlTWF4RGF0ZShfYSkge1xuICAgIHZhciBtYXhEYXRlID0gX2EubWF4RGF0ZSwgaW5jbHVkZURhdGVzID0gX2EuaW5jbHVkZURhdGVzO1xuICAgIGlmIChpbmNsdWRlRGF0ZXMgJiYgbWF4RGF0ZSkge1xuICAgICAgICB2YXIgbWF4RGF0ZXMgPSBpbmNsdWRlRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkgeyByZXR1cm4gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKGluY2x1ZGVEYXRlLCBtYXhEYXRlKSA8PSAwOyB9KTtcbiAgICAgICAgcmV0dXJuIG1heChtYXhEYXRlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGluY2x1ZGVEYXRlcykge1xuICAgICAgICByZXR1cm4gbWF4KGluY2x1ZGVEYXRlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF4RGF0ZTtcbiAgICB9XG59XG4vKipcbiAqIEdldCBhIG1hcCBvZiBoaWdobGlnaHRlZCBkYXRlcyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2xhc3Nlcy5cbiAqIEBwYXJhbSBoaWdobGlnaHREYXRlcyBUaGUgZGF0ZXMgdG8gaGlnaGxpZ2h0LlxuICogQHBhcmFtIGRlZmF1bHRDbGFzc05hbWUgVGhlIGRlZmF1bHQgY2xhc3MgdG8gdXNlIGZvciBoaWdobGlnaHRpbmcuXG4gKiBAcmV0dXJucyBBIG1hcCB3aXRoIGRhdGVzIGFzIGtleXMgYW5kIGFycmF5cyBvZiBjbGFzcyBuYW1lcyBhcyB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEhpZ2hMaWdodERheXNNYXAoaGlnaGxpZ2h0RGF0ZXMsIGRlZmF1bHRDbGFzc05hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGhpZ2hsaWdodERhdGVzID09PSB2b2lkIDApIHsgaGlnaGxpZ2h0RGF0ZXMgPSBbXTsgfVxuICAgIGlmIChkZWZhdWx0Q2xhc3NOYW1lID09PSB2b2lkIDApIHsgZGVmYXVsdENsYXNzTmFtZSA9IFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1oaWdobGlnaHRlZFwiOyB9XG4gICAgdmFyIGRhdGVDbGFzc2VzID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoaWdobGlnaHREYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gaGlnaGxpZ2h0RGF0ZXNbaV07XG4gICAgICAgIGlmIChpc0RhdGUob2JqKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGZvcm1hdERhdGUob2JqLCBcIk1NLmRkLnl5eXlcIik7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lc0FyciA9IGRhdGVDbGFzc2VzLmdldChrZXkpIHx8IFtdO1xuICAgICAgICAgICAgaWYgKCFjbGFzc05hbWVzQXJyLmluY2x1ZGVzKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lc0Fyci5wdXNoKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGRhdGVDbGFzc2VzLnNldChrZXksIGNsYXNzTmFtZXNBcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAoX2EgPSBrZXlzWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIGFyck9mRGF0ZXMgPSBvYmpbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoYXJyT2ZEYXRlcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgbGVuXzEgPSBhcnJPZkRhdGVzLmxlbmd0aDsgayA8IGxlbl8xOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGVLID0gYXJyT2ZEYXRlc1trXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZm9ybWF0RGF0ZShkYXRlSywgXCJNTS5kZC55eXl5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXNBcnIgPSBkYXRlQ2xhc3Nlcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xhc3NOYW1lc0Fyci5pbmNsdWRlcyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lc0Fyci5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUNsYXNzZXMuc2V0KGtleSwgY2xhc3NOYW1lc0Fycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGVDbGFzc2VzO1xufVxuLyoqXG4gKiBDb21wYXJlIHRoZSB0d28gYXJyYXlzXG4gKiBAcGFyYW0gYXJyYXkxIFRoZSBmaXJzdCBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIGFycmF5MiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlLCBpZiB0aGUgcGFzc2VkIGFycmF5cyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlzQXJlRXF1YWwoYXJyYXkxLCBhcnJheTIpIHtcbiAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTEuZXZlcnkoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gdmFsdWUgPT09IGFycmF5MltpbmRleF07IH0pO1xufVxuLyoqXG4gKiBBc3NpZ24gdGhlIGN1c3RvbSBjbGFzcyB0byBlYWNoIGRhdGVcbiAqIEBwYXJhbSBob2xpZGF5RGF0ZXMgYXJyYXkgb2Ygb2JqZWN0IGNvbnRhaW5pbmcgZGF0ZSBhbmQgbmFtZSBvZiB0aGUgaG9saWRheVxuICogQHBhcmFtIGRlZmF1bHRDbGFzc05hbWUgY2xhc3NOYW1lIHRvIGJlIGFkZGVkLlxuICogQHJldHVybnMgTWFwIGNvbnRhaW5pbmcgZGF0ZSBhcyBrZXkgYW5kIGFycmF5IG9mIGNsYXNzTmFtZSBhbmQgaG9saWRheSBuYW1lIGFzIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldEhvbGlkYXlzTWFwKGhvbGlkYXlEYXRlcywgZGVmYXVsdENsYXNzTmFtZSkge1xuICAgIGlmIChob2xpZGF5RGF0ZXMgPT09IHZvaWQgMCkgeyBob2xpZGF5RGF0ZXMgPSBbXTsgfVxuICAgIGlmIChkZWZhdWx0Q2xhc3NOYW1lID09PSB2b2lkIDApIHsgZGVmYXVsdENsYXNzTmFtZSA9IFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1ob2xpZGF5c1wiOyB9XG4gICAgdmFyIGRhdGVDbGFzc2VzID0gbmV3IE1hcCgpO1xuICAgIGhvbGlkYXlEYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChob2xpZGF5KSB7XG4gICAgICAgIHZhciBkYXRlT2JqID0gaG9saWRheS5kYXRlLCBob2xpZGF5TmFtZSA9IGhvbGlkYXkuaG9saWRheU5hbWU7XG4gICAgICAgIGlmICghaXNEYXRlKGRhdGVPYmopKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGZvcm1hdERhdGUoZGF0ZU9iaiwgXCJNTS5kZC55eXl5XCIpO1xuICAgICAgICB2YXIgY2xhc3NOYW1lc09iaiA9IGRhdGVDbGFzc2VzLmdldChrZXkpIHx8IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJcIixcbiAgICAgICAgICAgIGhvbGlkYXlOYW1lczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChcImNsYXNzTmFtZVwiIGluIGNsYXNzTmFtZXNPYmogJiZcbiAgICAgICAgICAgIGNsYXNzTmFtZXNPYmpbXCJjbGFzc05hbWVcIl0gPT09IGRlZmF1bHRDbGFzc05hbWUgJiZcbiAgICAgICAgICAgIGFycmF5c0FyZUVxdWFsKGNsYXNzTmFtZXNPYmpbXCJob2xpZGF5TmFtZXNcIl0sIFtob2xpZGF5TmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NOYW1lc09ialtcImNsYXNzTmFtZVwiXSA9IGRlZmF1bHRDbGFzc05hbWU7XG4gICAgICAgIHZhciBob2xpZGF5TmFtZUFyciA9IGNsYXNzTmFtZXNPYmpbXCJob2xpZGF5TmFtZXNcIl07XG4gICAgICAgIGNsYXNzTmFtZXNPYmpbXCJob2xpZGF5TmFtZXNcIl0gPSBob2xpZGF5TmFtZUFyclxuICAgICAgICAgICAgPyBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGhvbGlkYXlOYW1lQXJyLCB0cnVlKSwgW2hvbGlkYXlOYW1lXSwgZmFsc2UpIDogW2hvbGlkYXlOYW1lXTtcbiAgICAgICAgZGF0ZUNsYXNzZXMuc2V0KGtleSwgY2xhc3NOYW1lc09iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGVDbGFzc2VzO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSB0aW1lcyB0byBpbmplY3QgYWZ0ZXIgYSBnaXZlbiBzdGFydCBvZiBkYXksIGN1cnJlbnQgdGltZSwgYW5kIG11bHRpcGxpZXIuXG4gKiBAcGFyYW0gc3RhcnRPZkRheSBUaGUgc3RhcnQgb2YgdGhlIGRheS5cbiAqIEBwYXJhbSBjdXJyZW50VGltZSBUaGUgY3VycmVudCB0aW1lLlxuICogQHBhcmFtIGN1cnJlbnRNdWx0aXBsaWVyIFRoZSBjdXJyZW50IG11bHRpcGxpZXIuXG4gKiBAcGFyYW0gaW50ZXJ2YWxzIFRoZSBpbnRlcnZhbHMuXG4gKiBAcGFyYW0gaW5qZWN0ZWRUaW1lcyBUaGUgdGltZXMgdG8gcG90ZW50aWFsbHkgaW5qZWN0LlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGltZXMgdG8gaW5qZWN0LlxuICovXG5mdW5jdGlvbiB0aW1lc1RvSW5qZWN0QWZ0ZXIoc3RhcnRPZkRheSwgY3VycmVudFRpbWUsIGN1cnJlbnRNdWx0aXBsaWVyLCBpbnRlcnZhbHMsIGluamVjdGVkVGltZXMpIHtcbiAgICB2YXIgbCA9IGluamVjdGVkVGltZXMubGVuZ3RoO1xuICAgIHZhciB0aW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmplY3RlZFRpbWUgPSBzdGFydE9mRGF5O1xuICAgICAgICB2YXIgaW5qZWN0ZWRUaW1lVmFsdWUgPSBpbmplY3RlZFRpbWVzW2ldO1xuICAgICAgICBpZiAoaW5qZWN0ZWRUaW1lVmFsdWUpIHtcbiAgICAgICAgICAgIGluamVjdGVkVGltZSA9IGFkZEhvdXJzKGluamVjdGVkVGltZSwgZ2V0SG91cnMoaW5qZWN0ZWRUaW1lVmFsdWUpKTtcbiAgICAgICAgICAgIGluamVjdGVkVGltZSA9IGFkZE1pbnV0ZXMoaW5qZWN0ZWRUaW1lLCBnZXRNaW51dGVzKGluamVjdGVkVGltZVZhbHVlKSk7XG4gICAgICAgICAgICBpbmplY3RlZFRpbWUgPSBhZGRTZWNvbmRzKGluamVjdGVkVGltZSwgZ2V0U2Vjb25kcyhpbmplY3RlZFRpbWVWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0VGltZSA9IGFkZE1pbnV0ZXMoc3RhcnRPZkRheSwgKGN1cnJlbnRNdWx0aXBsaWVyICsgMSkgKiBpbnRlcnZhbHMpO1xuICAgICAgICBpZiAoaXNBZnRlcihpbmplY3RlZFRpbWUsIGN1cnJlbnRUaW1lKSAmJlxuICAgICAgICAgICAgaXNCZWZvcmUoaW5qZWN0ZWRUaW1lLCBuZXh0VGltZSkgJiZcbiAgICAgICAgICAgIGluamVjdGVkVGltZVZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZXMucHVzaChpbmplY3RlZFRpbWVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzO1xufVxuLyoqXG4gKiBBZGRzIGEgbGVhZGluZyB6ZXJvIHRvIGEgbnVtYmVyIGlmIGl0J3MgbGVzcyB0aGFuIDEwLlxuICogQHBhcmFtIGkgVGhlIG51bWJlciB0byBhZGQgYSBsZWFkaW5nIHplcm8gdG8uXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIGFzIGEgc3RyaW5nLCB3aXRoIGEgbGVhZGluZyB6ZXJvIGlmIGl0IHdhcyBsZXNzIHRoYW4gMTAuXG4gKi9cbmZ1bmN0aW9uIGFkZFplcm8oaSkge1xuICAgIHJldHVybiBpIDwgMTAgPyBcIjBcIi5jb25jYXQoaSkgOiBcIlwiLmNvbmNhdChpKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgc3RhcnQgYW5kIGVuZCB5ZWFycyBmb3IgYSBwZXJpb2QuXG4gKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBnZXQgdGhlIHBlcmlvZCBmb3IuXG4gKiBAcGFyYW0geWVhckl0ZW1OdW1iZXIgVGhlIG51bWJlciBvZiB5ZWFycyBpbiB0aGUgcGVyaW9kLiBEZWZhdWx0cyB0byBERUZBVUxUX1lFQVJfSVRFTV9OVU1CRVIuXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgc3RhcnQgYW5kIGVuZCB5ZWFycyBmb3IgdGhlIHBlcmlvZC5cbiAqL1xuZnVuY3Rpb24gZ2V0WWVhcnNQZXJpb2QoZGF0ZSwgeWVhckl0ZW1OdW1iZXIpIHtcbiAgICBpZiAoeWVhckl0ZW1OdW1iZXIgPT09IHZvaWQgMCkgeyB5ZWFySXRlbU51bWJlciA9IERFRkFVTFRfWUVBUl9JVEVNX05VTUJFUjsgfVxuICAgIHZhciBlbmRQZXJpb2QgPSBNYXRoLmNlaWwoZ2V0WWVhcihkYXRlKSAvIHllYXJJdGVtTnVtYmVyKSAqIHllYXJJdGVtTnVtYmVyO1xuICAgIHZhciBzdGFydFBlcmlvZCA9IGVuZFBlcmlvZCAtICh5ZWFySXRlbU51bWJlciAtIDEpO1xuICAgIHJldHVybiB7IHN0YXJ0UGVyaW9kOiBzdGFydFBlcmlvZCwgZW5kUGVyaW9kOiBlbmRQZXJpb2QgfTtcbn1cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGhvdXJzIGluIGEgZGF5LlxuICogQHBhcmFtIGQgVGhlIGRhdGUgdG8gZ2V0IHRoZSBudW1iZXIgb2YgaG91cnMgZm9yLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBob3VycyBpbiB0aGUgZGF5LlxuICovXG5mdW5jdGlvbiBnZXRIb3Vyc0luRGF5KGQpIHtcbiAgICB2YXIgc3RhcnRPZkRheSA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgdmFyIHN0YXJ0T2ZUaGVOZXh0RGF5ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpLCAyNCk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKCtzdGFydE9mVGhlTmV4dERheSAtICtzdGFydE9mRGF5KSAvIDM2MDAwMDApO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgbWludXRlIGZvciB0aGUgZ2l2ZW4gZGF0ZVxuICpcbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gaXMgYSBEU1QgYW5kIHRpbWV6b25lLXNhZmUgYW5hbG9nIG9mIGBkYXRlLWZucy9zdGFydE9mTWludXRlYFxuICogZG8gbm90IG1ha2UgY2hhbmdlcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmdcbiAqXG4gKiBTZWUgY29tbWVudHMgb24gaHR0cHM6Ly9naXRodWIuY29tL0hhY2tlcjB4MDEvcmVhY3QtZGF0ZXBpY2tlci9wdWxsLzQyNDRcbiAqIGZvciBtb3JlIGRldGFpbHNcbiAqXG4gKiBAcGFyYW0gZCBkYXRlXG4gKiBAcmV0dXJucyBzdGFydCBvZiB0aGUgbWludXRlXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUoZCkge1xuICAgIHZhciBzZWNvbmRzID0gZC5nZXRTZWNvbmRzKCk7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgcmV0dXJuIHRvRGF0ZShkLmdldFRpbWUoKSAtIHNlY29uZHMgKiAxMDAwIC0gbWlsbGlzZWNvbmRzKTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgbWludXRlXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIERTVCBhbmQgdGltZXpvbmUtc2FmZSBhbmFsb2cgb2YgYGRhdGUtZm5zL2lzU2FtZU1pbnV0ZWBcbiAqXG4gKiBAcGFyYW0gZDFcbiAqIEBwYXJhbSBkMlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNTYW1lTWludXRlKGQxLCBkMikge1xuICAgIHJldHVybiBzdGFydE9mTWludXRlKGQxKS5nZXRUaW1lKCkgPT09IHN0YXJ0T2ZNaW51dGUoZDIpLmdldFRpbWUoKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIG5ldyBkYXRldGltZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBkYXRlIHdpdGggbWlkbmlnaHQgdGltZVxuICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZ2V0IHRoZSBtaWRuaWdodCB0aW1lIGZvclxuICogQHJldHVybnMgQSBuZXcgZGF0ZXRpbWUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5wdXQgZGF0ZSB3aXRoIG1pZG5pZ2h0IHRpbWVcbiAqL1xuZnVuY3Rpb24gZ2V0TWlkbmlnaHREYXRlKGRhdGUpIHtcbiAgICBpZiAoIWlzRGF0ZShkYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGVcIik7XG4gICAgfVxuICAgIHZhciBkYXRlV2l0aG91dFRpbWUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBkYXRlV2l0aG91dFRpbWUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGRhdGVXaXRob3V0VGltZTtcbn1cbi8qKlxuICogSXMgdGhlIGZpcnN0IGRhdGUgYmVmb3JlIHRoZSBzZWNvbmQgb25lP1xuICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYmVmb3JlIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSBkYXRlVG9Db21wYXJlIFRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMgVGhlIGZpcnN0IGRhdGUgaXMgYmVmb3JlIHRoZSBzZWNvbmQgZGF0ZVxuICpcbiAqIE5vdGU6XG4gKiAgVGhpcyBmdW5jdGlvbiBjb25zaWRlcnMgdGhlIG1pZC1uaWdodCBvZiB0aGUgZ2l2ZW4gZGF0ZXMgZm9yIGNvbXBhcmlzb24uXG4gKiAgSXQgZXZhbHVhdGVzIHdoZXRoZXIgZGF0ZSBpcyBiZWZvcmUgZGF0ZVRvQ29tcGFyZSBiYXNlZCBvbiB0aGVpciBtaWQtbmlnaHQgdGltZXN0YW1wcy5cbiAqL1xuZnVuY3Rpb24gaXNEYXRlQmVmb3JlKGRhdGUsIGRhdGVUb0NvbXBhcmUpIHtcbiAgICBpZiAoIWlzRGF0ZShkYXRlKSB8fCAhaXNEYXRlKGRhdGVUb0NvbXBhcmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSByZWNlaXZlZFwiKTtcbiAgICB9XG4gICAgdmFyIG1pZG5pZ2h0RGF0ZSA9IGdldE1pZG5pZ2h0RGF0ZShkYXRlKTtcbiAgICB2YXIgbWlkbmlnaHREYXRlVG9Db21wYXJlID0gZ2V0TWlkbmlnaHREYXRlKGRhdGVUb0NvbXBhcmUpO1xuICAgIHJldHVybiBpc0JlZm9yZShtaWRuaWdodERhdGUsIG1pZG5pZ2h0RGF0ZVRvQ29tcGFyZSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3BhY2Uga2V5IHdhcyBwcmVzc2VkIGRvd24uXG4gKlxuICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWJvYXJkIGV2ZW50LlxuICogQHJldHVybnMgLSBSZXR1cm5zIHRydWUgaWYgdGhlIHNwYWNlIGtleSB3YXMgcHJlc3NlZCBkb3duLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzU3BhY2VLZXlEb3duKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmtleSA9PT0gS2V5VHlwZS5TcGFjZTtcbn1cblxuLyoqXG4gKiBgSW5wdXRUaW1lYCBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgdGltZSBpbnB1dC5cbiAqXG4gKiBAY29tcG9uZW50XG4gKiBAZXhhbXBsZVxuICogPElucHV0VGltZSB0aW1lU3RyaW5nPVwiMTI6MDBcIiAvPlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIHRoZSBgSW5wdXRUaW1lYCBjb21wb25lbnQuXG4gKiBAcGFyYW0gcHJvcHMub25DaGFuZ2UgLSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBkYXRlIGNoYW5nZXMuXG4gKiBAcGFyYW0gcHJvcHMuZGF0ZSAtIFRoZSBpbml0aWFsIGRhdGUgdmFsdWUuXG4gKiBAcGFyYW0gcHJvcHMudGltZVN0cmluZyAtIFRoZSBpbml0aWFsIHRpbWUgc3RyaW5nIHZhbHVlLlxuICogQHBhcmFtIHByb3BzLnRpbWVJbnB1dExhYmVsIC0gVGhlIGxhYmVsIGZvciB0aGUgdGltZSBpbnB1dC5cbiAqIEBwYXJhbSBwcm9wcy5jdXN0b21UaW1lSW5wdXQgLSBBbiBvcHRpb25hbCBjdXN0b20gdGltZSBpbnB1dCBlbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIFRoZSBgSW5wdXRUaW1lYCBjb21wb25lbnQuXG4gKi9cbnZhciBJbnB1dFRpbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElucHV0VGltZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnB1dFRpbWUocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlucHV0UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLm9uVGltZUNoYW5nZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyB0aW1lOiB0aW1lIH0pO1xuICAgICAgICAgICAgdmFyIHByb3BEYXRlID0gX3RoaXMucHJvcHMuZGF0ZTtcbiAgICAgICAgICAgIHZhciBpc1Byb3BEYXRlVmFsaWQgPSBwcm9wRGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKCtwcm9wRGF0ZSk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGlzUHJvcERhdGVWYWxpZCA/IHByb3BEYXRlIDogbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aW1lID09PSBudWxsIHx8IHRpbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWUuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gdGltZS5zcGxpdChcIjpcIiksIGhvdXJzID0gX2NbMF0sIG1pbnV0ZXMgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICBkYXRlLnNldEhvdXJzKE51bWJlcihob3VycykpO1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcyhOdW1iZXIobWludXRlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclRpbWVJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gX3RoaXMuc3RhdGUudGltZTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXRlID0gX2EuZGF0ZSwgdGltZVN0cmluZyA9IF9hLnRpbWVTdHJpbmcsIGN1c3RvbVRpbWVJbnB1dCA9IF9hLmN1c3RvbVRpbWVJbnB1dDtcbiAgICAgICAgICAgIGlmIChjdXN0b21UaW1lSW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGN1c3RvbVRpbWVJbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IF90aGlzLm9uVGltZUNoYW5nZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgdHlwZTogXCJ0aW1lXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyLXRpbWVfX2lucHV0XCIsIHBsYWNlaG9sZGVyOiBcIlRpbWVcIiwgbmFtZTogXCJ0aW1lLWlucHV0XCIsIHJlZjogX3RoaXMuaW5wdXRSZWYsIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5pbnB1dFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9LCByZXF1aXJlZDogdHJ1ZSwgdmFsdWU6IHRpbWUsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25UaW1lQ2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSB8fCB0aW1lU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0aW1lOiBfdGhpcy5wcm9wcy50aW1lU3RyaW5nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElucHV0VGltZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIHN0YXRlKSB7XG4gICAgICAgIGlmIChwcm9wcy50aW1lU3RyaW5nICE9PSBzdGF0ZS50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHByb3BzLnRpbWVTdHJpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNoYW5nZSB0byBzdGF0ZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBJbnB1dFRpbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2lucHV0LXRpbWUtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlci10aW1lX19jYXB0aW9uXCIgfSwgdGhpcy5wcm9wcy50aW1lSW5wdXRMYWJlbCksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXItdGltZV9faW5wdXQtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXItdGltZV9faW5wdXRcIiB9LCB0aGlzLnJlbmRlclRpbWVJbnB1dCgpKSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnB1dFRpbWU7XG59KENvbXBvbmVudCkpO1xuXG4vKipcbiAqIGBEYXlgIGlzIGEgUmVhY3QgY29tcG9uZW50IHRoYXQgcmVwcmVzZW50cyBhIHNpbmdsZSBkYXkgaW4gYSBkYXRlIHBpY2tlci5cbiAqIEl0IGhhbmRsZXMgdGhlIHJlbmRlcmluZyBhbmQgaW50ZXJhY3Rpb24gb2YgYSBkYXkuXG4gKlxuICogQHByb3AgYXJpYUxhYmVsUHJlZml4V2hlbkVuYWJsZWQgLSBBcmlhIGxhYmVsIHByZWZpeCB3aGVuIHRoZSBkYXkgaXMgZW5hYmxlZC5cbiAqIEBwcm9wIGFyaWFMYWJlbFByZWZpeFdoZW5EaXNhYmxlZCAtIEFyaWEgbGFiZWwgcHJlZml4IHdoZW4gdGhlIGRheSBpcyBkaXNhYmxlZC5cbiAqIEBwcm9wIGRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uIC0gV2hldGhlciBrZXlib2FyZCBuYXZpZ2F0aW9uIGlzIGRpc2FibGVkLlxuICogQHByb3AgZGF5IC0gVGhlIGRheSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcHJvcCBkYXlDbGFzc05hbWUgLSBGdW5jdGlvbiB0byBjdXN0b21pemUgdGhlIENTUyBjbGFzcyBvZiB0aGUgZGF5LlxuICogQHByb3AgZW5kRGF0ZSAtIFRoZSBlbmQgZGF0ZSBpbiBhIHJhbmdlLlxuICogQHByb3AgaGlnaGxpZ2h0RGF0ZXMgLSBNYXAgb2YgZGF0ZXMgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gKiBAcHJvcCBob2xpZGF5cyAtIE1hcCBvZiBob2xpZGF5IGRhdGVzLlxuICogQHByb3AgaW5saW5lIC0gV2hldGhlciB0aGUgZGF0ZSBwaWNrZXIgaXMgaW5saW5lLlxuICogQHByb3Agc2hvdWxkRm9jdXNEYXlJbmxpbmUgLSBXaGV0aGVyIHRoZSBkYXkgc2hvdWxkIGJlIGZvY3VzZWQgd2hlbiBkYXRlIHBpY2tlciBpcyBpbmxpbmUuXG4gKiBAcHJvcCBtb250aCAtIFRoZSBtb250aCB0aGUgZGF5IGJlbG9uZ3MgdG8uXG4gKiBAcHJvcCBvbkNsaWNrIC0gQ2xpY2sgZXZlbnQgaGFuZGxlci5cbiAqIEBwcm9wIG9uTW91c2VFbnRlciAtIE1vdXNlIGVudGVyIGV2ZW50IGhhbmRsZXIuXG4gKiBAcHJvcCBoYW5kbGVPbktleURvd24gLSBLZXkgZG93biBldmVudCBoYW5kbGVyLlxuICogQHByb3AgdXNlUG9pbnRlckV2ZW50IC0gV2hldGhlciB0byB1c2UgcG9pbnRlciBldmVudHMuXG4gKiBAcHJvcCBwcmVTZWxlY3Rpb24gLSBUaGUgZGF0ZSB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAqIEBwcm9wIHNlbGVjdGVkIC0gVGhlIHNlbGVjdGVkIGRhdGUuXG4gKiBAcHJvcCBzZWxlY3RpbmdEYXRlIC0gVGhlIGRhdGUgY3VycmVudGx5IGJlaW5nIHNlbGVjdGVkLlxuICogQHByb3Agc2VsZWN0c0VuZCAtIFdoZXRoZXIgdGhlIGRheSBjYW4gYmUgdGhlIGVuZCBkYXRlIGluIGEgcmFuZ2UuXG4gKiBAcHJvcCBzZWxlY3RzU3RhcnQgLSBXaGV0aGVyIHRoZSBkYXkgY2FuIGJlIHRoZSBzdGFydCBkYXRlIGluIGEgcmFuZ2UuXG4gKiBAcHJvcCBzZWxlY3RzUmFuZ2UgLSBXaGV0aGVyIHRoZSBkYXkgY2FuIGJlIGluIGEgcmFuZ2UuXG4gKiBAcHJvcCBzaG93V2Vla1BpY2tlciAtIFdoZXRoZXIgdG8gc2hvdyB3ZWVrIHBpY2tlci5cbiAqIEBwcm9wIHNob3dXZWVrTnVtYmVyIC0gV2hldGhlciB0byBzaG93IHdlZWsgbnVtYmVycy5cbiAqIEBwcm9wIHNlbGVjdHNEaXNhYmxlZERheXNJblJhbmdlIC0gV2hldGhlciB0byBzZWxlY3QgZGlzYWJsZWQgZGF5cyBpbiBhIHJhbmdlLlxuICogQHByb3Agc2VsZWN0c011bHRpcGxlIC0gV2hldGhlciB0byBhbGxvdyBtdWx0aXBsZSBkYXRlIHNlbGVjdGlvbi5cbiAqIEBwcm9wIHNlbGVjdGVkRGF0ZXMgLSBBcnJheSBvZiBzZWxlY3RlZCBkYXRlcy5cbiAqIEBwcm9wIHN0YXJ0RGF0ZSAtIFRoZSBzdGFydCBkYXRlIGluIGEgcmFuZ2UuXG4gKiBAcHJvcCByZW5kZXJEYXlDb250ZW50cyAtIEZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIG9mIHRoZSBkYXkncyBjb250ZW50cy5cbiAqIEBwcm9wIGNvbnRhaW5lclJlZiAtIFJlZiBmb3IgdGhlIGNvbnRhaW5lci5cbiAqIEBwcm9wIGV4Y2x1ZGVEYXRlcyAtIEFycmF5IG9mIGRhdGVzIHRvIGJlIGV4Y2x1ZGVkLlxuICogQHByb3AgY2FsZW5kYXJTdGFydERheSAtIFRoZSBzdGFydCBkYXkgb2YgdGhlIHdlZWsuXG4gKiBAcHJvcCBsb2NhbGUgLSBUaGUgbG9jYWxlIG9iamVjdC5cbiAqIEBwcm9wIG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzRW5kIC0gV2hldGhlciB0byBzaG93IGR1cGxpY2F0ZSBkYXlzIGF0IHRoZSBlbmQgb2YgdGhlIG1vbnRoLlxuICogQHByb3AgbW9udGhTaG93c0R1cGxpY2F0ZURheXNTdGFydCAtIFdoZXRoZXIgdG8gc2hvdyBkdXBsaWNhdGUgZGF5cyBhdCB0aGUgc3RhcnQgb2YgdGhlIG1vbnRoLlxuICogQHByb3AgaW5jbHVkZURhdGVzIC0gQXJyYXkgb2YgZGF0ZXMgdG8gYmUgaW5jbHVkZWQuXG4gKiBAcHJvcCBpbmNsdWRlRGF0ZUludGVydmFscyAtIEFycmF5IG9mIGRhdGUgaW50ZXJ2YWxzIHRvIGJlIGluY2x1ZGVkLlxuICogQHByb3AgbWluRGF0ZSAtIFRoZSBtaW5pbXVtIGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWQuXG4gKiBAcHJvcCBtYXhEYXRlIC0gVGhlIG1heGltdW0gZGF0ZSB0aGF0IGNhbiBiZSBzZWxlY3RlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IERheSBmcm9tICcuL2RheSc7XG4gKlxuICogZnVuY3Rpb24gTXlDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IGhhbmRsZURheUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ0RheSBjbGlja2VkJywgZXZlbnQpO1xuICogICB9O1xuICpcbiAqICAgY29uc3QgaGFuZGxlRGF5TW91c2VFbnRlciA9IChldmVudCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdNb3VzZSBlbnRlcmVkIGRheScsIGV2ZW50KTtcbiAqICAgfTtcbiAqXG4gKiAgIGNvbnN0IHJlbmRlckRheUNvbnRlbnRzID0gKGRhdGUpID0+IHtcbiAqICAgICByZXR1cm4gPGRpdj57ZGF0ZS5nZXREYXRlKCl9PC9kaXY+O1xuICogICB9O1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8RGF5XG4gKiAgICAgICBkYXk9e25ldyBEYXRlKCl9XG4gKiAgICAgICBvbkNsaWNrPXtoYW5kbGVEYXlDbGlja31cbiAqICAgICAgIG9uTW91c2VFbnRlcj17aGFuZGxlRGF5TW91c2VFbnRlcn1cbiAqICAgICAgIHJlbmRlckRheUNvbnRlbnRzPXtyZW5kZXJEYXlDb250ZW50c31cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICpcbiAqIGV4cG9ydCBkZWZhdWx0IE15Q29tcG9uZW50O1xuICogYGBgXG4gKi9cbnZhciBEYXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERheSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXlFbCA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0Rpc2FibGVkKCkgJiYgX3RoaXMucHJvcHMub25DbGljaykge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVNb3VzZUVudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzRGlzYWJsZWQoKSAmJiBfdGhpcy5wcm9wcy5vbk1vdXNlRW50ZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbk1vdXNlRW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVPbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgZXZlbnRLZXkgPSBldmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LmtleSA9IEtleVR5cGUuRW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykuaGFuZGxlT25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NhbWVEYXkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoX3RoaXMucHJvcHMuZGF5LCBvdGhlcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzS2V5Ym9hcmRTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc1NlbGVjdGVkRGF0ZSA9IF90aGlzLnByb3BzLnNlbGVjdHNNdWx0aXBsZVxuICAgICAgICAgICAgICAgID8gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0ZWREYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIF90aGlzLmlzU2FtZURheU9yV2VlayhkYXRlKTsgfSlcbiAgICAgICAgICAgICAgICA6IF90aGlzLmlzU2FtZURheU9yV2VlayhfdGhpcy5wcm9wcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiAmJiBfdGhpcy5pc0Rpc2FibGVkKF90aGlzLnByb3BzLnByZVNlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gKCFpc1NlbGVjdGVkRGF0ZSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLmlzU2FtZURheU9yV2VlayhfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgIWlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgaWYgKGRheSA9PT0gdm9pZCAwKSB7IGRheSA9IF90aGlzLnByb3BzLmRheTsgfVxuICAgICAgICAgICAgLy8gQWxtb3N0IGFsbCBwcm9wcyBwcmV2aW91c2x5IHdlcmUgcGFzc2VkIGFzIHRoaXMucHJvcHMgdy9vIHByb3BlciB0eXBpbmcgd2l0aCBwcm9wLXR5cGVzXG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgbWlncmF0aW9uIHRvIFRTIGkgbWFkZSBpdCBleHBsaWNpdFxuICAgICAgICAgICAgcmV0dXJuIGlzRGF5RGlzYWJsZWQoZGF5LCB7XG4gICAgICAgICAgICAgICAgbWluRGF0ZTogX3RoaXMucHJvcHMubWluRGF0ZSxcbiAgICAgICAgICAgICAgICBtYXhEYXRlOiBfdGhpcy5wcm9wcy5tYXhEYXRlLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVEYXRlczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVzLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZUludGVydmFscyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlRGF0ZUludGVydmFsczogX3RoaXMucHJvcHMuaW5jbHVkZURhdGVJbnRlcnZhbHMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5pbmNsdWRlRGF0ZXMsXG4gICAgICAgICAgICAgICAgZmlsdGVyRGF0ZTogX3RoaXMucHJvcHMuZmlsdGVyRGF0ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogX3RoaXMucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNFeGNsdWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEFsbW9zdCBhbGwgcHJvcHMgcHJldmlvdXNseSB3ZXJlIHBhc3NlZCBhcyB0aGlzLnByb3BzIHcvbyBwcm9wZXIgdHlwaW5nIHdpdGggcHJvcC10eXBlc1xuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIG1pZ3JhdGlvbiB0byBUUyBpIG1hZGUgaXQgZXhwbGljaXRcbiAgICAgICAgICAgIHJldHVybiBpc0RheUV4Y2x1ZGVkKF90aGlzLnByb3BzLmRheSwge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVEYXRlczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVzLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZUludGVydmFscyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1N0YXJ0T2ZXZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShfdGhpcy5wcm9wcy5kYXksIGdldFN0YXJ0T2ZXZWVrKF90aGlzLnByb3BzLmRheSwgX3RoaXMucHJvcHMubG9jYWxlLCBfdGhpcy5wcm9wcy5jYWxlbmRhclN0YXJ0RGF5KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2FtZVdlZWsgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5zaG93V2Vla1BpY2tlciAmJlxuICAgICAgICAgICAgICAgIGlzU2FtZURheShvdGhlciwgZ2V0U3RhcnRPZldlZWsoX3RoaXMucHJvcHMuZGF5LCBfdGhpcy5wcm9wcy5sb2NhbGUsIF90aGlzLnByb3BzLmNhbGVuZGFyU3RhcnREYXkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTYW1lRGF5T3JXZWVrID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNTYW1lRGF5KG90aGVyKSB8fCBfdGhpcy5pc1NhbWVXZWVrKG90aGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0SGlnaExpZ2h0ZWRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIGhpZ2hsaWdodERhdGVzID0gX2EuaGlnaGxpZ2h0RGF0ZXM7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodERhdGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9va2luZyBmb3IgY2xhc3NOYW1lIGluIHRoZSBNYXAgb2YgeydkYXkgc3RyaW5nLCAnY2xhc3NOYW1lJ31cbiAgICAgICAgICAgIHZhciBkYXlTdHIgPSBmb3JtYXREYXRlKGRheSwgXCJNTS5kZC55eXl5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodERhdGVzLmdldChkYXlTdHIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBGdW5jdGlvbiB0byByZXR1cm4gdGhlIGFycmF5IGNvbnRhaW5pbmcgY2xhc3NOYW1lIGFzc29jaWF0ZWQgdG8gdGhlIGRhdGVcbiAgICAgICAgX3RoaXMuZ2V0SG9saWRheXNDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBkYXkgPSBfYi5kYXksIGhvbGlkYXlzID0gX2IuaG9saWRheXM7XG4gICAgICAgICAgICBpZiAoIWhvbGlkYXlzKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHR5cGUgY29uc2lzdGVuY3kgbm8gb3RoZXIgcmVhc29uc1xuICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXlTdHIgPSBmb3JtYXREYXRlKGRheSwgXCJNTS5kZC55eXl5XCIpO1xuICAgICAgICAgICAgLy8gTG9va2luZyBmb3IgY2xhc3NOYW1lIGluIHRoZSBNYXAgb2Yge2RheSBzdHJpbmc6IHtjbGFzc05hbWUsIGhvbGlkYXlOYW1lfX1cbiAgICAgICAgICAgIGlmIChob2xpZGF5cy5oYXMoZGF5U3RyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbKF9hID0gaG9saWRheXMuZ2V0KGRheVN0cikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc05hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIHR5cGUgY29uc2lzdGVuY3kgbm8gb3RoZXIgcmVhc29uc1xuICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0luUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBzdGFydERhdGUgPSBfYS5zdGFydERhdGUsIGVuZERhdGUgPSBfYS5lbmREYXRlO1xuICAgICAgICAgICAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNEYXlJblJhbmdlKGRheSwgc3RhcnREYXRlLCBlbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGRheSA9IF9iLmRheSwgc2VsZWN0c1N0YXJ0ID0gX2Iuc2VsZWN0c1N0YXJ0LCBzZWxlY3RzRW5kID0gX2Iuc2VsZWN0c0VuZCwgc2VsZWN0c1JhbmdlID0gX2Iuc2VsZWN0c1JhbmdlLCBzZWxlY3RzRGlzYWJsZWREYXlzSW5SYW5nZSA9IF9iLnNlbGVjdHNEaXNhYmxlZERheXNJblJhbmdlLCBzdGFydERhdGUgPSBfYi5zdGFydERhdGUsIHN3YXBSYW5nZSA9IF9iLnN3YXBSYW5nZSwgZW5kRGF0ZSA9IF9iLmVuZERhdGU7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW5nRGF0ZSA9IChfYSA9IF90aGlzLnByb3BzLnNlbGVjdGluZ0RhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIC8vIERvbid0IGhpZ2hsaWdodCBkYXlzIG91dHNpZGUgdGhlIGN1cnJlbnQgbW9udGhcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0FmdGVyTW9udGgoKSB8fCBfdGhpcy5pc0JlZm9yZU1vbnRoKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShzZWxlY3RzU3RhcnQgfHwgc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHx8XG4gICAgICAgICAgICAgICAgIXNlbGVjdGluZ0RhdGUgfHxcbiAgICAgICAgICAgICAgICAoIXNlbGVjdHNEaXNhYmxlZERheXNJblJhbmdlICYmIF90aGlzLmlzRGlzYWJsZWQoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1N0YXJ0ICYmXG4gICAgICAgICAgICAgICAgZW5kRGF0ZSAmJlxuICAgICAgICAgICAgICAgIChpc0JlZm9yZShzZWxlY3RpbmdEYXRlLCBlbmREYXRlKSB8fCBpc0VxdWFsKHNlbGVjdGluZ0RhdGUsIGVuZERhdGUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RheUluUmFuZ2UoZGF5LCBzZWxlY3RpbmdEYXRlLCBlbmREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RzRW5kICYmXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlICYmXG4gICAgICAgICAgICAgICAgKGlzQWZ0ZXIoc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKSB8fCBpc0VxdWFsKHNlbGVjdGluZ0RhdGUsIHN0YXJ0RGF0ZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlICYmIHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKHNlbGVjdGluZ0RhdGUsIHN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0FmdGVyKHNlbGVjdGluZ0RhdGUsIHN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzd2FwUmFuZ2UgJiYgaXNCZWZvcmUoc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNEYXlJblJhbmdlKGRheSwgc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2VsZWN0aW5nUmFuZ2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBzdGFydERhdGUgPSBfYi5zdGFydERhdGUsIHNlbGVjdHNTdGFydCA9IF9iLnNlbGVjdHNTdGFydCwgc3dhcFJhbmdlID0gX2Iuc3dhcFJhbmdlLCBzZWxlY3RzUmFuZ2UgPSBfYi5zZWxlY3RzUmFuZ2U7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW5nRGF0ZSA9IChfYSA9IF90aGlzLnByb3BzLnNlbGVjdGluZ0RhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlICYmIHN3YXBSYW5nZSAmJiBzdGFydERhdGUgJiYgc2VsZWN0aW5nRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBpc0JlZm9yZShzZWxlY3RpbmdEYXRlLCBzdGFydERhdGUpID8gc2VsZWN0aW5nRGF0ZSA6IHN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgc3RhcnREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RpbmdSYW5nZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBlbmREYXRlID0gX2IuZW5kRGF0ZSwgc2VsZWN0c0VuZCA9IF9iLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZSwgc3dhcFJhbmdlID0gX2Iuc3dhcFJhbmdlLCBzdGFydERhdGUgPSBfYi5zdGFydERhdGU7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW5nRGF0ZSA9IChfYSA9IF90aGlzLnByb3BzLnNlbGVjdGluZ0RhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RzRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIHNlbGVjdGluZ0RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSAmJiBzd2FwUmFuZ2UgJiYgc3RhcnREYXRlICYmIHNlbGVjdGluZ0RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgaXNCZWZvcmUoc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKSA/IHN0YXJ0RGF0ZSA6IHNlbGVjdGluZ0RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBzZWxlY3RpbmdEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBlbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNSYW5nZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRheSA9IF9hLmRheSwgc3RhcnREYXRlID0gX2Euc3RhcnREYXRlLCBlbmREYXRlID0gX2EuZW5kRGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShzdGFydERhdGUsIGRheSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzUmFuZ2VFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBzdGFydERhdGUgPSBfYS5zdGFydERhdGUsIGVuZERhdGUgPSBfYS5lbmREYXRlO1xuICAgICAgICAgICAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGVuZERhdGUsIGRheSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzV2Vla2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gZ2V0RGF5KF90aGlzLnByb3BzLmRheSk7XG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheSA9PT0gMCB8fCB3ZWVrZGF5ID09PSA2O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0FmdGVyTW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLnByb3BzLm1vbnRoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAoX3RoaXMucHJvcHMubW9udGggKyAxKSAlIDEyID09PSBnZXRNb250aChfdGhpcy5wcm9wcy5kYXkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNCZWZvcmVNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMucHJvcHMubW9udGggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIChnZXRNb250aChfdGhpcy5wcm9wcy5kYXkpICsgMSkgJSAxMiA9PT0gX3RoaXMucHJvcHMubW9udGgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0N1cnJlbnREYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pc1NhbWVEYXkobmV3RGF0ZSgpKTsgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0ZWREYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzU2FtZURheU9yV2VlayhkYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc1NhbWVEYXlPcldlZWsoX3RoaXMucHJvcHMuc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRDbGFzc05hbWVzID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBkYXlDbGFzc05hbWUgPSBfdGhpcy5wcm9wcy5kYXlDbGFzc05hbWVcbiAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLmRheUNsYXNzTmFtZShkYXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGNsc3goXCJyZWFjdC1kYXRlcGlja2VyX19kYXlcIiwgZGF5Q2xhc3NOYW1lLCBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tXCIgKyBnZXREYXlPZldlZWtDb2RlKF90aGlzLnByb3BzLmRheSksIHtcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tZGlzYWJsZWRcIjogX3RoaXMuaXNEaXNhYmxlZCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1leGNsdWRlZFwiOiBfdGhpcy5pc0V4Y2x1ZGVkKCksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXNlbGVjdGVkXCI6IF90aGlzLmlzU2VsZWN0ZWQoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0ta2V5Ym9hcmQtc2VsZWN0ZWRcIjogX3RoaXMuaXNLZXlib2FyZFNlbGVjdGVkKCksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzUmFuZ2VTdGFydCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1yYW5nZS1lbmRcIjogX3RoaXMuaXNSYW5nZUVuZCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1pbi1yYW5nZVwiOiBfdGhpcy5pc0luUmFuZ2UoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0taW4tc2VsZWN0aW5nLXJhbmdlXCI6IF90aGlzLmlzSW5TZWxlY3RpbmdSYW5nZSgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1zZWxlY3RpbmctcmFuZ2Utc3RhcnRcIjogX3RoaXMuaXNTZWxlY3RpbmdSYW5nZVN0YXJ0KCksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXNlbGVjdGluZy1yYW5nZS1lbmRcIjogX3RoaXMuaXNTZWxlY3RpbmdSYW5nZUVuZCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS10b2RheVwiOiBfdGhpcy5pc0N1cnJlbnREYXkoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0td2Vla2VuZFwiOiBfdGhpcy5pc1dlZWtlbmQoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tb3V0c2lkZS1tb250aFwiOiBfdGhpcy5pc0FmdGVyTW9udGgoKSB8fCBfdGhpcy5pc0JlZm9yZU1vbnRoKCksXG4gICAgICAgICAgICB9LCBfdGhpcy5nZXRIaWdoTGlnaHRlZENsYXNzKCksIF90aGlzLmdldEhvbGlkYXlzQ2xhc3MoKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldEFyaWFMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIF9iID0gX2EuYXJpYUxhYmVsUHJlZml4V2hlbkVuYWJsZWQsIGFyaWFMYWJlbFByZWZpeFdoZW5FbmFibGVkID0gX2IgPT09IHZvaWQgMCA/IFwiQ2hvb3NlXCIgOiBfYiwgX2MgPSBfYS5hcmlhTGFiZWxQcmVmaXhXaGVuRGlzYWJsZWQsIGFyaWFMYWJlbFByZWZpeFdoZW5EaXNhYmxlZCA9IF9jID09PSB2b2lkIDAgPyBcIk5vdCBhdmFpbGFibGVcIiA6IF9jO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IF90aGlzLmlzRGlzYWJsZWQoKSB8fCBfdGhpcy5pc0V4Y2x1ZGVkKClcbiAgICAgICAgICAgICAgICA/IGFyaWFMYWJlbFByZWZpeFdoZW5EaXNhYmxlZFxuICAgICAgICAgICAgICAgIDogYXJpYUxhYmVsUHJlZml4V2hlbkVuYWJsZWQ7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIikuY29uY2F0KGZvcm1hdERhdGUoZGF5LCBcIlBQUFBcIiwgX3RoaXMucHJvcHMubG9jYWxlKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBob2xpZGF5J3MgbmFtZSBhcyB0aXRsZSdzIGNvbnRlbnRcbiAgICAgICAgX3RoaXMuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBfYiA9IF9hLmhvbGlkYXlzLCBob2xpZGF5cyA9IF9iID09PSB2b2lkIDAgPyBuZXcgTWFwKCkgOiBfYiwgZXhjbHVkZURhdGVzID0gX2EuZXhjbHVkZURhdGVzO1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVEdCA9IGZvcm1hdERhdGUoZGF5LCBcIk1NLmRkLnl5eXlcIik7XG4gICAgICAgICAgICB2YXIgdGl0bGVzID0gW107XG4gICAgICAgICAgICBpZiAoaG9saWRheXMuaGFzKGNvbXBhcmVEdCkpIHtcbiAgICAgICAgICAgICAgICB0aXRsZXMucHVzaC5hcHBseSh0aXRsZXMsIGhvbGlkYXlzLmdldChjb21wYXJlRHQpLmhvbGlkYXlOYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNFeGNsdWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGVzLnB1c2goZXhjbHVkZURhdGVzID09PSBudWxsIHx8IGV4Y2x1ZGVEYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhjbHVkZURhdGVzLmZpbHRlcihmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShleGNsdWRlRGF0ZSwgZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGV4Y2x1ZGVEYXRlID09PSBudWxsIHx8IGV4Y2x1ZGVEYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGNsdWRlRGF0ZS5kYXRlLCBkYXkpO1xuICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZURhdGUgPT09IG51bGwgfHwgZXhjbHVkZURhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4Y2x1ZGVEYXRlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSSdtIG5vdCBzdXJlIHRoYXQgdGhpcyBpcyBhIHJpZ2h0IG91dHB1dCwgYnV0IGFsbCB0ZXN0cyBhcmUgZ3JlZW5cbiAgICAgICAgICAgIHJldHVybiB0aXRsZXMuam9pbihcIiwgXCIpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRUYWJJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZERheSA9IF90aGlzLnByb3BzLnNlbGVjdGVkO1xuICAgICAgICAgICAgdmFyIHByZVNlbGVjdGlvbkRheSA9IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciB0YWJJbmRleCA9ICEoX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIgJiZcbiAgICAgICAgICAgICAgICAoX3RoaXMucHJvcHMuc2hvd1dlZWtOdW1iZXIgfHwgIV90aGlzLmlzU3RhcnRPZldlZWsoKSkpICYmXG4gICAgICAgICAgICAgICAgKF90aGlzLmlzS2V5Ym9hcmRTZWxlY3RlZCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIChfdGhpcy5pc1NhbWVEYXkoc2VsZWN0ZWREYXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVEYXkocHJlU2VsZWN0aW9uRGF5LCBzZWxlY3RlZERheSkpKVxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgICByZXR1cm4gdGFiSW5kZXg7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHZhcmlvdXMgY2FzZXMgd2hlbiB3ZSBuZWVkIHRvIGFwcGx5IGZvY3VzIHRvIHRoZSBwcmVzZWxlY3RlZCBkYXlcbiAgICAgICAgLy8gZm9jdXMgdGhlIGRheSBvbiBtb3VudC91cGRhdGUgc28gdGhhdCBrZXlib2FyZCBuYXZpZ2F0aW9uIHdvcmtzIHdoaWxlIGN5Y2xpbmcgdGhyb3VnaCBtb250aHMgd2l0aCB1cCBvciBkb3duIGtleXMgKG5vdCBmb3IgcHJldiBhbmQgbmV4dCBtb250aCBidXR0b25zKVxuICAgICAgICAvLyBwcmV2ZW50IGZvY3VzIGZvciB0aGVzZSBhY3RpdmVFbGVtZW50IGNhc2VzIHNvIHdlIGRvbid0IHB1bGwgZm9jdXMgZnJvbSB0aGUgaW5wdXQgYXMgdGhlIGNhbGVuZGFyIG9wZW5zXG4gICAgICAgIF90aGlzLmhhbmRsZUZvY3VzRGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIHdoaWxlIHRoZSBpbnB1dCBpc24ndCBmb2N1c2VkXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHR5cGluZy9iYWNrc3BhY2luZyB0aGUgZGF0ZSBtYW51YWxseSBtYXkgc3RlYWwgZm9jdXMgYXdheSBmcm9tIHRoZSBpbnB1dFxuICAgICAgICAgICAgX3RoaXMuc2hvdWxkRm9jdXNEYXkoKSAmJiAoKF9hID0gX3RoaXMuZGF5RWwuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckRheUNvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzRW5kICYmIF90aGlzLmlzQWZ0ZXJNb250aCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgJiYgX3RoaXMuaXNCZWZvcmVNb250aCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnJlbmRlckRheUNvbnRlbnRzXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5wcm9wcy5yZW5kZXJEYXlDb250ZW50cyhnZXREYXRlKF90aGlzLnByb3BzLmRheSksIF90aGlzLnByb3BzLmRheSlcbiAgICAgICAgICAgICAgICA6IGdldERhdGUoX3RoaXMucHJvcHMuZGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFxuICAgICAgICAvLyBUT0RPOiBVc2UgPG9wdGlvbj4gaW5zdGVhZCBvZiB0aGUgXCJvcHRpb25cIiByb2xlIHRvIGVuc3VyZSBhY2Nlc3NpYmlsaXR5IGFjcm9zcyBhbGwgZGV2aWNlcy5cbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogX3RoaXMuZGF5RWwsIGNsYXNzTmFtZTogX3RoaXMuZ2V0Q2xhc3NOYW1lcyhfdGhpcy5wcm9wcy5kYXkpLCBvbktleURvd246IF90aGlzLmhhbmRsZU9uS2V5RG93biwgb25DbGljazogX3RoaXMuaGFuZGxlQ2xpY2ssIG9uTW91c2VFbnRlcjogIV90aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudCA/IF90aGlzLmhhbmRsZU1vdXNlRW50ZXIgOiB1bmRlZmluZWQsIG9uUG9pbnRlckVudGVyOiBfdGhpcy5wcm9wcy51c2VQb2ludGVyRXZlbnQgPyBfdGhpcy5oYW5kbGVNb3VzZUVudGVyIDogdW5kZWZpbmVkLCB0YWJJbmRleDogX3RoaXMuZ2V0VGFiSW5kZXgoKSwgXCJhcmlhLWxhYmVsXCI6IF90aGlzLmdldEFyaWFMYWJlbCgpLCByb2xlOiBcImdyaWRjZWxsXCIsIHRpdGxlOiBfdGhpcy5nZXRUaXRsZSgpLCBcImFyaWEtZGlzYWJsZWRcIjogX3RoaXMuaXNEaXNhYmxlZCgpLCBcImFyaWEtY3VycmVudFwiOiBfdGhpcy5pc0N1cnJlbnREYXkoKSA/IFwiZGF0ZVwiIDogdW5kZWZpbmVkLCBcImFyaWEtc2VsZWN0ZWRcIjogX3RoaXMuaXNTZWxlY3RlZCgpIHx8IF90aGlzLmlzSW5SYW5nZSgpIH0sXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXlDb250ZW50cygpLFxuICAgICAgICAgICAgX3RoaXMuZ2V0VGl0bGUoKSAhPT0gXCJcIiAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwib3ZlcmxheVwiIH0sIF90aGlzLmdldFRpdGxlKCkpKSkpOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRm9jdXNEYXkoKTtcbiAgICB9O1xuICAgIERheS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzRGF5KCk7XG4gICAgfTtcbiAgICBEYXkucHJvdG90eXBlLnNob3VsZEZvY3VzRGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2hvdWxkRm9jdXNEYXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGFiSW5kZXgoKSA9PT0gMCAmJiB0aGlzLmlzU2FtZURheSh0aGlzLnByb3BzLnByZVNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGN1cnJlbnRseSBubyBhY3RpdmVFbGVtZW50IGFuZCBub3QgaW5saW5lXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlubGluZSB2ZXJzaW9uOlxuICAgICAgICAgICAgLy8gZG8gbm90IGZvY3VzIG9uIGluaXRpYWwgcmVuZGVyIHRvIHByZXZlbnQgYXV0b0ZvY3VzIGlzc3VlXG4gICAgICAgICAgICAvLyBmb2N1cyBhZnRlciBtb250aCBoYXMgY2hhbmdlZCB2aWEga2V5Ym9hcmRcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmlubGluZSAmJiAhdGhpcy5wcm9wcy5zaG91bGRGb2N1c0RheUlubGluZSkge1xuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RheUFjdGl2ZUVsZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHVwbGljYXRlRGF5KCkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRGb2N1c0RheSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaG91bGRGb2N1c0RheTtcbiAgICB9O1xuICAgIC8vIHRoZSBhY3RpdmVFbGVtZW50IGlzIGluIHRoZSBjb250YWluZXIsIGFuZCBpdCBpcyBhbm90aGVyIGluc3RhbmNlIG9mIERheVxuICAgIERheS5wcm90b3R5cGUuaXNEYXlBY3RpdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICgoKF9iID0gKF9hID0gdGhpcy5wcm9wcy5jb250YWluZXJSZWYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpICYmXG4gICAgICAgICAgICAoKF9jID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNsYXNzTGlzdC5jb250YWlucyhcInJlYWN0LWRhdGVwaWNrZXJfX2RheVwiKSkpO1xuICAgIH07XG4gICAgRGF5LnByb3RvdHlwZS5pc0R1cGxpY2F0ZURheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgLy9kYXkgaXMgb25lIG9mIHRoZSBub24gcmVuZGVyZWQgZHVwbGljYXRlIGRheXNcbiAgICAgICAgKHRoaXMucHJvcHMubW9udGhTaG93c0R1cGxpY2F0ZURheXNFbmQgJiYgdGhpcy5pc0FmdGVyTW9udGgoKSkgfHxcbiAgICAgICAgICAgICh0aGlzLnByb3BzLm1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgJiYgdGhpcy5pc0JlZm9yZU1vbnRoKCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXk7XG59KENvbXBvbmVudCkpO1xuXG52YXIgV2Vla051bWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2Vla051bWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWVrTnVtYmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMud2Vla051bWJlckVsID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25DbGljaykge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVPbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgZXZlbnRLZXkgPSBldmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LmtleSA9IEtleVR5cGUuRW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykuaGFuZGxlT25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIV90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzU2FtZURheShfdGhpcy5wcm9wcy5kYXRlLCBfdGhpcy5wcm9wcy5zZWxlY3RlZCkgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkoX3RoaXMucHJvcHMuZGF0ZSwgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93V2Vla051bWJlciAmJlxuICAgICAgICAgICAgICAgIChfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQoKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNTYW1lRGF5KF90aGlzLnByb3BzLmRhdGUsIF90aGlzLnByb3BzLnNlbGVjdGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lRGF5KF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiwgX3RoaXMucHJvcHMuc2VsZWN0ZWQpKSlcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICB9O1xuICAgICAgICAvLyB2YXJpb3VzIGNhc2VzIHdoZW4gd2UgbmVlZCB0byBhcHBseSBmb2N1cyB0byB0aGUgcHJlc2VsZWN0ZWQgd2Vlay1udW1iZXJcbiAgICAgICAgLy8gZm9jdXMgdGhlIHdlZWstbnVtYmVyIG9uIG1vdW50L3VwZGF0ZSBzbyB0aGF0IGtleWJvYXJkIG5hdmlnYXRpb24gd29ya3Mgd2hpbGUgY3ljbGluZyB0aHJvdWdoIG1vbnRocyB3aXRoIHVwIG9yIGRvd24ga2V5cyAobm90IGZvciBwcmV2IGFuZCBuZXh0IG1vbnRoIGJ1dHRvbnMpXG4gICAgICAgIC8vIHByZXZlbnQgZm9jdXMgZm9yIHRoZXNlIGFjdGl2ZUVsZW1lbnQgY2FzZXMgc28gd2UgZG9uJ3QgcHVsbCBmb2N1cyBmcm9tIHRoZSBpbnB1dCBhcyB0aGUgY2FsZW5kYXIgb3BlbnNcbiAgICAgICAgX3RoaXMuaGFuZGxlRm9jdXNXZWVrTnVtYmVyID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICAgICAgdmFyIHNob3VsZEZvY3VzV2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIHdoaWxlIHRoZSBpbnB1dCBpc24ndCBmb2N1c2VkXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHR5cGluZy9iYWNrc3BhY2luZyB0aGUgZGF0ZSBtYW51YWxseSBtYXkgc3RlYWwgZm9jdXMgYXdheSBmcm9tIHRoZSBpbnB1dFxuICAgICAgICAgICAgaWYgKF90aGlzLmdldFRhYkluZGV4KCkgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAhKHByZXZQcm9wcyA9PT0gbnVsbCB8fCBwcmV2UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZQcm9wcy5pc0lucHV0Rm9jdXNlZCkgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkoX3RoaXMucHJvcHMuZGF0ZSwgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGN1cnJlbnRseSBubyBhY3RpdmVFbGVtZW50IGFuZCBub3QgaW5saW5lXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkRm9jdXNXZWVrTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW5saW5lIHZlcnNpb246XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGZvY3VzIG9uIGluaXRpYWwgcmVuZGVyIHRvIHByZXZlbnQgYXV0b0ZvY3VzIGlzc3VlXG4gICAgICAgICAgICAgICAgLy8gZm9jdXMgYWZ0ZXIgbW9udGggaGFzIGNoYW5nZWQgdmlhIGtleWJvYXJkXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmlubGluZSAmJiAhX3RoaXMucHJvcHMuc2hvdWxkRm9jdXNEYXlJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkRm9jdXNXZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZSBhY3RpdmVFbGVtZW50IGlzIGluIHRoZSBjb250YWluZXIsIGFuZCBpdCBpcyBhbm90aGVyIGluc3RhbmNlIG9mIFdlZWtOdW1iZXJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuY29udGFpbmVyUmVmICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmNvbnRhaW5lclJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmNvbnRhaW5lclJlZi5jdXJyZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJyZWFjdC1kYXRlcGlja2VyX193ZWVrLW51bWJlclwiKSkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRGb2N1c1dlZWtOdW1iZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZEZvY3VzV2Vla051bWJlciAmJlxuICAgICAgICAgICAgICAgIF90aGlzLndlZWtOdW1iZXJFbC5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgX3RoaXMud2Vla051bWJlckVsLmN1cnJlbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWVrTnVtYmVyLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhcmlhTGFiZWxQcmVmaXg6IFwid2VlayBcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXZWVrTnVtYmVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1c1dlZWtOdW1iZXIoKTtcbiAgICB9O1xuICAgIFdlZWtOdW1iZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1c1dlZWtOdW1iZXIocHJldlByb3BzKTtcbiAgICB9O1xuICAgIFdlZWtOdW1iZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgd2Vla051bWJlciA9IF9hLndlZWtOdW1iZXIsIGlzV2Vla0Rpc2FibGVkID0gX2EuaXNXZWVrRGlzYWJsZWQsIF9iID0gX2EuYXJpYUxhYmVsUHJlZml4LCBhcmlhTGFiZWxQcmVmaXggPSBfYiA9PT0gdm9pZCAwID8gV2Vla051bWJlci5kZWZhdWx0UHJvcHMuYXJpYUxhYmVsUHJlZml4IDogX2IsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrO1xuICAgICAgICB2YXIgd2Vla051bWJlckNsYXNzZXMgPSB7XG4gICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3dlZWstbnVtYmVyXCI6IHRydWUsXG4gICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3dlZWstbnVtYmVyLS1jbGlja2FibGVcIjogISFvbkNsaWNrICYmICFpc1dlZWtEaXNhYmxlZCxcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fd2Vlay1udW1iZXItLXNlbGVjdGVkXCI6ICEhb25DbGljayAmJiBpc1NhbWVEYXkodGhpcy5wcm9wcy5kYXRlLCB0aGlzLnByb3BzLnNlbGVjdGVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLndlZWtOdW1iZXJFbCwgY2xhc3NOYW1lOiBjbHN4KHdlZWtOdW1iZXJDbGFzc2VzKSwgXCJhcmlhLWxhYmVsXCI6IFwiXCIuY29uY2F0KGFyaWFMYWJlbFByZWZpeCwgXCIgXCIpLmNvbmNhdCh0aGlzLnByb3BzLndlZWtOdW1iZXIpLCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCBvbktleURvd246IHRoaXMuaGFuZGxlT25LZXlEb3duLCB0YWJJbmRleDogdGhpcy5nZXRUYWJJbmRleCgpLCByb2xlOiBcImdyaWRjZWxsXCIgfSwgd2Vla051bWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFdlZWtOdW1iZXI7XG59KENvbXBvbmVudCkpO1xuXG52YXIgV2VlayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2VlaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWVrKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RheURpc2FibGVkKGRheSwge1xuICAgICAgICAgICAgICAgIG1pbkRhdGU6IF90aGlzLnByb3BzLm1pbkRhdGUsXG4gICAgICAgICAgICAgICAgbWF4RGF0ZTogX3RoaXMucHJvcHMubWF4RGF0ZSxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlcyxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZUludGVydmFsczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVJbnRlcnZhbHMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZURhdGVJbnRlcnZhbHM6IF90aGlzLnByb3BzLmluY2x1ZGVEYXRlSW50ZXJ2YWxzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVEYXRlczogX3RoaXMucHJvcHMuaW5jbHVkZURhdGVzLFxuICAgICAgICAgICAgICAgIGZpbHRlckRhdGU6IF90aGlzLnByb3BzLmZpbHRlckRhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZGF5LCBldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5Q2xpY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkRheUNsaWNrKGRheSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEYXlNb3VzZUVudGVyID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlcihkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVXZWVrQ2xpY2sgPSBmdW5jdGlvbiAoZGF5LCB3ZWVrTnVtYmVyLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB2YXIgZW5hYmxlZFdlZWtEYXkgPSBuZXcgRGF0ZShkYXkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2luZ0RheSA9IG5ldyBEYXRlKGRheSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0RheS5zZXREYXRlKHByb2Nlc3NpbmdEYXkuZ2V0RGF0ZSgpICsgaSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzRW5hYmxlZCA9ICFfdGhpcy5pc0Rpc2FibGVkKHByb2Nlc3NpbmdEYXkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZFdlZWtEYXkgPSBwcm9jZXNzaW5nRGF5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLnByb3BzLm9uV2Vla1NlbGVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25XZWVrU2VsZWN0KGVuYWJsZWRXZWVrRGF5LCB3ZWVrTnVtYmVyLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEYXlDbGljayhlbmFibGVkV2Vla0RheSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IF90aGlzLnByb3BzLnNob3VsZENsb3NlT25TZWxlY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFdlZWsuZGVmYXVsdFByb3BzLnNob3VsZENsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfdGhpcy5wcm9wcykuc2V0T3BlbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZm9ybWF0V2Vla051bWJlciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZm9ybWF0V2Vla051bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5mb3JtYXRXZWVrTnVtYmVyKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFdlZWsoZGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzV2Vla0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrID0gX3RoaXMuc3RhcnRPZldlZWsoKTtcbiAgICAgICAgICAgIHZhciBlbmRPZldlZWsgPSBhZGREYXlzKHN0YXJ0T2ZXZWVrLCA2KTtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzaW5nRGF0ZSA9IG5ldyBEYXRlKHN0YXJ0T2ZXZWVrKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm9jZXNzaW5nRGF0ZSA8PSBlbmRPZldlZWspIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzRGlzYWJsZWQocHJvY2Vzc2luZ0RhdGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0RhdGUgPSBhZGREYXlzKHByb2Nlc3NpbmdEYXRlLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJEYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrID0gX3RoaXMuc3RhcnRPZldlZWsoKTtcbiAgICAgICAgICAgIHZhciBkYXlzID0gW107XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlciA9IF90aGlzLmZvcm1hdFdlZWtOdW1iZXIoc3RhcnRPZldlZWspO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uQ2xpY2tBY3Rpb24gPSBfdGhpcy5wcm9wcy5vbldlZWtTZWxlY3QgfHwgX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5oYW5kbGVXZWVrQ2xpY2suYmluZChfdGhpcywgc3RhcnRPZldlZWssIHdlZWtOdW1iZXIpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGRheXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFdlZWtOdW1iZXIsIF9hc3NpZ24oeyBrZXk6IFwiV1wiIH0sIFdlZWsuZGVmYXVsdFByb3BzLCBfdGhpcy5wcm9wcywgeyB3ZWVrTnVtYmVyOiB3ZWVrTnVtYmVyLCBpc1dlZWtEaXNhYmxlZDogX3RoaXMuaXNXZWVrRGlzYWJsZWQoKSwgZGF0ZTogc3RhcnRPZldlZWssIG9uQ2xpY2s6IG9uQ2xpY2tBY3Rpb24gfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXlzLmNvbmNhdChbMCwgMSwgMiwgMywgNCwgNSwgNl0ubWFwKGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF5ID0gYWRkRGF5cyhzdGFydE9mV2Vlaywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGF5LCBfYXNzaWduKHt9LCBXZWVrLmRlZmF1bHRQcm9wcywgX3RoaXMucHJvcHMsIHsgYXJpYUxhYmVsUHJlZml4V2hlbkVuYWJsZWQ6IF90aGlzLnByb3BzLmNob29zZURheUFyaWFMYWJlbFByZWZpeCwgYXJpYUxhYmVsUHJlZml4V2hlbkRpc2FibGVkOiBfdGhpcy5wcm9wcy5kaXNhYmxlZERheUFyaWFMYWJlbFByZWZpeCwga2V5OiBkYXkudmFsdWVPZigpLCBkYXk6IGRheSwgb25DbGljazogX3RoaXMuaGFuZGxlRGF5Q2xpY2suYmluZChfdGhpcywgZGF5KSwgb25Nb3VzZUVudGVyOiBfdGhpcy5oYW5kbGVEYXlNb3VzZUVudGVyLmJpbmQoX3RoaXMsIGRheSkgfSkpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhcnRPZldlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RhcnRPZldlZWsoX3RoaXMucHJvcHMuZGF5LCBfdGhpcy5wcm9wcy5sb2NhbGUsIF90aGlzLnByb3BzLmNhbGVuZGFyU3RhcnREYXkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIV90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzU2FtZURheShfdGhpcy5zdGFydE9mV2VlaygpLCBfdGhpcy5wcm9wcy5zZWxlY3RlZCkgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkoX3RoaXMuc3RhcnRPZldlZWsoKSwgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2VlaywgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ2xvc2VPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXZWVrLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3ZWVrTnVtYmVyQ2xhc3NlcyA9IHtcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fd2Vla1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX193ZWVrLS1zZWxlY3RlZFwiOiBpc1NhbWVEYXkodGhpcy5zdGFydE9mV2VlaygpLCB0aGlzLnByb3BzLnNlbGVjdGVkKSxcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fd2Vlay0ta2V5Ym9hcmQtc2VsZWN0ZWRcIjogdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGN1c3RvbVdlZWtDbGFzc05hbWUgPSB0aGlzLnByb3BzLndlZWtDbGFzc05hbWVcbiAgICAgICAgICAgID8gdGhpcy5wcm9wcy53ZWVrQ2xhc3NOYW1lKHRoaXMuc3RhcnRPZldlZWsoKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3god2Vla051bWJlckNsYXNzZXMsIGN1c3RvbVdlZWtDbGFzc05hbWUpLCByb2xlOiBcInJvd1wiIH0sIHRoaXMucmVuZGVyRGF5cygpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2Vlaztcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBfYTtcbnZhciBGSVhFRF9IRUlHSFRfU1RBTkRBUkRfV0VFS19DT1VOVCA9IDY7XG52YXIgTU9OVEhfQ09MVU1OU19MQVlPVVQgPSB7XG4gICAgVFdPX0NPTFVNTlM6IFwidHdvX2NvbHVtbnNcIixcbiAgICBUSFJFRV9DT0xVTU5TOiBcInRocmVlX2NvbHVtbnNcIixcbiAgICBGT1VSX0NPTFVNTlM6IFwiZm91cl9jb2x1bW5zXCIsXG59O1xudmFyIE1PTlRIX0NPTFVNTlMgPSAoX2EgPSB7fSxcbiAgICBfYVtNT05USF9DT0xVTU5TX0xBWU9VVC5UV09fQ09MVU1OU10gPSB7XG4gICAgICAgIGdyaWQ6IFtcbiAgICAgICAgICAgIFswLCAxXSxcbiAgICAgICAgICAgIFsyLCAzXSxcbiAgICAgICAgICAgIFs0LCA1XSxcbiAgICAgICAgICAgIFs2LCA3XSxcbiAgICAgICAgICAgIFs4LCA5XSxcbiAgICAgICAgICAgIFsxMCwgMTFdLFxuICAgICAgICBdLFxuICAgICAgICB2ZXJ0aWNhbE5hdmlnYXRpb25PZmZzZXQ6IDIsXG4gICAgfSxcbiAgICBfYVtNT05USF9DT0xVTU5TX0xBWU9VVC5USFJFRV9DT0xVTU5TXSA9IHtcbiAgICAgICAgZ3JpZDogW1xuICAgICAgICAgICAgWzAsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDQsIDVdLFxuICAgICAgICAgICAgWzYsIDcsIDhdLFxuICAgICAgICAgICAgWzksIDEwLCAxMV0sXG4gICAgICAgIF0sXG4gICAgICAgIHZlcnRpY2FsTmF2aWdhdGlvbk9mZnNldDogMyxcbiAgICB9LFxuICAgIF9hW01PTlRIX0NPTFVNTlNfTEFZT1VULkZPVVJfQ09MVU1OU10gPSB7XG4gICAgICAgIGdyaWQ6IFtcbiAgICAgICAgICAgIFswLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFs0LCA1LCA2LCA3XSxcbiAgICAgICAgICAgIFs4LCA5LCAxMCwgMTFdLFxuICAgICAgICBdLFxuICAgICAgICB2ZXJ0aWNhbE5hdmlnYXRpb25PZmZzZXQ6IDQsXG4gICAgfSxcbiAgICBfYSk7XG52YXIgTU9OVEhfTkFWSUdBVElPTl9IT1JJWk9OVEFMX09GRlNFVCA9IDE7XG5mdW5jdGlvbiBnZXRNb250aENvbHVtbnNMYXlvdXQoc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIsIHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIpIHtcbiAgICBpZiAoc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIpIHtcbiAgICAgICAgcmV0dXJuIE1PTlRIX0NPTFVNTlNfTEFZT1VULkZPVVJfQ09MVU1OUztcbiAgICB9XG4gICAgaWYgKHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIpIHtcbiAgICAgICAgcmV0dXJuIE1PTlRIX0NPTFVNTlNfTEFZT1VULlRXT19DT0xVTU5TO1xuICAgIH1cbiAgICByZXR1cm4gTU9OVEhfQ09MVU1OU19MQVlPVVQuVEhSRUVfQ09MVU1OUztcbn1cbi8qKlxuICogYE1vbnRoYCBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgYSBtb250aCBpbiBhIGNhbGVuZGFyLlxuICogSXQgYWNjZXB0cyBhIGBNb250aFByb3BzYCBvYmplY3QgYXMgcHJvcHMgd2hpY2ggcHJvdmlkZXMgdmFyaW91cyBjb25maWd1cmF0aW9ucyBhbmQgZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogQHByb3AgZGF5Q2xhc3NOYW1lIC0gRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSBjbGFzcyBuYW1lIGZvciBhIGRheS5cbiAqIEBwcm9wIG1vbnRoQ2xhc3NOYW1lIC0gRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSBjbGFzcyBuYW1lIGZvciBhIG1vbnRoLlxuICogQHByb3AgZmlsdGVyRGF0ZSAtIEZ1bmN0aW9uIHRvIGZpbHRlciBkYXRlcy5cbiAqIEBwcm9wIGZvcm1hdFdlZWtOdW1iZXIgLSBGdW5jdGlvbiB0byBmb3JtYXQgdGhlIHdlZWsgbnVtYmVyLlxuICogQHByb3Agb25EYXlDbGljayAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBkYXkgY2xpY2sgZXZlbnRzLlxuICogQHByb3Agb25EYXlNb3VzZUVudGVyIC0gRnVuY3Rpb24gdG8gaGFuZGxlIG1vdXNlIGVudGVyIGV2ZW50cyBvbiBhIGRheS5cbiAqIEBwcm9wIG9uTW91c2VMZWF2ZSAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBtb3VzZSBsZWF2ZSBldmVudHMuXG4gKiBAcHJvcCBvbldlZWtTZWxlY3QgLSBGdW5jdGlvbiB0byBoYW5kbGUgd2VlayBzZWxlY3Rpb24uXG4gKiBAcHJvcCBzZXRQcmVTZWxlY3Rpb24gLSBGdW5jdGlvbiB0byBzZXQgcHJlLXNlbGVjdGlvbi5cbiAqIEBwcm9wIHNldE9wZW4gLSBGdW5jdGlvbiB0byBzZXQgb3BlbiBzdGF0ZS5cbiAqIEBwcm9wIHJlbmRlckRheUNvbnRlbnRzIC0gRnVuY3Rpb24gdG8gcmVuZGVyIGRheSBjb250ZW50cy5cbiAqIEBwcm9wIHJlbmRlck1vbnRoQ29udGVudCAtIEZ1bmN0aW9uIHRvIHJlbmRlciBtb250aCBjb250ZW50LlxuICogQHByb3AgcmVuZGVyUXVhcnRlckNvbnRlbnQgLSBGdW5jdGlvbiB0byByZW5kZXIgcXVhcnRlciBjb250ZW50LlxuICogQHByb3AgaGFuZGxlT25LZXlEb3duIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGtleSBkb3duIGV2ZW50cy5cbiAqIEBwcm9wIGhhbmRsZU9uTW9udGhLZXlEb3duIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGtleSBkb3duIGV2ZW50cyBvbiBhIG1vbnRoLlxuICogQHByb3AgYXJpYUxhYmVsUHJlZml4IC0gQXJpYSBsYWJlbCBwcmVmaXguXG4gKiBAcHJvcCBjaG9vc2VEYXlBcmlhTGFiZWxQcmVmaXggLSBBcmlhIGxhYmVsIHByZWZpeCBmb3IgY2hvb3NpbmcgYSBkYXkuXG4gKiBAcHJvcCBkaXNhYmxlZERheUFyaWFMYWJlbFByZWZpeCAtIEFyaWEgbGFiZWwgcHJlZml4IGZvciBkaXNhYmxlZCBkYXkuXG4gKiBAcHJvcCBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiAtIEZsYWcgdG8gZGlzYWJsZSBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICogQHByb3AgZGF5IC0gVGhlIGRheS5cbiAqIEBwcm9wIGVuZERhdGUgLSBUaGUgZW5kIGRhdGUuXG4gKiBAcHJvcCBvcmRlckluRGlzcGxheSAtIFRoZSBvcmRlciBpbiBkaXNwbGF5LlxuICogQHByb3AgZXhjbHVkZURhdGVzIC0gRGF0ZXMgdG8gZXhjbHVkZS5cbiAqIEBwcm9wIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzIC0gRGF0ZSBpbnRlcnZhbHMgdG8gZXhjbHVkZS5cbiAqIEBwcm9wIGZpeGVkSGVpZ2h0IC0gRmxhZyB0byBzZXQgZml4ZWQgaGVpZ2h0LlxuICogQHByb3AgaGlnaGxpZ2h0RGF0ZXMgLSBEYXRlcyB0byBoaWdobGlnaHQuXG4gKiBAcHJvcCBob2xpZGF5cyAtIEhvbGlkYXlzLlxuICogQHByb3AgaW5jbHVkZURhdGVzIC0gRGF0ZXMgdG8gaW5jbHVkZS5cbiAqIEBwcm9wIGluY2x1ZGVEYXRlSW50ZXJ2YWxzIC0gRGF0ZSBpbnRlcnZhbHMgdG8gaW5jbHVkZS5cbiAqIEBwcm9wIGlubGluZSAtIEZsYWcgdG8gc2V0IGlubGluZS5cbiAqIEBwcm9wIHNob3VsZEZvY3VzRGF5SW5saW5lIC0gRmxhZyB0byBzZXQgZm9jdXMgb24gZGF5IGlubGluZS5cbiAqIEBwcm9wIGxvY2FsZSAtIFRoZSBsb2NhbGUuXG4gKiBAcHJvcCBtYXhEYXRlIC0gVGhlIG1heGltdW0gZGF0ZS5cbiAqIEBwcm9wIG1pbkRhdGUgLSBUaGUgbWluaW11bSBkYXRlLlxuICogQHByb3AgdXNlUG9pbnRlckV2ZW50IC0gRmxhZyB0byB1c2UgcG9pbnRlciBldmVudC5cbiAqIEBwcm9wIHBlZWtOZXh0TW9udGggLSBGbGFnIHRvIHBlZWsgbmV4dCBtb250aC5cbiAqIEBwcm9wIHByZVNlbGVjdGlvbiAtIFRoZSBwcmUtc2VsZWN0aW9uLlxuICogQHByb3Agc2VsZWN0ZWQgLSBUaGUgc2VsZWN0ZWQgZGF0ZS5cbiAqIEBwcm9wIHNlbGVjdGluZ0RhdGUgLSBUaGUgc2VsZWN0aW5nIGRhdGUuXG4gKiBAcHJvcCBjYWxlbmRhclN0YXJ0RGF5IC0gVGhlIGNhbGVuZGFyIHN0YXJ0IGRheS5cbiAqIEBwcm9wIHNlbGVjdHNFbmQgLSBGbGFnIHRvIHNlbGVjdCBlbmQuXG4gKiBAcHJvcCBzZWxlY3RzU3RhcnQgLSBGbGFnIHRvIHNlbGVjdCBzdGFydC5cbiAqIEBwcm9wIHNlbGVjdHNSYW5nZSAtIEZsYWcgdG8gc2VsZWN0IHJhbmdlLlxuICogQHByb3Agc2VsZWN0c0Rpc2FibGVkRGF5c0luUmFuZ2UgLSBGbGFnIHRvIHNlbGVjdCBkaXNhYmxlZCBkYXlzIGluIHJhbmdlLlxuICogQHByb3Agc2VsZWN0c011bHRpcGxlIC0gRmxhZyB0byBzZWxlY3QgbXVsdGlwbGUuXG4gKiBAcHJvcCBzZWxlY3RlZERhdGVzIC0gVGhlIHNlbGVjdGVkIGRhdGVzLlxuICogQHByb3Agc2hvd1dlZWtOdW1iZXJzIC0gRmxhZyB0byBzaG93IHdlZWsgbnVtYmVycy5cbiAqIEBwcm9wIHN0YXJ0RGF0ZSAtIFRoZSBzdGFydCBkYXRlLlxuICogQHByb3Agc2hvdWxkQ2xvc2VPblNlbGVjdCAtIEZsYWcgdG8gY2xvc2Ugb24gc2VsZWN0LlxuICogQHByb3Agc2hvd01vbnRoWWVhclBpY2tlciAtIEZsYWcgdG8gc2hvdyBtb250aCB5ZWFyIHBpY2tlci5cbiAqIEBwcm9wIHNob3dGdWxsTW9udGhZZWFyUGlja2VyIC0gRmxhZyB0byBzaG93IGZ1bGwgbW9udGggeWVhciBwaWNrZXIuXG4gKiBAcHJvcCBzaG93VHdvQ29sdW1uTW9udGhZZWFyUGlja2VyIC0gRmxhZyB0byBzaG93IHR3byBjb2x1bW4gbW9udGggeWVhciBwaWNrZXIuXG4gKiBAcHJvcCBzaG93Rm91ckNvbHVtbk1vbnRoWWVhclBpY2tlciAtIEZsYWcgdG8gc2hvdyBmb3VyIGNvbHVtbiBtb250aCB5ZWFyIHBpY2tlci5cbiAqIEBwcm9wIHNob3dRdWFydGVyWWVhclBpY2tlciAtIEZsYWcgdG8gc2hvdyBxdWFydGVyIHllYXIgcGlja2VyLlxuICogQHByb3Agc2hvd1dlZWtQaWNrZXIgLSBGbGFnIHRvIHNob3cgd2VlayBwaWNrZXIuXG4gKiBAcHJvcCBpc0lucHV0Rm9jdXNlZCAtIEZsYWcgdG8gc2V0IGlucHV0IGZvY3VzLlxuICogQHByb3Agd2Vla0FyaWFMYWJlbFByZWZpeCAtIEFyaWEgbGFiZWwgcHJlZml4IGZvciB3ZWVrLlxuICogQHByb3AgY29udGFpbmVyUmVmIC0gVGhlIGNvbnRhaW5lciByZWZlcmVuY2UuXG4gKiBAcHJvcCBtb250aFNob3dzRHVwbGljYXRlRGF5c0VuZCAtIEZsYWcgdG8gc2hvdyBkdXBsaWNhdGUgZGF5cyBhdCB0aGUgZW5kIG9mIHRoZSBtb250aC5cbiAqIEBwcm9wIG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgLSBGbGFnIHRvIHNob3cgZHVwbGljYXRlIGRheXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBtb250aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgY29uc3QgaGFuZGxlRGF5Q2xpY2sgPSAoZGF0ZSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdEYXkgY2xpY2tlZDogJywgZGF0ZSk7XG4gKiAgIH07XG4gKlxuICogICBjb25zdCBoYW5kbGVEYXlNb3VzZUVudGVyID0gKGRhdGUpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnTW91c2UgZW50ZXJlZCBvbiBkYXk6ICcsIGRhdGUpO1xuICogICB9O1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPE1vbnRoXG4gKiAgICAgICAgIGRheT17bmV3IERhdGUoKX1cbiAqICAgICAgICAgZW5kRGF0ZT17bmV3IERhdGUoKX1cbiAqICAgICAgICAgb25EYXlDbGljaz17aGFuZGxlRGF5Q2xpY2t9XG4gKiAgICAgICAgIG9uRGF5TW91c2VFbnRlcj17aGFuZGxlRGF5TW91c2VFbnRlcn1cbiAqICAgICAgICAgZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb249e2ZhbHNlfVxuICogICAgICAgICBzaG93V2Vla051bWJlcnM9e3RydWV9XG4gKiAgICAgICAgIHNob3dNb250aFllYXJQaWNrZXI9e2ZhbHNlfVxuICogICAgICAgLz5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG52YXIgTW9udGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbnRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbnRoKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuTU9OVEhfUkVGUyA9IF9fc3ByZWFkQXJyYXkoW10sIEFycmF5KDEyKSwgdHJ1ZSkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJlZigpOyB9KTtcbiAgICAgICAgX3RoaXMuUVVBUlRFUl9SRUZTID0gX19zcHJlYWRBcnJheShbXSwgQXJyYXkoNCksIHRydWUpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSZWYoKTsgfSk7XG4gICAgICAgIF90aGlzLmlzRGlzYWJsZWQgPSBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgICAvLyBBbG1vc3QgYWxsIHByb3BzIHByZXZpb3VzbHkgd2VyZSBwYXNzZWQgYXMgdGhpcy5wcm9wcyB3L28gcHJvcGVyIHR5cGluZyB3aXRoIHByb3AtdHlwZXNcbiAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBtaWdyYXRpb24gdG8gVFMgaSBtYWRlIGl0IGV4cGxpY2l0XG4gICAgICAgICAgICByZXR1cm4gaXNEYXlEaXNhYmxlZChkYXksIHtcbiAgICAgICAgICAgICAgICBtaW5EYXRlOiBfdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgICAgICAgICAgIG1heERhdGU6IF90aGlzLnByb3BzLm1heERhdGUsXG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZXMsXG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVJbnRlcnZhbHM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlSW50ZXJ2YWxzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVEYXRlSW50ZXJ2YWxzOiBfdGhpcy5wcm9wcy5pbmNsdWRlRGF0ZUludGVydmFscyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmluY2x1ZGVEYXRlcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJEYXRlOiBfdGhpcy5wcm9wcy5maWx0ZXJEYXRlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdGhpcy5wcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0V4Y2x1ZGVkID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgLy8gQWxtb3N0IGFsbCBwcm9wcyBwcmV2aW91c2x5IHdlcmUgcGFzc2VkIGFzIHRoaXMucHJvcHMgdy9vIHByb3BlciB0eXBpbmcgd2l0aCBwcm9wLXR5cGVzXG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgbWlncmF0aW9uIHRvIFRTIGkgbWFkZSBpdCBleHBsaWNpdFxuICAgICAgICAgICAgcmV0dXJuIGlzRGF5RXhjbHVkZWQoZGF5LCB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZXMsXG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVJbnRlcnZhbHM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlSW50ZXJ2YWxzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURheUNsaWNrID0gZnVuY3Rpb24gKGRheSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25EYXlDbGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGRheSwgZXZlbnQsIF90aGlzLnByb3BzLm9yZGVySW5EaXNwbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlciA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25EYXlNb3VzZUVudGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25Nb3VzZUxlYXZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzUmFuZ2VTdGFydE1vbnRoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0RGF0ZSB8fCAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChzZXRNb250aChkYXksIG0pLCBzdGFydERhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1JhbmdlU3RhcnRRdWFydGVyID0gZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0RGF0ZSB8fCAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVRdWFydGVyKHNldFF1YXJ0ZXIoZGF5LCBxKSwgc3RhcnREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNSYW5nZUVuZE1vbnRoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0RGF0ZSB8fCAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChzZXRNb250aChkYXksIG0pLCBlbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNSYW5nZUVuZFF1YXJ0ZXIgPSBmdW5jdGlvbiAocSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRheSA9IF9hLmRheSwgc3RhcnREYXRlID0gX2Euc3RhcnREYXRlLCBlbmREYXRlID0gX2EuZW5kRGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZVF1YXJ0ZXIoc2V0UXVhcnRlcihkYXksIHEpLCBlbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlTW9udGggPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGRheSA9IF9iLmRheSwgc2VsZWN0c1N0YXJ0ID0gX2Iuc2VsZWN0c1N0YXJ0LCBzZWxlY3RzRW5kID0gX2Iuc2VsZWN0c0VuZCwgc2VsZWN0c1JhbmdlID0gX2Iuc2VsZWN0c1JhbmdlLCBzdGFydERhdGUgPSBfYi5zdGFydERhdGUsIGVuZERhdGUgPSBfYi5lbmREYXRlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGluZ0RhdGUgPSAoX2EgPSBfdGhpcy5wcm9wcy5zZWxlY3RpbmdEYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoIShzZWxlY3RzU3RhcnQgfHwgc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHx8ICFzZWxlY3RpbmdEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNTdGFydCAmJiBlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTW9udGhJblJhbmdlKHNlbGVjdGluZ0RhdGUsIGVuZERhdGUsIG0sIGRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCAmJiBzdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNNb250aEluUmFuZ2Uoc3RhcnREYXRlLCBzZWxlY3RpbmdEYXRlLCBtLCBkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSAmJiBzdGFydERhdGUgJiYgIWVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNNb250aEluUmFuZ2Uoc3RhcnREYXRlLCBzZWxlY3RpbmdEYXRlLCBtLCBkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGluZ01vbnRoUmFuZ2VTdGFydCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzSW5TZWxlY3RpbmdSYW5nZU1vbnRoKG0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGRheSA9IF9iLmRheSwgc3RhcnREYXRlID0gX2Iuc3RhcnREYXRlLCBzZWxlY3RzU3RhcnQgPSBfYi5zZWxlY3RzU3RhcnQ7XG4gICAgICAgICAgICB2YXIgX21vbnRoID0gc2V0TW9udGgoZGF5LCBtKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RpbmdEYXRlID0gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0aW5nRGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHNlbGVjdHNTdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChfbW9udGgsIHNlbGVjdGluZ0RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZU1vbnRoKF9tb250aCwgc3RhcnREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RpbmdNb250aFJhbmdlRW5kID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlTW9udGgobSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBlbmREYXRlID0gX2IuZW5kRGF0ZSwgc2VsZWN0c0VuZCA9IF9iLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZTtcbiAgICAgICAgICAgIHZhciBfbW9udGggPSBzZXRNb250aChkYXksIG0pO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGluZ0RhdGUgPSAoX2EgPSBfdGhpcy5wcm9wcy5zZWxlY3RpbmdEYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lTW9udGgoX21vbnRoLCBzZWxlY3RpbmdEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChfbW9udGgsIGVuZERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2VRdWFydGVyID0gZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBkYXkgPSBfYi5kYXksIHNlbGVjdHNTdGFydCA9IF9iLnNlbGVjdHNTdGFydCwgc2VsZWN0c0VuZCA9IF9iLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZSwgc3RhcnREYXRlID0gX2Iuc3RhcnREYXRlLCBlbmREYXRlID0gX2IuZW5kRGF0ZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RpbmdEYXRlID0gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0aW5nRGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKCEoc2VsZWN0c1N0YXJ0IHx8IHNlbGVjdHNFbmQgfHwgc2VsZWN0c1JhbmdlKSB8fCAhc2VsZWN0aW5nRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RzU3RhcnQgJiYgZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1F1YXJ0ZXJJblJhbmdlKHNlbGVjdGluZ0RhdGUsIGVuZERhdGUsIHEsIGRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCAmJiBzdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNRdWFydGVySW5SYW5nZShzdGFydERhdGUsIHNlbGVjdGluZ0RhdGUsIHEsIGRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlICYmIHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1F1YXJ0ZXJJblJhbmdlKHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSwgcSwgZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNXZWVrSW5Nb250aCA9IGZ1bmN0aW9uIChzdGFydE9mV2Vlaykge1xuICAgICAgICAgICAgdmFyIGRheSA9IF90aGlzLnByb3BzLmRheTtcbiAgICAgICAgICAgIHZhciBlbmRPZldlZWsgPSBhZGREYXlzKHN0YXJ0T2ZXZWVrLCA2KTtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChzdGFydE9mV2VlaywgZGF5KSB8fCBpc1NhbWVNb250aChlbmRPZldlZWssIGRheSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzQ3VycmVudE1vbnRoID0gZnVuY3Rpb24gKGRheSwgbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFllYXIoZGF5KSA9PT0gZ2V0WWVhcihuZXdEYXRlKCkpICYmIG0gPT09IGdldE1vbnRoKG5ld0RhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzQ3VycmVudFF1YXJ0ZXIgPSBmdW5jdGlvbiAoZGF5LCBxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0WWVhcihkYXkpID09PSBnZXRZZWFyKG5ld0RhdGUoKSkgJiYgcSA9PT0gZ2V0UXVhcnRlcihuZXdEYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGVkTW9udGggPSBmdW5jdGlvbiAoZGF5LCBtLCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1vbnRoKHNlbGVjdGVkKSA9PT0gbSAmJiBnZXRZZWFyKGRheSkgPT09IGdldFllYXIoc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdE1vbnRoSW5MaXN0ID0gZnVuY3Rpb24gKGRheSwgbSwgc2VsZWN0ZWREYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkRGF0ZXMuc29tZShmdW5jdGlvbiAoc2VsZWN0ZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzU2VsZWN0ZWRNb250aChkYXksIG0sIHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIgPSBmdW5jdGlvbiAoZGF5LCBxLCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFF1YXJ0ZXIoc2VsZWN0ZWQpID09PSBxICYmIGdldFllYXIoZGF5KSA9PT0gZ2V0WWVhcihzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2VsZWN0UXVhcnRlckluTGlzdCA9IGZ1bmN0aW9uIChkYXksIHEsIHNlbGVjdGVkRGF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZERhdGVzLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc1NlbGVjdGVkUXVhcnRlcihkYXksIHEsIHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNNb250aFNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRheSA9IF9hLmRheSwgc2VsZWN0ZWQgPSBfYS5zZWxlY3RlZCwgc2VsZWN0ZWREYXRlcyA9IF9hLnNlbGVjdGVkRGF0ZXMsIHNlbGVjdHNNdWx0aXBsZSA9IF9hLnNlbGVjdHNNdWx0aXBsZTtcbiAgICAgICAgICAgIHZhciBtb250aElkeCA9IGdldE1vbnRoKGRheSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0c011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkRGF0ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWREYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWREYXRlcy5zb21lKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc1NlbGVjdGVkTW9udGgoZGF5LCBtb250aElkeCwgZGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISFzZWxlY3RlZCAmJiBfdGhpcy5pc1NlbGVjdGVkTW9udGgoZGF5LCBtb250aElkeCwgc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1F1YXJ0ZXJTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQsIHNlbGVjdGVkRGF0ZXMgPSBfYS5zZWxlY3RlZERhdGVzLCBzZWxlY3RzTXVsdGlwbGUgPSBfYS5zZWxlY3RzTXVsdGlwbGU7XG4gICAgICAgICAgICB2YXIgcXVhcnRlcklkeCA9IGdldFF1YXJ0ZXIoZGF5KTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWREYXRlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZERhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERhdGVzLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIoZGF5LCBxdWFydGVySWR4LCBzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICEhc2VsZWN0ZWQgJiYgX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIoZGF5LCBxdWFydGVySWR4LCBzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlcldlZWtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGlmIGRheSBpcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQoX3RoaXMucHJvcHMuZGF5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3ZWVrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGlzRml4ZWRIZWlnaHQgPSBfdGhpcy5wcm9wcy5maXhlZEhlaWdodDtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciBicmVha0FmdGVyTmV4dFB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50V2Vla1N0YXJ0ID0gZ2V0U3RhcnRPZldlZWsoZ2V0U3RhcnRPZk1vbnRoKF90aGlzLnByb3BzLmRheSksIF90aGlzLnByb3BzLmxvY2FsZSwgX3RoaXMucHJvcHMuY2FsZW5kYXJTdGFydERheSk7XG4gICAgICAgICAgICB2YXIgaXNQcmVTZWxlY3RlZCA9IGZ1bmN0aW9uIChwcmVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTdGFydE9mV2VlayhwcmVTZWxlY3Rpb24sIF90aGlzLnByb3BzLmxvY2FsZSwgX3RoaXMucHJvcHMuY2FsZW5kYXJTdGFydERheSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTdGFydE9mV2VlayhzZWxlY3RlZCwgX3RoaXMucHJvcHMubG9jYWxlLCBfdGhpcy5wcm9wcy5jYWxlbmRhclN0YXJ0RGF5KVxuICAgICAgICAgICAgICAgICAgICA6IF90aGlzLnByb3BzLnNlbGVjdGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IF90aGlzLnByb3BzLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyBpc1NlbGVjdGVkKF90aGlzLnByb3BzLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHByZVNlbGVjdGlvbiA9IF90aGlzLnByb3BzLnByZVNlbGVjdGlvblxuICAgICAgICAgICAgICAgID8gaXNQcmVTZWxlY3RlZChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdlZWtzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChXZWVrLCBfYXNzaWduKHt9LCBfdGhpcy5wcm9wcywgeyBhcmlhTGFiZWxQcmVmaXg6IF90aGlzLnByb3BzLndlZWtBcmlhTGFiZWxQcmVmaXgsIGtleTogaSwgZGF5OiBjdXJyZW50V2Vla1N0YXJ0LCBtb250aDogZ2V0TW9udGgoX3RoaXMucHJvcHMuZGF5KSwgb25EYXlDbGljazogX3RoaXMuaGFuZGxlRGF5Q2xpY2ssIG9uRGF5TW91c2VFbnRlcjogX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlciwgc2VsZWN0ZWQ6IHNlbGVjdGVkLCBwcmVTZWxlY3Rpb246IHByZVNlbGVjdGlvbiwgc2hvd1dlZWtOdW1iZXI6IF90aGlzLnByb3BzLnNob3dXZWVrTnVtYmVycyB9KSkpO1xuICAgICAgICAgICAgICAgIGlmIChicmVha0FmdGVyTmV4dFB1c2gpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50V2Vla1N0YXJ0ID0gYWRkV2Vla3MoY3VycmVudFdlZWtTdGFydCwgMSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgb25lIG9mIHRoZXNlIGNvbmRpdGlvbnMgaXMgdHJ1ZSwgd2Ugd2lsbCBlaXRoZXIgYnJlYWsgb24gdGhpcyB3ZWVrXG4gICAgICAgICAgICAgICAgLy8gb3IgYnJlYWsgb24gdGhlIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHZhciBpc0ZpeGVkQW5kRmluYWxXZWVrID0gaXNGaXhlZEhlaWdodCAmJiBpID49IEZJWEVEX0hFSUdIVF9TVEFOREFSRF9XRUVLX0NPVU5UO1xuICAgICAgICAgICAgICAgIHZhciBpc05vbkZpeGVkQW5kT3V0T2ZNb250aCA9ICFpc0ZpeGVkSGVpZ2h0ICYmICFfdGhpcy5pc1dlZWtJbk1vbnRoKGN1cnJlbnRXZWVrU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpeGVkQW5kRmluYWxXZWVrIHx8IGlzTm9uRml4ZWRBbmRPdXRPZk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wZWVrTmV4dE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha0FmdGVyTmV4dFB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2Vla3M7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW9udGhDbGljayA9IGZ1bmN0aW9uIChldmVudCwgbSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuaXNNb250aERpc2FibGVkRm9yTGFiZWxEYXRlKG0pLCBpc0Rpc2FibGVkID0gX2EuaXNEaXNhYmxlZCwgbGFiZWxEYXRlID0gX2EubGFiZWxEYXRlO1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVEYXlDbGljayhnZXRTdGFydE9mTW9udGgobGFiZWxEYXRlKSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vbnRoTW91c2VFbnRlciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5pc01vbnRoRGlzYWJsZWRGb3JMYWJlbERhdGUobSksIGlzRGlzYWJsZWQgPSBfYS5pc0Rpc2FibGVkLCBsYWJlbERhdGUgPSBfYS5sYWJlbERhdGU7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhhbmRsZURheU1vdXNlRW50ZXIoZ2V0U3RhcnRPZk1vbnRoKGxhYmVsRGF0ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVNb250aE5hdmlnYXRpb24gPSBmdW5jdGlvbiAobmV3TW9udGgsIG5ld0RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRQcmVTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXdEYXRlKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IF90aGlzLk1PTlRIX1JFRlNbbmV3TW9udGhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUtleWJvYXJkTmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChldmVudCwgZXZlbnRLZXksIG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgc2VsZWN0ZWQgPSBfYi5zZWxlY3RlZCwgcHJlU2VsZWN0aW9uID0gX2IucHJlU2VsZWN0aW9uLCBzZXRQcmVTZWxlY3Rpb24gPSBfYi5zZXRQcmVTZWxlY3Rpb24sIG1pbkRhdGUgPSBfYi5taW5EYXRlLCBtYXhEYXRlID0gX2IubWF4RGF0ZSwgc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIgPSBfYi5zaG93Rm91ckNvbHVtbk1vbnRoWWVhclBpY2tlciwgc2hvd1R3b0NvbHVtbk1vbnRoWWVhclBpY2tlciA9IF9iLnNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXI7XG4gICAgICAgICAgICBpZiAoIXByZVNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbW9udGhDb2x1bW5zTGF5b3V0ID0gZ2V0TW9udGhDb2x1bW5zTGF5b3V0KHNob3dGb3VyQ29sdW1uTW9udGhZZWFyUGlja2VyLCBzaG93VHdvQ29sdW1uTW9udGhZZWFyUGlja2VyKTtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IF90aGlzLmdldFZlcnRpY2FsT2Zmc2V0KG1vbnRoQ29sdW1uc0xheW91dCk7XG4gICAgICAgICAgICB2YXIgbW9udGhzR3JpZCA9IChfYSA9IE1PTlRIX0NPTFVNTlNbbW9udGhDb2x1bW5zTGF5b3V0XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyaWQ7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlTmV3RGF0ZUFuZE1vbnRoID0gZnVuY3Rpb24gKGV2ZW50S2V5LCBkYXRlLCBtb250aCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NhbGN1bGF0ZWREYXRlID0gZGF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2FsY3VsYXRlZE1vbnRoID0gbW9udGg7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudEtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gYWRkTW9udGhzKGRhdGUsIE1PTlRIX05BVklHQVRJT05fSE9SSVpPTlRBTF9PRkZTRVQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZE1vbnRoID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9PT0gMTEgPyAwIDogbW9udGggKyBNT05USF9OQVZJR0FUSU9OX0hPUklaT05UQUxfT0ZGU0VUO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IHN1Yk1vbnRocyhkYXRlLCBNT05USF9OQVZJR0FUSU9OX0hPUklaT05UQUxfT0ZGU0VUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPT09IDAgPyAxMSA6IG1vbnRoIC0gTU9OVEhfTkFWSUdBVElPTl9IT1JJWk9OVEFMX09GRlNFVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dVcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gc3ViTW9udGhzKGRhdGUsIHZlcnRpY2FsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9ICgoX2EgPSBtb250aHNHcmlkID09PSBudWxsIHx8IG1vbnRoc0dyaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vbnRoc0dyaWRbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhtb250aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtb250aCArIDEyIC0gdmVydGljYWxPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1vbnRoIC0gdmVydGljYWxPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93RG93bjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gYWRkTW9udGhzKGRhdGUsIHZlcnRpY2FsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9ICgoX2IgPSBtb250aHNHcmlkID09PSBudWxsIHx8IG1vbnRoc0dyaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vbnRoc0dyaWRbbW9udGhzR3JpZC5sZW5ndGggLSAxXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKG1vbnRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1vbnRoIC0gMTIgKyB2ZXJ0aWNhbE9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9udGggKyB2ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBuZXdDYWxjdWxhdGVkRGF0ZTogbmV3Q2FsY3VsYXRlZERhdGUsIG5ld0NhbGN1bGF0ZWRNb250aDogbmV3Q2FsY3VsYXRlZE1vbnRoIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldE5ld0RhdGVBbmRNb250aCA9IGZ1bmN0aW9uIChldmVudEtleSwgc2VsZWN0ZWREYXRlLCBtb250aCkge1xuICAgICAgICAgICAgICAgIHZhciBNQVhfSVRFUkFUSU9OUyA9IDQwO1xuICAgICAgICAgICAgICAgIHZhciBldmVudEtleUNvcHkgPSBldmVudEtleTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWREYXRlRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gY2FsY3VsYXRlTmV3RGF0ZUFuZE1vbnRoKGV2ZW50S2V5Q29weSwgc2VsZWN0ZWREYXRlLCBtb250aCksIG5ld0NhbGN1bGF0ZWREYXRlID0gX2EubmV3Q2FsY3VsYXRlZERhdGUsIG5ld0NhbGN1bGF0ZWRNb250aCA9IF9hLm5ld0NhbGN1bGF0ZWRNb250aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIXZhbGlkRGF0ZUZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb25zID49IE1BWF9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IHNlbGVjdGVkRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9IG1vbnRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbWluRGF0ZSBleGlzdHMgYW5kIHRoZSBuZXcgbW9udGggaXMgYmVmb3JlIHRoZSBtaW5pbXVtIG1vbnRoLCBpdCB3aWxsIHRyeSB0byBmaW5kIHRoZSBuZXh0IGF2YWlsYWJsZSBtb250aCBhZnRlclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluRGF0ZSAmJiBuZXdDYWxjdWxhdGVkRGF0ZSA8IG1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29weSA9IEtleVR5cGUuQXJyb3dSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYWxjdWxhdGVOZXdEYXRlQW5kTW9udGgoZXZlbnRLZXlDb3B5LCBuZXdDYWxjdWxhdGVkRGF0ZSwgbmV3Q2FsY3VsYXRlZE1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gb2JqLm5ld0NhbGN1bGF0ZWREYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZE1vbnRoID0gb2JqLm5ld0NhbGN1bGF0ZWRNb250aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtYXhEYXRlIGV4aXN0cyBhbmQgdGhlIG5ldyBtb250aCBpcyBhZnRlciB0aGUgbWF4aW11bSBtb250aCwgaXQgd2lsbCB0cnkgdG8gZmluZCB0aGUgbmV4dCBhdmFpbGFibGUgbW9udGggYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIG5ld0NhbGN1bGF0ZWREYXRlID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRLZXlDb3B5ID0gS2V5VHlwZS5BcnJvd0xlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FsY3VsYXRlTmV3RGF0ZUFuZE1vbnRoKGV2ZW50S2V5Q29weSwgbmV3Q2FsY3VsYXRlZERhdGUsIG5ld0NhbGN1bGF0ZWRNb250aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IG9iai5uZXdDYWxjdWxhdGVkRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9IG9iai5uZXdDYWxjdWxhdGVkTW9udGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW9udGhZZWFyRGlzYWJsZWQobmV3Q2FsY3VsYXRlZERhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGNhbGN1bGF0ZU5ld0RhdGVBbmRNb250aChldmVudEtleUNvcHksIG5ld0NhbGN1bGF0ZWREYXRlLCBuZXdDYWxjdWxhdGVkTW9udGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBvYmoubmV3Q2FsY3VsYXRlZERhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkTW9udGggPSBvYmoubmV3Q2FsY3VsYXRlZE1vbnRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWREYXRlRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmV3Q2FsY3VsYXRlZERhdGU6IG5ld0NhbGN1bGF0ZWREYXRlLCBuZXdDYWxjdWxhdGVkTW9udGg6IG5ld0NhbGN1bGF0ZWRNb250aCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5FbnRlcikge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNNb250aERpc2FibGVkKG1vbnRoKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbk1vbnRoQ2xpY2soZXZlbnQsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJlU2VsZWN0aW9uID09PSBudWxsIHx8IHNldFByZVNlbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0UHJlU2VsZWN0aW9uKHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9jID0gZ2V0TmV3RGF0ZUFuZE1vbnRoKGV2ZW50S2V5LCBwcmVTZWxlY3Rpb24sIG1vbnRoKSwgbmV3Q2FsY3VsYXRlZERhdGUgPSBfYy5uZXdDYWxjdWxhdGVkRGF0ZSwgbmV3Q2FsY3VsYXRlZE1vbnRoID0gX2MubmV3Q2FsY3VsYXRlZE1vbnRoO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudEtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd1JpZ2h0OlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93VXA6XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93RG93bjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW9udGhOYXZpZ2F0aW9uKG5ld0NhbGN1bGF0ZWRNb250aCwgbmV3Q2FsY3VsYXRlZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VmVydGljYWxPZmZzZXQgPSBmdW5jdGlvbiAobW9udGhDb2x1bW5zTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IE1PTlRIX0NPTFVNTlNbbW9udGhDb2x1bW5zTGF5b3V0XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZlcnRpY2FsTmF2aWdhdGlvbk9mZnNldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb250aEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQsIG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24gPSBfYS5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiwgaGFuZGxlT25Nb250aEtleURvd24gPSBfYS5oYW5kbGVPbk1vbnRoS2V5RG93bjtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSAhPT0gS2V5VHlwZS5UYWIpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbiB0YWIgZXZlbnQgYmxvY2tzIGZvY3VzIGNoYW5nZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9uKGV2ZW50LCBldmVudEtleSwgbW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlT25Nb250aEtleURvd24gJiYgaGFuZGxlT25Nb250aEtleURvd24oZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblF1YXJ0ZXJDbGljayA9IGZ1bmN0aW9uIChldmVudCwgcSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsRGF0ZSA9IHNldFF1YXJ0ZXIoX3RoaXMucHJvcHMuZGF5LCBxKTtcbiAgICAgICAgICAgIGlmIChpc1F1YXJ0ZXJEaXNhYmxlZChsYWJlbERhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhhbmRsZURheUNsaWNrKGdldFN0YXJ0T2ZRdWFydGVyKGxhYmVsRGF0ZSksIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25RdWFydGVyTW91c2VFbnRlciA9IGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxEYXRlID0gc2V0UXVhcnRlcihfdGhpcy5wcm9wcy5kYXksIHEpO1xuICAgICAgICAgICAgaWYgKGlzUXVhcnRlckRpc2FibGVkKGxhYmVsRGF0ZSwgX3RoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlcihnZXRTdGFydE9mUXVhcnRlcihsYWJlbERhdGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUXVhcnRlck5hdmlnYXRpb24gPSBmdW5jdGlvbiAobmV3UXVhcnRlciwgbmV3RGF0ZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRGlzYWJsZWQobmV3RGF0ZSkgfHwgX3RoaXMuaXNFeGNsdWRlZChuZXdEYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRQcmVTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXdEYXRlKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IF90aGlzLlFVQVJURVJfUkVGU1tuZXdRdWFydGVyIC0gMV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25RdWFydGVyS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCwgcXVhcnRlcikge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5FbnRlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uUXVhcnRlckNsaWNrKGV2ZW50LCBxdWFydGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRQcmVTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBfdGhpcy5wcm9wcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93UmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLnByZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUXVhcnRlck5hdmlnYXRpb24ocXVhcnRlciA9PT0gNCA/IDEgOiBxdWFydGVyICsgMSwgYWRkUXVhcnRlcnMoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93TGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVRdWFydGVyTmF2aWdhdGlvbihxdWFydGVyID09PSAxID8gNCA6IHF1YXJ0ZXIgLSAxLCBzdWJRdWFydGVycyhfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNNb250aERpc2FibGVkRm9yTGFiZWxEYXRlID0gZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9iLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzO1xuICAgICAgICAgICAgdmFyIGxhYmVsRGF0ZSA9IHNldE1vbnRoKGRheSwgbW9udGgpO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRlOiBzZXRNb250aChkYXksIG1vbnRoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc0Rpc2FibGVkOiAoX2EgPSAoKG1pbkRhdGUgfHwgbWF4RGF0ZSB8fCBleGNsdWRlRGF0ZXMgfHwgaW5jbHVkZURhdGVzKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc01vbnRoRGlzYWJsZWQobGFiZWxEYXRlLCBfdGhpcy5wcm9wcykpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbERhdGU6IGxhYmVsRGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzTW9udGhEaXNhYmxlZCA9IGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBfdGhpcy5pc01vbnRoRGlzYWJsZWRGb3JMYWJlbERhdGUobW9udGgpLmlzRGlzYWJsZWQ7XG4gICAgICAgICAgICByZXR1cm4gaXNEaXNhYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TW9udGhDbGFzc05hbWVzID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGUsIHByZVNlbGVjdGlvbiA9IF9hLnByZVNlbGVjdGlvbiwgbW9udGhDbGFzc05hbWUgPSBfYS5tb250aENsYXNzTmFtZTtcbiAgICAgICAgICAgIHZhciBfbW9udGhDbGFzc05hbWUgPSBtb250aENsYXNzTmFtZVxuICAgICAgICAgICAgICAgID8gbW9udGhDbGFzc05hbWUoc2V0TW9udGgoZGF5LCBtKSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBjbHN4KFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dFwiLCBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLVwiLmNvbmNhdChtKSwgX21vbnRoQ2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS1kaXNhYmxlZFwiOiBfdGhpcy5pc01vbnRoRGlzYWJsZWQobSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS1zZWxlY3RlZFwiOiBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5pc1NlbGVjdE1vbnRoSW5MaXN0KGRheSwgbSwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXRleHQtLWtleWJvYXJkLXNlbGVjdGVkXCI6ICFfdGhpcy5wcm9wcy5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNTZWxlY3RlZE1vbnRoKGRheSwgbSwgcHJlU2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAhX3RoaXMuaXNNb250aFNlbGVjdGVkKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLmlzTW9udGhEaXNhYmxlZChtKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXRleHQtLWluLXNlbGVjdGluZy1yYW5nZVwiOiBfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2VNb250aChtKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXRleHQtLWluLXJhbmdlXCI6IHN0YXJ0RGF0ZSAmJiBlbmREYXRlXG4gICAgICAgICAgICAgICAgICAgID8gaXNNb250aEluUmFuZ2Uoc3RhcnREYXRlLCBlbmREYXRlLCBtLCBkYXkpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dC0tcmFuZ2Utc3RhcnRcIjogX3RoaXMuaXNSYW5nZVN0YXJ0TW9udGgobSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS1yYW5nZS1lbmRcIjogX3RoaXMuaXNSYW5nZUVuZE1vbnRoKG0pLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dC0tc2VsZWN0aW5nLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzU2VsZWN0aW5nTW9udGhSYW5nZVN0YXJ0KG0pLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dC0tc2VsZWN0aW5nLXJhbmdlLWVuZFwiOiBfdGhpcy5pc1NlbGVjdGluZ01vbnRoUmFuZ2VFbmQobSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS10b2RheVwiOiBfdGhpcy5pc0N1cnJlbnRNb250aChkYXksIG0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFRhYkluZGV4ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi0xXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlU2VsZWN0ZWRNb250aCA9IGdldE1vbnRoKF90aGlzLnByb3BzLnByZVNlbGVjdGlvbik7XG4gICAgICAgICAgICB2YXIgaXNQcmVTZWxlY3RlZE1vbnRoRGlzYWJsZWQgPSBfdGhpcy5pc01vbnRoRGlzYWJsZWRGb3JMYWJlbERhdGUocHJlU2VsZWN0ZWRNb250aCkuaXNEaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciB0YWJJbmRleCA9IG0gPT09IHByZVNlbGVjdGVkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhKGlzUHJlU2VsZWN0ZWRNb250aERpc2FibGVkIHx8IF90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uKVxuICAgICAgICAgICAgICAgID8gXCIwXCJcbiAgICAgICAgICAgICAgICA6IFwiLTFcIjtcbiAgICAgICAgICAgIHJldHVybiB0YWJJbmRleDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0UXVhcnRlclRhYkluZGV4ID0gZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi0xXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlU2VsZWN0ZWRRdWFydGVyID0gZ2V0UXVhcnRlcihfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGlzQ3VycmVudFF1YXJ0ZXJEaXNhYmxlZCA9IGlzUXVhcnRlckRpc2FibGVkKF90aGlzLnByb3BzLmRheSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgdmFyIHRhYkluZGV4ID0gcSA9PT0gcHJlU2VsZWN0ZWRRdWFydGVyICYmXG4gICAgICAgICAgICAgICAgIShpc0N1cnJlbnRRdWFydGVyRGlzYWJsZWQgfHwgX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24pXG4gICAgICAgICAgICAgICAgPyBcIjBcIlxuICAgICAgICAgICAgICAgIDogXCItMVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRhYkluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRBcmlhTGFiZWwgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBfYiA9IF9hLmNob29zZURheUFyaWFMYWJlbFByZWZpeCwgY2hvb3NlRGF5QXJpYUxhYmVsUHJlZml4ID0gX2IgPT09IHZvaWQgMCA/IFwiQ2hvb3NlXCIgOiBfYiwgX2MgPSBfYS5kaXNhYmxlZERheUFyaWFMYWJlbFByZWZpeCwgZGlzYWJsZWREYXlBcmlhTGFiZWxQcmVmaXggPSBfYyA9PT0gdm9pZCAwID8gXCJOb3QgYXZhaWxhYmxlXCIgOiBfYywgZGF5ID0gX2EuZGF5LCBsb2NhbGUgPSBfYS5sb2NhbGU7XG4gICAgICAgICAgICB2YXIgbGFiZWxEYXRlID0gc2V0TW9udGgoZGF5LCBtb250aCk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gX3RoaXMuaXNEaXNhYmxlZChsYWJlbERhdGUpIHx8IF90aGlzLmlzRXhjbHVkZWQobGFiZWxEYXRlKVxuICAgICAgICAgICAgICAgID8gZGlzYWJsZWREYXlBcmlhTGFiZWxQcmVmaXhcbiAgICAgICAgICAgICAgICA6IGNob29zZURheUFyaWFMYWJlbFByZWZpeDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiKS5jb25jYXQoZm9ybWF0RGF0ZShsYWJlbERhdGUsIFwiTU1NTSB5eXl5XCIsIGxvY2FsZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRRdWFydGVyQ2xhc3NOYW1lcyA9IGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBzdGFydERhdGUgPSBfYS5zdGFydERhdGUsIGVuZERhdGUgPSBfYS5lbmREYXRlLCBtaW5EYXRlID0gX2EubWluRGF0ZSwgbWF4RGF0ZSA9IF9hLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9hLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2EuaW5jbHVkZURhdGVzLCBmaWx0ZXJEYXRlID0gX2EuZmlsdGVyRGF0ZSwgcHJlU2VsZWN0aW9uID0gX2EucHJlU2VsZWN0aW9uLCBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiA9IF9hLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSAobWluRGF0ZSB8fFxuICAgICAgICAgICAgICAgIG1heERhdGUgfHxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXMgfHxcbiAgICAgICAgICAgICAgICBpbmNsdWRlRGF0ZXMgfHxcbiAgICAgICAgICAgICAgICBmaWx0ZXJEYXRlIHx8XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQpICYmXG4gICAgICAgICAgICAgICAgaXNRdWFydGVyRGlzYWJsZWQoc2V0UXVhcnRlcihkYXksIHEpLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX3RoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dFwiLCBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItXCIuY29uY2F0KHEpLCB7XG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19xdWFydGVyLXRleHQtLWRpc2FibGVkXCI6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19xdWFydGVyLXRleHQtLXNlbGVjdGVkXCI6IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLmlzU2VsZWN0UXVhcnRlckluTGlzdChkYXksIHEsIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19xdWFydGVyLXRleHQtLWtleWJvYXJkLXNlbGVjdGVkXCI6ICFkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIoZGF5LCBxLCBwcmVTZWxlY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5pc1F1YXJ0ZXJTZWxlY3RlZCgpICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0Rpc2FibGVkLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fcXVhcnRlci10ZXh0LS1pbi1zZWxlY3RpbmctcmFuZ2VcIjogX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlUXVhcnRlcihxKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dC0taW4tcmFuZ2VcIjogc3RhcnREYXRlICYmIGVuZERhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBpc1F1YXJ0ZXJJblJhbmdlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgcSwgZGF5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dC0tcmFuZ2Utc3RhcnRcIjogX3RoaXMuaXNSYW5nZVN0YXJ0UXVhcnRlcihxKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dC0tcmFuZ2UtZW5kXCI6IF90aGlzLmlzUmFuZ2VFbmRRdWFydGVyKHEpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fcXVhcnRlci10ZXh0LS10b2RheVwiOiBfdGhpcy5pc0N1cnJlbnRRdWFydGVyKGRheSwgcSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TW9udGhDb250ZW50ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBzaG93RnVsbE1vbnRoWWVhclBpY2tlciA9IF9hLnNob3dGdWxsTW9udGhZZWFyUGlja2VyLCByZW5kZXJNb250aENvbnRlbnQgPSBfYS5yZW5kZXJNb250aENvbnRlbnQsIGxvY2FsZSA9IF9hLmxvY2FsZSwgZGF5ID0gX2EuZGF5O1xuICAgICAgICAgICAgdmFyIHNob3J0TW9udGhUZXh0ID0gZ2V0TW9udGhTaG9ydEluTG9jYWxlKG0sIGxvY2FsZSk7XG4gICAgICAgICAgICB2YXIgZnVsbE1vbnRoVGV4dCA9IGdldE1vbnRoSW5Mb2NhbGUobSwgbG9jYWxlKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJNb250aENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTW9udGhDb250ZW50KG0sIHNob3J0TW9udGhUZXh0LCBmdWxsTW9udGhUZXh0LCBkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNob3dGdWxsTW9udGhZZWFyUGlja2VyID8gZnVsbE1vbnRoVGV4dCA6IHNob3J0TW9udGhUZXh0O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRRdWFydGVyQ29udGVudCA9IGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgcmVuZGVyUXVhcnRlckNvbnRlbnQgPSBfYi5yZW5kZXJRdWFydGVyQ29udGVudCwgbG9jYWxlID0gX2IubG9jYWxlO1xuICAgICAgICAgICAgdmFyIHNob3J0UXVhcnRlciA9IGdldFF1YXJ0ZXJTaG9ydEluTG9jYWxlKHEsIGxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcmVuZGVyUXVhcnRlckNvbnRlbnQgPT09IG51bGwgfHwgcmVuZGVyUXVhcnRlckNvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlclF1YXJ0ZXJDb250ZW50KHEsIHNob3J0UXVhcnRlcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNob3J0UXVhcnRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyTW9udGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIgPSBfYi5zaG93VHdvQ29sdW1uTW9udGhZZWFyUGlja2VyLCBzaG93Rm91ckNvbHVtbk1vbnRoWWVhclBpY2tlciA9IF9iLnNob3dGb3VyQ29sdW1uTW9udGhZZWFyUGlja2VyLCBkYXkgPSBfYi5kYXksIHNlbGVjdGVkID0gX2Iuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgbW9udGhDb2x1bW5zID0gKF9hID0gTU9OVEhfQ09MVU1OU1tnZXRNb250aENvbHVtbnNMYXlvdXQoc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIsIHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyaWQ7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhDb2x1bW5zID09PSBudWxsIHx8IG1vbnRoQ29sdW1ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9udGhDb2x1bW5zLm1hcChmdW5jdGlvbiAobW9udGgsIGkpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXdyYXBwZXJcIiwga2V5OiBpIH0sIG1vbnRoLm1hcChmdW5jdGlvbiAobSwgaikgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IF90aGlzLk1PTlRIX1JFRlNbbV0sIGtleTogaiwgb25DbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTW9udGhDbGljayhldmVudCwgbSk7XG4gICAgICAgICAgICAgICAgfSwgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3BhY2VLZXlEb3duKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmtleSA9IEtleVR5cGUuRW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25Nb250aEtleURvd24oZXZlbnQsIG0pO1xuICAgICAgICAgICAgICAgIH0sIG9uTW91c2VFbnRlcjogIV90aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW9udGhNb3VzZUVudGVyKG0pOyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvblBvaW50ZXJFbnRlcjogX3RoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50XG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb250aE1vdXNlRW50ZXIobSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIHRhYkluZGV4OiBOdW1iZXIoX3RoaXMuZ2V0VGFiSW5kZXgobSkpLCBjbGFzc05hbWU6IF90aGlzLmdldE1vbnRoQ2xhc3NOYW1lcyhtKSwgXCJhcmlhLWRpc2FibGVkXCI6IF90aGlzLmlzTW9udGhEaXNhYmxlZChtKSwgcm9sZTogXCJvcHRpb25cIiwgXCJhcmlhLWxhYmVsXCI6IF90aGlzLmdldEFyaWFMYWJlbChtKSwgXCJhcmlhLWN1cnJlbnRcIjogX3RoaXMuaXNDdXJyZW50TW9udGgoZGF5LCBtKSA/IFwiZGF0ZVwiIDogdW5kZWZpbmVkLCBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWQgPyBfdGhpcy5pc1NlbGVjdGVkTW9udGgoZGF5LCBtLCBzZWxlY3RlZCkgOiB1bmRlZmluZWQgfSwgX3RoaXMuZ2V0TW9udGhDb250ZW50KG0pKSk7IH0pKSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJRdWFydGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgcXVhcnRlcnMgPSBbMSwgMiwgMywgNF07XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fcXVhcnRlci13cmFwcGVyXCIgfSwgcXVhcnRlcnMubWFwKGZ1bmN0aW9uIChxLCBqKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogaiwgcmVmOiBfdGhpcy5RVUFSVEVSX1JFRlNbal0sIHJvbGU6IFwib3B0aW9uXCIsIG9uQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblF1YXJ0ZXJDbGljayhldmVudCwgcSk7XG4gICAgICAgICAgICAgICAgfSwgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25RdWFydGVyS2V5RG93bihldmVudCwgcSk7XG4gICAgICAgICAgICAgICAgfSwgb25Nb3VzZUVudGVyOiAhX3RoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50XG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25RdWFydGVyTW91c2VFbnRlcihxKTsgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgb25Qb2ludGVyRW50ZXI6IF90aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uUXVhcnRlck1vdXNlRW50ZXIocSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIGNsYXNzTmFtZTogX3RoaXMuZ2V0UXVhcnRlckNsYXNzTmFtZXMocSksIFwiYXJpYS1zZWxlY3RlZFwiOiBzZWxlY3RlZCA/IF90aGlzLmlzU2VsZWN0ZWRRdWFydGVyKGRheSwgcSwgc2VsZWN0ZWQpIDogdW5kZWZpbmVkLCB0YWJJbmRleDogTnVtYmVyKF90aGlzLmdldFF1YXJ0ZXJUYWJJbmRleChxKSksIFwiYXJpYS1jdXJyZW50XCI6IF90aGlzLmlzQ3VycmVudFF1YXJ0ZXIoZGF5LCBxKSA/IFwiZGF0ZVwiIDogdW5kZWZpbmVkIH0sIF90aGlzLmdldFF1YXJ0ZXJDb250ZW50KHEpKSk7IH0pKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldENsYXNzTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgc2VsZWN0aW5nRGF0ZSA9IF9hLnNlbGVjdGluZ0RhdGUsIHNlbGVjdHNTdGFydCA9IF9hLnNlbGVjdHNTdGFydCwgc2VsZWN0c0VuZCA9IF9hLnNlbGVjdHNFbmQsIHNob3dNb250aFllYXJQaWNrZXIgPSBfYS5zaG93TW9udGhZZWFyUGlja2VyLCBzaG93UXVhcnRlclllYXJQaWNrZXIgPSBfYS5zaG93UXVhcnRlclllYXJQaWNrZXIsIHNob3dXZWVrUGlja2VyID0gX2Euc2hvd1dlZWtQaWNrZXI7XG4gICAgICAgICAgICByZXR1cm4gY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoXCIsIHtcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLS1zZWxlY3RpbmctcmFuZ2VcIjogc2VsZWN0aW5nRGF0ZSAmJiAoc2VsZWN0c1N0YXJ0IHx8IHNlbGVjdHNFbmQpLFxuICAgICAgICAgICAgfSwgeyBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoUGlja2VyXCI6IHNob3dNb250aFllYXJQaWNrZXIgfSwgeyBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXJQaWNrZXJcIjogc2hvd1F1YXJ0ZXJZZWFyUGlja2VyIH0sIHsgXCJyZWFjdC1kYXRlcGlja2VyX193ZWVrUGlja2VyXCI6IHNob3dXZWVrUGlja2VyIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vbnRoLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQsIHNlbGVjdGVkRGF0ZXMgPSBfYS5zZWxlY3RlZERhdGVzLCBzZWxlY3RzTXVsdGlwbGUgPSBfYS5zZWxlY3RzTXVsdGlwbGU7XG4gICAgICAgIGlmIChzZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZERhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzZWxlY3RlZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIE1vbnRoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNob3dNb250aFllYXJQaWNrZXIgPSBfYS5zaG93TW9udGhZZWFyUGlja2VyLCBzaG93UXVhcnRlclllYXJQaWNrZXIgPSBfYS5zaG93UXVhcnRlclllYXJQaWNrZXIsIGRheSA9IF9hLmRheSwgX2IgPSBfYS5hcmlhTGFiZWxQcmVmaXgsIGFyaWFMYWJlbFByZWZpeCA9IF9iID09PSB2b2lkIDAgPyBcIk1vbnRoIFwiIDogX2I7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRBcmlhTGFiZWxQcmVmaXggPSBhcmlhTGFiZWxQcmVmaXhcbiAgICAgICAgICAgID8gYXJpYUxhYmVsUHJlZml4LnRyaW0oKSArIFwiIFwiXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIC8vIEZvcm1hdCBhcmlhLWxhYmVsLCByZXR1cm4gZW1wdHkgc3RyaW5nIGlmIGRhdGUgaXMgaW52YWxpZFxuICAgICAgICB2YXIgZm9ybWF0dGVkQXJpYUxhYmVsID0gaXNWYWxpZChkYXkpXG4gICAgICAgICAgICA/IFwiXCIuY29uY2F0KGZvcm1hdHRlZEFyaWFMYWJlbFByZWZpeCkuY29uY2F0KGZvcm1hdERhdGUoZGF5LCBcIk1NTU0sIHl5eXlcIiwgdGhpcy5wcm9wcy5sb2NhbGUpKVxuICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB2YXIgc2hvdWxkVXNlTGlzdGJveFJvbGUgPSBzaG93TW9udGhZZWFyUGlja2VyIHx8IHNob3dRdWFydGVyWWVhclBpY2tlcjtcbiAgICAgICAgaWYgKHNob3VsZFVzZUxpc3Rib3hSb2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lcygpLCBvbk1vdXNlTGVhdmU6ICF0aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudCA/IHRoaXMuaGFuZGxlTW91c2VMZWF2ZSA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IHRoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50ID8gdGhpcy5oYW5kbGVNb3VzZUxlYXZlIDogdW5kZWZpbmVkLCBcImFyaWEtbGFiZWxcIjogZm9ybWF0dGVkQXJpYUxhYmVsLCByb2xlOiBcImxpc3Rib3hcIiB9LCBzaG93TW9udGhZZWFyUGlja2VyID8gdGhpcy5yZW5kZXJNb250aHMoKSA6IHRoaXMucmVuZGVyUXVhcnRlcnMoKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciByZWd1bGFyIGNhbGVuZGFyIHZpZXcsIHVzZSB0YWJsZSBzdHJ1Y3R1cmVcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcm9sZTogXCJ0YWJsZVwiIH0sXG4gICAgICAgICAgICB0aGlzLnByb3BzLmRheU5hbWVzSGVhZGVyICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcm9sZTogXCJyb3dncm91cFwiIH0sIHRoaXMucHJvcHMuZGF5TmFtZXNIZWFkZXIpKSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMubW9udGhIZWFkZXIgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByb2xlOiBcInJvd2dyb3VwXCIgfSwgdGhpcy5wcm9wcy5tb250aEhlYWRlcikpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogdGhpcy5nZXRDbGFzc05hbWVzKCksIG9uTW91c2VMZWF2ZTogIXRoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50ID8gdGhpcy5oYW5kbGVNb3VzZUxlYXZlIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogdGhpcy5wcm9wcy51c2VQb2ludGVyRXZlbnQgPyB0aGlzLmhhbmRsZU1vdXNlTGVhdmUgOiB1bmRlZmluZWQsIFwiYXJpYS1sYWJlbFwiOiBmb3JtYXR0ZWRBcmlhTGFiZWwsIHJvbGU6IFwicm93Z3JvdXBcIiB9LCB0aGlzLnJlbmRlcldlZWtzKCkpLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5tb250aEZvb3RlciAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJvbGU6IFwicm93Z3JvdXBcIiB9LCB0aGlzLnByb3BzLm1vbnRoRm9vdGVyKSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBNb250aDtcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBNb250aERyb3Bkb3duT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9udGhEcm9wZG93bk9wdGlvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9udGhEcm9wZG93bk9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tb250aE9wdGlvbkJ1dHRvbnNSZWYgPSB7fTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZE1vbnRoID0gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIF90aGlzLnByb3BzLm1vbnRoID09PSBpOyB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVPcHRpb25LZXlEb3duID0gZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkNoYW5nZShpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVzY2FwZVwiOlxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld01vbnRoID0gKGkgKyAoZS5rZXkgPT09IFwiQXJyb3dVcFwiID8gLTEgOiAxKSArIF90aGlzLnByb3BzLm1vbnRoTmFtZXMubGVuZ3RoKSAlXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5tb250aE5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMubW9udGhPcHRpb25CdXR0b25zUmVmW25ld01vbnRoXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHJlZnMgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgb24gcmUtcmVuZGVyXG4gICAgICAgICAgICBfdGhpcy5tb250aE9wdGlvbkJ1dHRvbnNSZWYgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5tb250aE5hbWVzLm1hcChmdW5jdGlvbiAobW9udGgsIGkpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubW9udGhPcHRpb25CdXR0b25zUmVmW2ldID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1NlbGVjdGVkTW9udGgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcm9sZTogXCJidXR0b25cIiwgdGFiSW5kZXg6IDAsIGNsYXNzTmFtZTogX3RoaXMuaXNTZWxlY3RlZE1vbnRoKGkpXG4gICAgICAgICAgICAgICAgICAgID8gXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC1vcHRpb24gcmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtb3B0aW9uLS1zZWxlY3RlZF9tb250aFwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC1vcHRpb25cIiwga2V5OiBtb250aCwgb25DbGljazogX3RoaXMub25DaGFuZ2UuYmluZChfdGhpcywgaSksIG9uS2V5RG93bjogX3RoaXMuaGFuZGxlT3B0aW9uS2V5RG93bi5iaW5kKF90aGlzLCBpKSwgXCJhcmlhLXNlbGVjdGVkXCI6IF90aGlzLmlzU2VsZWN0ZWRNb250aChpKSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNTZWxlY3RlZE1vbnRoKGkpID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLW9wdGlvbi0tc2VsZWN0ZWRcIiB9LCBcIlxcdTI3MTNcIikpIDogKFwiXCIpLFxuICAgICAgICAgICAgICAgIG1vbnRoKSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChtb250aCkgeyByZXR1cm4gX3RoaXMucHJvcHMub25DaGFuZ2UobW9udGgpOyB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm9wcy5vbkNhbmNlbCgpOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vbnRoRHJvcGRvd25PcHRpb25zLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDbGlja091dHNpZGVXcmFwcGVyLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC1kcm9wZG93blwiLCBvbkNsaWNrT3V0c2lkZTogdGhpcy5oYW5kbGVDbGlja091dHNpZGUgfSwgdGhpcy5yZW5kZXJPcHRpb25zKCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBNb250aERyb3Bkb3duT3B0aW9ucztcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBNb250aERyb3Bkb3duID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb250aERyb3Bkb3duLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbnRoRHJvcGRvd24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRyb3Bkb3duVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclNlbGVjdE9wdGlvbnMgPSBmdW5jdGlvbiAobW9udGhOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnRoTmFtZXMubWFwKGZ1bmN0aW9uIChtLCBpKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IGtleTogbSwgdmFsdWU6IGkgfSwgbSkpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2VsZWN0TW9kZSA9IGZ1bmN0aW9uIChtb250aE5hbWVzKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCB7IHZhbHVlOiBfdGhpcy5wcm9wcy5tb250aCwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXNlbGVjdFwiLCBvbkNoYW5nZTogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLm9uQ2hhbmdlKHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKSk7IH0gfSwgX3RoaXMucmVuZGVyU2VsZWN0T3B0aW9ucyhtb250aE5hbWVzKSkpOyB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJSZWFkVmlldyA9IGZ1bmN0aW9uICh2aXNpYmxlLCBtb250aE5hbWVzKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IGtleTogXCJyZWFkXCIsIHR5cGU6IFwiYnV0dG9uXCIsIHN0eWxlOiB7IHZpc2liaWxpdHk6IHZpc2libGUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIgfSwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXJlYWQtdmlld1wiLCBvbkNsaWNrOiBfdGhpcy50b2dnbGVEcm9wZG93biB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtcmVhZC12aWV3LS1kb3duLWFycm93XCIgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC1yZWFkLXZpZXctLXNlbGVjdGVkLW1vbnRoXCIgfSwgbW9udGhOYW1lc1tfdGhpcy5wcm9wcy5tb250aF0pKSk7IH07XG4gICAgICAgIF90aGlzLnJlbmRlckRyb3Bkb3duID0gZnVuY3Rpb24gKG1vbnRoTmFtZXMpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1vbnRoRHJvcGRvd25PcHRpb25zLCBfYXNzaWduKHsga2V5OiBcImRyb3Bkb3duXCIgfSwgX3RoaXMucHJvcHMsIHsgbW9udGhOYW1lczogbW9udGhOYW1lcywgb25DaGFuZ2U6IF90aGlzLm9uQ2hhbmdlLCBvbkNhbmNlbDogX3RoaXMudG9nZ2xlRHJvcGRvd24gfSkpKTsgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2Nyb2xsTW9kZSA9IGZ1bmN0aW9uIChtb250aE5hbWVzKSB7XG4gICAgICAgICAgICB2YXIgZHJvcGRvd25WaXNpYmxlID0gX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtfdGhpcy5yZW5kZXJSZWFkVmlldyghZHJvcGRvd25WaXNpYmxlLCBtb250aE5hbWVzKV07XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQoX3RoaXMucmVuZGVyRHJvcGRvd24obW9udGhOYW1lcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgICAgIF90aGlzLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgICAgICAgICBpZiAobW9udGggIT09IF90aGlzLnByb3BzLm1vbnRoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UobW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50b2dnbGVEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25WaXNpYmxlOiAhX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9udGhEcm9wZG93bi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbW9udGhOYW1lcyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdLm1hcCh0aGlzLnByb3BzLnVzZVNob3J0TW9udGhJbkRyb3Bkb3duXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChtKSB7IHJldHVybiBnZXRNb250aFNob3J0SW5Mb2NhbGUobSwgX3RoaXMucHJvcHMubG9jYWxlKTsgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAobSkgeyByZXR1cm4gZ2V0TW9udGhJbkxvY2FsZShtLCBfdGhpcy5wcm9wcy5sb2NhbGUpOyB9KTtcbiAgICAgICAgdmFyIHJlbmRlcmVkRHJvcGRvd247XG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5kcm9wZG93bk1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICAgICAgICByZW5kZXJlZERyb3Bkb3duID0gdGhpcy5yZW5kZXJTY3JvbGxNb2RlKG1vbnRoTmFtZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNlbGVjdE1vZGUobW9udGhOYW1lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLWRyb3Bkb3duLWNvbnRhaW5lciByZWFjdC1kYXRlcGlja2VyX19tb250aC1kcm9wZG93bi1jb250YWluZXItLVwiLmNvbmNhdCh0aGlzLnByb3BzLmRyb3Bkb3duTW9kZSkgfSwgcmVuZGVyZWREcm9wZG93bikpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vbnRoRHJvcGRvd247XG59KENvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZU1vbnRoWWVhcnMobWluRGF0ZSwgbWF4RGF0ZSkge1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgdmFyIGN1cnJEYXRlID0gZ2V0U3RhcnRPZk1vbnRoKG1pbkRhdGUpO1xuICAgIHZhciBsYXN0RGF0ZSA9IGdldFN0YXJ0T2ZNb250aChtYXhEYXRlKTtcbiAgICB3aGlsZSAoIWlzQWZ0ZXIoY3VyckRhdGUsIGxhc3REYXRlKSkge1xuICAgICAgICBsaXN0LnB1c2gobmV3RGF0ZShjdXJyRGF0ZSkpO1xuICAgICAgICBjdXJyRGF0ZSA9IGFkZE1vbnRocyhjdXJyRGF0ZSwgMSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxudmFyIE1vbnRoWWVhckRyb3Bkb3duT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9udGhZZWFyRHJvcGRvd25PcHRpb25zLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbnRoWWVhckRyb3Bkb3duT3B0aW9ucyhwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVuZGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdGF0ZS5tb250aFllYXJzTGlzdC5tYXAoZnVuY3Rpb24gKG1vbnRoWWVhcikge1xuICAgICAgICAgICAgICAgIHZhciBtb250aFllYXJQb2ludCA9IGdldFRpbWUobW9udGhZZWFyKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNTYW1lTW9udGhZZWFyID0gaXNTYW1lWWVhcihfdGhpcy5wcm9wcy5kYXRlLCBtb250aFllYXIpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzU2FtZU1vbnRoKF90aGlzLnByb3BzLmRhdGUsIG1vbnRoWWVhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBpc1NhbWVNb250aFllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLW9wdGlvbi0tc2VsZWN0ZWRfbW9udGgteWVhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1vcHRpb25cIiwga2V5OiBtb250aFllYXJQb2ludCwgb25DbGljazogX3RoaXMub25DaGFuZ2UuYmluZChfdGhpcywgbW9udGhZZWFyUG9pbnQpLCBcImFyaWEtc2VsZWN0ZWRcIjogaXNTYW1lTW9udGhZZWFyID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNTYW1lTW9udGhZZWFyID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItb3B0aW9uLS1zZWxlY3RlZFwiIH0sIFwiXFx1MjcxM1wiKSkgOiAoXCJcIiksXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdERhdGUobW9udGhZZWFyLCBfdGhpcy5wcm9wcy5kYXRlRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAobW9udGhZZWFyKSB7IHJldHVybiBfdGhpcy5wcm9wcy5vbkNoYW5nZShtb250aFllYXIpOyB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNhbmNlbCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG1vbnRoWWVhcnNMaXN0OiBnZW5lcmF0ZU1vbnRoWWVhcnMoX3RoaXMucHJvcHMubWluRGF0ZSwgX3RoaXMucHJvcHMubWF4RGF0ZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9udGhZZWFyRHJvcGRvd25PcHRpb25zLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkcm9wZG93bkNsYXNzID0gY2xzeCh7XG4gICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItZHJvcGRvd25cIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1kcm9wZG93bi0tc2Nyb2xsYWJsZVwiOiB0aGlzLnByb3BzLnNjcm9sbGFibGVNb250aFllYXJEcm9wZG93bixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDbGlja091dHNpZGVXcmFwcGVyLCB7IGNsYXNzTmFtZTogZHJvcGRvd25DbGFzcywgb25DbGlja091dHNpZGU6IHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlIH0sIHRoaXMucmVuZGVyT3B0aW9ucygpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGhZZWFyRHJvcGRvd25PcHRpb25zO1xufShDb21wb25lbnQpKTtcblxudmFyIE1vbnRoWWVhckRyb3Bkb3duID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb250aFllYXJEcm9wZG93biwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb250aFllYXJEcm9wZG93bigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZHJvcGRvd25WaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2VsZWN0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyRGF0ZSA9IGdldFN0YXJ0T2ZNb250aChfdGhpcy5wcm9wcy5taW5EYXRlKTtcbiAgICAgICAgICAgIHZhciBsYXN0RGF0ZSA9IGdldFN0YXJ0T2ZNb250aChfdGhpcy5wcm9wcy5tYXhEYXRlKTtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gW107XG4gICAgICAgICAgICB3aGlsZSAoIWlzQWZ0ZXIoY3VyckRhdGUsIGxhc3REYXRlKSkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lUG9pbnQgPSBnZXRUaW1lKGN1cnJEYXRlKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IGtleTogdGltZVBvaW50LCB2YWx1ZTogdGltZVBvaW50IH0sIGZvcm1hdERhdGUoY3VyckRhdGUsIF90aGlzLnByb3BzLmRhdGVGb3JtYXQsIF90aGlzLnByb3BzLmxvY2FsZSkpKTtcbiAgICAgICAgICAgICAgICBjdXJyRGF0ZSA9IGFkZE1vbnRocyhjdXJyRGF0ZSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25TZWxlY3RDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlKHBhcnNlSW50KGV2ZW50LnRhcmdldC52YWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJTZWxlY3RNb2RlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgeyB2YWx1ZTogZ2V0VGltZShnZXRTdGFydE9mTW9udGgoX3RoaXMucHJvcHMuZGF0ZSkpLCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1zZWxlY3RcIiwgb25DaGFuZ2U6IF90aGlzLm9uU2VsZWN0Q2hhbmdlIH0sIF90aGlzLnJlbmRlclNlbGVjdE9wdGlvbnMoKSkpOyB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJSZWFkVmlldyA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB2YXIgeWVhck1vbnRoID0gZm9ybWF0RGF0ZShfdGhpcy5wcm9wcy5kYXRlLCBfdGhpcy5wcm9wcy5kYXRlRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcInJlYWRcIiwgc3R5bGU6IHsgdmlzaWJpbGl0eTogdmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIiB9LCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1yZWFkLXZpZXdcIiwgb25DbGljazogX3RoaXMudG9nZ2xlRHJvcGRvd24gfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLXJlYWQtdmlldy0tZG93bi1hcnJvd1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItcmVhZC12aWV3LS1zZWxlY3RlZC1tb250aC15ZWFyXCIgfSwgeWVhck1vbnRoKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJEcm9wZG93biA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1vbnRoWWVhckRyb3Bkb3duT3B0aW9ucywgX2Fzc2lnbih7IGtleTogXCJkcm9wZG93blwiIH0sIF90aGlzLnByb3BzLCB7IG9uQ2hhbmdlOiBfdGhpcy5vbkNoYW5nZSwgb25DYW5jZWw6IF90aGlzLnRvZ2dsZURyb3Bkb3duIH0pKSk7IH07XG4gICAgICAgIF90aGlzLnJlbmRlclNjcm9sbE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHJvcGRvd25WaXNpYmxlID0gX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtfdGhpcy5yZW5kZXJSZWFkVmlldyghZHJvcGRvd25WaXNpYmxlKV07XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQoX3RoaXMucmVuZGVyRHJvcGRvd24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChtb250aFllYXJQb2ludCkge1xuICAgICAgICAgICAgX3RoaXMudG9nZ2xlRHJvcGRvd24oKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkRGF0ZSA9IG5ld0RhdGUobW9udGhZZWFyUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGlzU2FtZVllYXIoX3RoaXMucHJvcHMuZGF0ZSwgY2hhbmdlZERhdGUpICYmXG4gICAgICAgICAgICAgICAgaXNTYW1lTW9udGgoX3RoaXMucHJvcHMuZGF0ZSwgY2hhbmdlZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoY2hhbmdlZERhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50b2dnbGVEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25WaXNpYmxlOiAhX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9udGhZZWFyRHJvcGRvd24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkRHJvcGRvd247XG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5kcm9wZG93bk1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICAgICAgICByZW5kZXJlZERyb3Bkb3duID0gdGhpcy5yZW5kZXJTY3JvbGxNb2RlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgICAgICAgcmVuZGVyZWREcm9wZG93biA9IHRoaXMucmVuZGVyU2VsZWN0TW9kZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLWRyb3Bkb3duLWNvbnRhaW5lciByZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLWRyb3Bkb3duLWNvbnRhaW5lci0tXCIuY29uY2F0KHRoaXMucHJvcHMuZHJvcGRvd25Nb2RlKSB9LCByZW5kZXJlZERyb3Bkb3duKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGhZZWFyRHJvcGRvd247XG59KENvbXBvbmVudCkpO1xuXG52YXIgVGltZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNjcm9sbFRvVGhlU2VsZWN0ZWRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmxpc3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBfdGhpcy5saXN0LnNjcm9sbFRvcCA9XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IChfdGhpcy5jZW50ZXJMaSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgVGltZS5jYWxjQ2VudGVyUG9zaXRpb24oX3RoaXMucHJvcHMubW9udGhSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLm1vbnRoUmVmLmNsaWVudEhlaWdodCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSAoX2EgPSBfdGhpcy5oZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGllbnRIZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5saXN0LmNsaWVudEhlaWdodCwgX3RoaXMuY2VudGVyTGkpKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCgoX3RoaXMucHJvcHMubWluVGltZSB8fCBfdGhpcy5wcm9wcy5tYXhUaW1lKSAmJlxuICAgICAgICAgICAgICAgIGlzVGltZUluRGlzYWJsZWRSYW5nZSh0aW1lLCBfdGhpcy5wcm9wcykpIHx8XG4gICAgICAgICAgICAgICAgKChfdGhpcy5wcm9wcy5leGNsdWRlVGltZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuaW5jbHVkZVRpbWVzIHx8XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmZpbHRlclRpbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVGltZURpc2FibGVkKHRpbWUsIF90aGlzLnByb3BzKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25DaGFuZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnNlbGVjdGVkICYmIGlzU2FtZU1pbnV0ZShfdGhpcy5wcm9wcy5zZWxlY3RlZCwgdGltZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzRGlzYWJsZWRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKF90aGlzLnByb3BzLm1pblRpbWUgfHwgX3RoaXMucHJvcHMubWF4VGltZSkgJiZcbiAgICAgICAgICAgICAgICBpc1RpbWVJbkRpc2FibGVkUmFuZ2UodGltZSwgX3RoaXMucHJvcHMpKSB8fFxuICAgICAgICAgICAgICAgICgoX3RoaXMucHJvcHMuZXhjbHVkZVRpbWVzIHx8XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmluY2x1ZGVUaW1lcyB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5maWx0ZXJUaW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1RpbWVEaXNhYmxlZCh0aW1lLCBfdGhpcy5wcm9wcykpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5saUNsYXNzZXMgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3QtaXRlbVwiLFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnRpbWVDbGFzc05hbWUgPyBfdGhpcy5wcm9wcy50aW1lQ2xhc3NOYW1lKHRpbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc1NlbGVjdGVkVGltZSh0aW1lKSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtbGlzdC1pdGVtLS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0Rpc2FibGVkVGltZSh0aW1lKSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtbGlzdC1pdGVtLS1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29udmVydCB0aGlzLnByb3BzLmludGVydmFscyBhbmQgdGhlIHJlbGV2YW50IHRpbWUgdG8gc2Vjb25kcyBhbmQgY2hlY2sgaWYgaXQgaXQncyBhIGNsZWFuIG11bHRpcGxlIG9mIHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmluamVjdFRpbWVzICYmXG4gICAgICAgICAgICAgICAgKGdldEhvdXJzKHRpbWUpICogMzYwMCArIGdldE1pbnV0ZXModGltZSkgKiA2MCArIGdldFNlY29uZHModGltZSkpICVcbiAgICAgICAgICAgICAgICAgICAgKCgoX2EgPSBfdGhpcy5wcm9wcy5pbnRlcnZhbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFRpbWUuZGVmYXVsdFByb3BzLmludGVydmFscykgKiA2MCkgIT09XG4gICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3QtaXRlbS0taW5qZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlT25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50LCB0aW1lKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gS2V5VHlwZS5TcGFjZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQua2V5ID0gS2V5VHlwZS5FbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQua2V5ID09PSBLZXlUeXBlLkFycm93VXAgfHwgZXZlbnQua2V5ID09PSBLZXlUeXBlLkFycm93TGVmdCkgJiZcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5wcmV2aW91c1NpYmxpbmcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQucHJldmlvdXNTaWJsaW5nLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGV2ZW50LmtleSA9PT0gS2V5VHlwZS5BcnJvd0Rvd24gfHwgZXZlbnQua2V5ID09PSBLZXlUeXBlLkFycm93UmlnaHQpICYmXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gS2V5VHlwZS5FbnRlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsaWNrKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLmhhbmRsZU9uS2V5RG93bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyVGltZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgdGltZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSB0eXBlb2YgX3RoaXMucHJvcHMuZm9ybWF0ID09PSBcInN0cmluZ1wiID8gX3RoaXMucHJvcHMuZm9ybWF0IDogXCJwXCI7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxzID0gKF9hID0gX3RoaXMucHJvcHMuaW50ZXJ2YWxzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBUaW1lLmRlZmF1bHRQcm9wcy5pbnRlcnZhbHM7XG4gICAgICAgICAgICB2YXIgYWN0aXZlRGF0ZSA9IF90aGlzLnByb3BzLnNlbGVjdGVkIHx8IF90aGlzLnByb3BzLm9wZW5Ub0RhdGUgfHwgbmV3RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBnZXRTdGFydE9mRGF5KGFjdGl2ZURhdGUpO1xuICAgICAgICAgICAgdmFyIHNvcnRlZEluamVjdFRpbWVzID0gX3RoaXMucHJvcHMuaW5qZWN0VGltZXMgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5pbmplY3RUaW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXNJbkRheSA9IDYwICogZ2V0SG91cnNJbkRheShhY3RpdmVEYXRlKTtcbiAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gbWludXRlc0luRGF5IC8gaW50ZXJ2YWxzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aXBsaWVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBhZGRNaW51dGVzKGJhc2UsIGkgKiBpbnRlcnZhbHMpO1xuICAgICAgICAgICAgICAgIHRpbWVzLnB1c2goY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmplY3RUaW1lcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXNUb0luamVjdCA9IHRpbWVzVG9JbmplY3RBZnRlcihiYXNlLCBjdXJyZW50VGltZSwgaSwgaW50ZXJ2YWxzLCBzb3J0ZWRJbmplY3RUaW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzID0gdGltZXMuY29uY2F0KHRpbWVzVG9JbmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCB0aW1lIHRvIGZvY3VzIGFuZCBzY3JvbGwgaW50byB2aWV3IHdoZW4gY29tcG9uZW50IG1vdW50c1xuICAgICAgICAgICAgdmFyIHRpbWVUb0ZvY3VzID0gdGltZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUuZ2V0VGltZSgpIDw9IGFjdGl2ZURhdGUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgIH0sIHRpbWVzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcy5tYXAoZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IGtleTogdGltZS52YWx1ZU9mKCksIG9uQ2xpY2s6IF90aGlzLmhhbmRsZUNsaWNrLmJpbmQoX3RoaXMsIHRpbWUpLCBjbGFzc05hbWU6IF90aGlzLmxpQ2xhc3Nlcyh0aW1lKSwgcmVmOiBmdW5jdGlvbiAobGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID09PSB0aW1lVG9Gb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNlbnRlckxpID0gbGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIG9uS2V5RG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVPbktleURvd24oZXZlbnQsIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0YWJJbmRleDogdGltZSA9PT0gdGltZVRvRm9jdXMgPyAwIDogLTEsIHJvbGU6IFwib3B0aW9uXCIsIFwiYXJpYS1zZWxlY3RlZFwiOiBfdGhpcy5pc1NlbGVjdGVkVGltZSh0aW1lKSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkLCBcImFyaWEtZGlzYWJsZWRcIjogX3RoaXMuaXNEaXNhYmxlZFRpbWUodGltZSkgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9LCBmb3JtYXREYXRlKHRpbWUsIGZvcm1hdCwgX3RoaXMucHJvcHMubG9jYWxlKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclRpbWVDYXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dUaW1lQ2FwdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyIHJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlci0tdGltZSBcIi5jb25jYXQoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5XG4gICAgICAgICAgICAgICAgICAgID8gXCJyZWFjdC1kYXRlcGlja2VyX19oZWFkZXItLXRpbWUtLW9ubHlcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpLCByZWY6IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXItdGltZV9faGVhZGVyXCIgfSwgX3RoaXMucHJvcHMudGltZUNhcHRpb24pKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWUsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVydmFsczogMzAsXG4gICAgICAgICAgICAgICAgdG9kYXlCdXR0b246IG51bGwsXG4gICAgICAgICAgICAgICAgdGltZUNhcHRpb246IFwiVGltZVwiLFxuICAgICAgICAgICAgICAgIHNob3dUaW1lQ2FwdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUaW1lLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29kZSB0byBlbnN1cmUgc2VsZWN0ZWQgdGltZSB3aWxsIGFsd2F5cyBiZSBpbiBmb2N1cyB3aXRoaW4gdGltZSB3aW5kb3cgd2hlbiBpdCBmaXJzdCBhcHBlYXJzXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9UaGVTZWxlY3RlZFRpbWUoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlRGF0ZVBpY2tlckhlaWdodENoYW5nZXMoKTtcbiAgICB9O1xuICAgIFRpbWUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMucmVzaXplT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgICBUaW1lLnByb3RvdHlwZS5vYnNlcnZlRGF0ZVBpY2tlckhlaWdodENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb250aFJlZiA9IHRoaXMucHJvcHMubW9udGhSZWY7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgIGlmIChtb250aFJlZikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShtb250aFJlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWUucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lckhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubW9udGhSZWYgJiYgdGhpcy5oZWFkZXIpIHtcbiAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSB0aGlzLnByb3BzLm1vbnRoUmVmLmNsaWVudEhlaWdodCAtIHRoaXMuaGVhZGVyLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHN0YXRlIGlmIGhlaWdodCBhY3R1YWxseSBjaGFuZ2VkIHRvIHByZXZlbnQgaW5maW5pdGUgcmVzaXplIGxvb3BzXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnN0YXRlLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtY29udGFpbmVyIFwiLmNvbmNhdCgoKF9hID0gdGhpcy5wcm9wcy50b2RheUJ1dHRvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVGltZS5kZWZhdWx0UHJvcHMudG9kYXlCdXR0b24pXG4gICAgICAgICAgICAgICAgPyBcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtY29udGFpbmVyLS13aXRoLXRvZGF5LWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgOiBcIlwiKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUaW1lQ2FwdGlvbigpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX190aW1lXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtYm94XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtbGlzdFwiLCByZWY6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdCA9IGxpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBzdHlsZTogaGVpZ2h0ID8geyBoZWlnaHQ6IGhlaWdodCB9IDoge30sIHJvbGU6IFwibGlzdGJveFwiLCBcImFyaWEtbGFiZWxcIjogdGhpcy5wcm9wcy50aW1lQ2FwdGlvbiB9LCB0aGlzLnJlbmRlclRpbWVzKCkpKSkpKTtcbiAgICB9O1xuICAgIFRpbWUuY2FsY0NlbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKGxpc3RIZWlnaHQsIGNlbnRlckxpUmVmKSB7XG4gICAgICAgIHJldHVybiAoY2VudGVyTGlSZWYub2Zmc2V0VG9wIC0gKGxpc3RIZWlnaHQgLyAyIC0gY2VudGVyTGlSZWYuY2xpZW50SGVpZ2h0IC8gMikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWU7XG59KENvbXBvbmVudCkpO1xuXG52YXIgVkVSVElDQUxfTkFWSUdBVElPTl9PRkZTRVQgPSAzO1xuLyoqXG4gKiBgWWVhcmAgaXMgYSBjb21wb25lbnQgdGhhdCByZXByZXNlbnRzIGEgeWVhciBpbiBhIGRhdGUgcGlja2VyLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtZZWFyUHJvcHN9IHByb3BzIC0gVGhlIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgdGhlIGBZZWFyYCBjb21wb25lbnQuXG4gKiBAcHJvcGVydHkge1ZvaWRGdW5jdGlvbn0gW3Byb3BzLmNsZWFyU2VsZWN0aW5nRGF0ZV0gLSBGdW5jdGlvbiB0byBjbGVhciB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAqIEBwcm9wZXJ0eSB7RGF0ZX0gW3Byb3BzLmRhdGVdIC0gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb25dIC0gSWYgdHJ1ZSwga2V5Ym9hcmQgbmF2aWdhdGlvbiBpcyBkaXNhYmxlZC5cbiAqIEBwcm9wZXJ0eSB7RGF0ZX0gW3Byb3BzLmVuZERhdGVdIC0gVGhlIGVuZCBkYXRlIGluIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICogQHByb3BlcnR5IHsoZGF0ZTogRGF0ZSkgPT4gdm9pZH0gcHJvcHMub25EYXlDbGljayAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBkYXkgY2xpY2sgZXZlbnRzLlxuICogQHByb3BlcnR5IHtEYXRlfSBwcm9wcy5wcmVTZWxlY3Rpb24gLSBUaGUgZGF0ZSB0aGF0IGlzIGN1cnJlbnRseSBpbiBmb2N1cy5cbiAqIEBwcm9wZXJ0eSB7KGRhdGU6IERhdGUpID0+IHZvaWR9IHByb3BzLnNldFByZVNlbGVjdGlvbiAtIEZ1bmN0aW9uIHRvIHNldCB0aGUgcHJlLXNlbGVjdGVkIGRhdGUuXG4gKiBAcHJvcGVydHkge3sgW2tleTogc3RyaW5nXTogYW55IH19IHByb3BzLnNlbGVjdGVkIC0gVGhlIHNlbGVjdGVkIGRhdGUocykuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHByb3BzLmlubGluZSAtIElmIHRydWUsIHRoZSBkYXRlIHBpY2tlciBpcyBkaXNwbGF5ZWQgaW5saW5lLlxuICogQHByb3BlcnR5IHtEYXRlfSBwcm9wcy5tYXhEYXRlIC0gVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLlxuICogQHByb3BlcnR5IHtEYXRlfSBwcm9wcy5taW5EYXRlIC0gVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBwcm9wcy51c2VQb2ludGVyRXZlbnQgLSBJZiB0cnVlLCBwb2ludGVyIGV2ZW50cyBhcmUgdXNlZCBpbnN0ZWFkIG9mIG1vdXNlIGV2ZW50cy5cbiAqIEBwcm9wZXJ0eSB7KGRhdGU6IERhdGUpID0+IHZvaWR9IHByb3BzLm9uWWVhck1vdXNlRW50ZXIgLSBGdW5jdGlvbiB0byBoYW5kbGUgbW91c2UgZW50ZXIgZXZlbnRzIG9uIGEgeWVhci5cbiAqIEBwcm9wZXJ0eSB7KGRhdGU6IERhdGUpID0+IHZvaWR9IHByb3BzLm9uWWVhck1vdXNlTGVhdmUgLSBGdW5jdGlvbiB0byBoYW5kbGUgbW91c2UgbGVhdmUgZXZlbnRzIG9uIGEgeWVhci5cbiAqL1xudmFyIFllYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFllYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWWVhcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuWUVBUl9SRUZTID0gX19zcHJlYWRBcnJheShbXSwgQXJyYXkoX3RoaXMucHJvcHMueWVhckl0ZW1OdW1iZXIpLCB0cnVlKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZigpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNEYXlEaXNhYmxlZChkYXRlLCB7XG4gICAgICAgICAgICAgICAgbWluRGF0ZTogX3RoaXMucHJvcHMubWluRGF0ZSxcbiAgICAgICAgICAgICAgICBtYXhEYXRlOiBfdGhpcy5wcm9wcy5tYXhEYXRlLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVEYXRlczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVEYXRlczogX3RoaXMucHJvcHMuaW5jbHVkZURhdGVzLFxuICAgICAgICAgICAgICAgIGZpbHRlckRhdGU6IF90aGlzLnByb3BzLmZpbHRlckRhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNFeGNsdWRlZCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNEYXlFeGNsdWRlZChkYXRlLCB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2VsZWN0aW5nRGF0ZSA9IGZ1bmN0aW9uICgpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0aW5nRGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uOyB9O1xuICAgICAgICBfdGhpcy51cGRhdGVGb2N1c09uUGFnaW5hdGUgPSBmdW5jdGlvbiAocmVmSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB3YWl0Rm9yUmVSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5ZRUFSX1JFRlNbcmVmSW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvY3VzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh3YWl0Rm9yUmVSZW5kZXIpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVZZWFyQ2xpY2sgPSBmdW5jdGlvbiAoZGF5LCBldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5Q2xpY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkRheUNsaWNrKGRheSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVZZWFyTmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChuZXdZZWFyLCBuZXdEYXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICB2YXIgX2UgPSBfdGhpcy5wcm9wcywgZGF0ZSA9IF9lLmRhdGUsIHllYXJJdGVtTnVtYmVyID0gX2UueWVhckl0ZW1OdW1iZXI7XG4gICAgICAgICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHllYXJJdGVtTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRQZXJpb2QgPSBnZXRZZWFyc1BlcmlvZChkYXRlLCB5ZWFySXRlbU51bWJlcikuc3RhcnRQZXJpb2Q7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEaXNhYmxlZChuZXdEYXRlKSB8fCBfdGhpcy5pc0V4Y2x1ZGVkKG5ld0RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLnNldFByZVNlbGVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5ld0RhdGUpO1xuICAgICAgICAgICAgaWYgKG5ld1llYXIgLSBzdGFydFBlcmlvZCA8IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVGb2N1c09uUGFnaW5hdGUoeWVhckl0ZW1OdW1iZXIgLSAoc3RhcnRQZXJpb2QgLSBuZXdZZWFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdZZWFyIC0gc3RhcnRQZXJpb2QgPj0geWVhckl0ZW1OdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVGb2N1c09uUGFnaW5hdGUoTWF0aC5hYnMoeWVhckl0ZW1OdW1iZXIgLSAobmV3WWVhciAtIHN0YXJ0UGVyaW9kKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChfZCA9IChfYyA9IF90aGlzLllFQVJfUkVGU1tuZXdZZWFyIC0gc3RhcnRQZXJpb2RdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2FtZURheSA9IGZ1bmN0aW9uICh5LCBvdGhlcikgeyByZXR1cm4gaXNTYW1lRGF5KHksIG90aGVyKTsgfTtcbiAgICAgICAgX3RoaXMuaXNDdXJyZW50WWVhciA9IGZ1bmN0aW9uICh5KSB7IHJldHVybiB5ID09PSBnZXRZZWFyKG5ld0RhdGUoKSk7IH07XG4gICAgICAgIF90aGlzLmlzUmFuZ2VTdGFydCA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc3RhcnREYXRlICYmXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuZW5kRGF0ZSAmJlxuICAgICAgICAgICAgICAgIGlzU2FtZVllYXIoc2V0WWVhcihuZXdEYXRlKCksIHkpLCBfdGhpcy5wcm9wcy5zdGFydERhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1JhbmdlRW5kID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5zdGFydERhdGUgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5lbmREYXRlICYmXG4gICAgICAgICAgICAgICAgaXNTYW1lWWVhcihzZXRZZWFyKG5ld0RhdGUoKSwgeSksIF90aGlzLnByb3BzLmVuZERhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0luUmFuZ2UgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzWWVhckluUmFuZ2UoeSwgX3RoaXMucHJvcHMuc3RhcnREYXRlLCBfdGhpcy5wcm9wcy5lbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBzZWxlY3RzU3RhcnQgPSBfYS5zZWxlY3RzU3RhcnQsIHNlbGVjdHNFbmQgPSBfYS5zZWxlY3RzRW5kLCBzZWxlY3RzUmFuZ2UgPSBfYS5zZWxlY3RzUmFuZ2UsIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGU7XG4gICAgICAgICAgICBpZiAoIShzZWxlY3RzU3RhcnQgfHwgc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHx8XG4gICAgICAgICAgICAgICAgIV90aGlzLnNlbGVjdGluZ0RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RzU3RhcnQgJiYgZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1llYXJJblJhbmdlKHksIF90aGlzLnNlbGVjdGluZ0RhdGUoKSwgZW5kRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCAmJiBzdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNZZWFySW5SYW5nZSh5LCBzdGFydERhdGUsIF90aGlzLnNlbGVjdGluZ0RhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlICYmIHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1llYXJJblJhbmdlKHksIHN0YXJ0RGF0ZSwgX3RoaXMuc2VsZWN0aW5nRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RpbmdSYW5nZVN0YXJ0ID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIHN0YXJ0RGF0ZSA9IF9iLnN0YXJ0RGF0ZSwgc2VsZWN0c1N0YXJ0ID0gX2Iuc2VsZWN0c1N0YXJ0O1xuICAgICAgICAgICAgdmFyIF95ZWFyID0gc2V0WWVhcihuZXdEYXRlKCksIHkpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdHNTdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVZZWFyKF95ZWFyLCAoX2EgPSBfdGhpcy5zZWxlY3RpbmdEYXRlKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZVllYXIoX3llYXIsIHN0YXJ0RGF0ZSAhPT0gbnVsbCAmJiBzdGFydERhdGUgIT09IHZvaWQgMCA/IHN0YXJ0RGF0ZSA6IG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGluZ1JhbmdlRW5kID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGVuZERhdGUgPSBfYi5lbmREYXRlLCBzZWxlY3RzRW5kID0gX2Iuc2VsZWN0c0VuZCwgc2VsZWN0c1JhbmdlID0gX2Iuc2VsZWN0c1JhbmdlO1xuICAgICAgICAgICAgdmFyIF95ZWFyID0gc2V0WWVhcihuZXdEYXRlKCksIHkpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdHNFbmQgfHwgc2VsZWN0c1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZVllYXIoX3llYXIsIChfYSA9IF90aGlzLnNlbGVjdGluZ0RhdGUoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lWWVhcihfeWVhciwgZW5kRGF0ZSAhPT0gbnVsbCAmJiBlbmREYXRlICE9PSB2b2lkIDAgPyBlbmREYXRlIDogbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzS2V5Ym9hcmRTZWxlY3RlZCA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24gfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5kYXRlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBtaW5EYXRlID0gX2EubWluRGF0ZSwgbWF4RGF0ZSA9IF9hLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9hLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2EuaW5jbHVkZURhdGVzLCBmaWx0ZXJEYXRlID0gX2EuZmlsdGVyRGF0ZSwgc2VsZWN0ZWQgPSBfYS5zZWxlY3RlZDtcbiAgICAgICAgICAgIHZhciBkYXRlID0gZ2V0U3RhcnRPZlllYXIoc2V0WWVhcihfdGhpcy5wcm9wcy5kYXRlLCB5KSk7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IChtaW5EYXRlIHx8IG1heERhdGUgfHwgZXhjbHVkZURhdGVzIHx8IGluY2x1ZGVEYXRlcyB8fCBmaWx0ZXJEYXRlKSAmJlxuICAgICAgICAgICAgICAgIGlzWWVhckRpc2FibGVkKHksIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBpc1NlbGVjdGVkRGF5ID0gISFzZWxlY3RlZCAmJiBpc1NhbWVEYXkoZGF0ZSwgZ2V0U3RhcnRPZlllYXIoc2VsZWN0ZWQpKTtcbiAgICAgICAgICAgIHZhciBpc0tleWJvYXJkU2VsZWN0ZWREYXkgPSBpc1NhbWVEYXkoZGF0ZSwgZ2V0U3RhcnRPZlllYXIoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4gKCFfdGhpcy5wcm9wcy5pbmxpbmUgJiZcbiAgICAgICAgICAgICAgICAhaXNTZWxlY3RlZERheSAmJlxuICAgICAgICAgICAgICAgIGlzS2V5Ym9hcmRTZWxlY3RlZERheSAmJlxuICAgICAgICAgICAgICAgICFpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZFllYXIgPSBmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHNlbGVjdHNNdWx0aXBsZSA9IF9hLnNlbGVjdHNNdWx0aXBsZSwgc2VsZWN0ZWQgPSBfYS5zZWxlY3RlZCwgc2VsZWN0ZWREYXRlcyA9IF9hLnNlbGVjdGVkRGF0ZXM7XG4gICAgICAgICAgICBpZiAoc2VsZWN0c011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkRGF0ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWREYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWREYXRlcy5zb21lKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB5ZWFyID09PSBnZXRZZWFyKGRhdGUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIXNlbGVjdGVkICYmIHllYXIgPT09IGdldFllYXIoc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblllYXJDbGljayA9IGZ1bmN0aW9uIChldmVudCwgeSkge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy5wcm9wcy5kYXRlO1xuICAgICAgICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVllYXJDbGljayhnZXRTdGFydE9mWWVhcihzZXRZZWFyKGRhdGUsIHkpKSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblllYXJLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50LCB5KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIHZhciBfYyA9IF90aGlzLnByb3BzLCBkYXRlID0gX2MuZGF0ZSwgeWVhckl0ZW1OdW1iZXIgPSBfYy55ZWFySXRlbU51bWJlciwgaGFuZGxlT25LZXlEb3duID0gX2MuaGFuZGxlT25LZXlEb3duO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gS2V5VHlwZS5UYWIpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbiB0YWIgZXZlbnQgYmxvY2tzIGZvY3VzIGNoYW5nZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkVudGVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNlbGVjdGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uWWVhckNsaWNrKGV2ZW50LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRQcmVTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBfdGhpcy5wcm9wcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93UmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVllYXJOYXZpZ2F0aW9uKHkgKyAxLCBhZGRZZWFycyhfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dMZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVZZWFyTmF2aWdhdGlvbih5IC0gMSwgc3ViWWVhcnMoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93VXA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFySXRlbU51bWJlciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFBlcmlvZCA9IGdldFllYXJzUGVyaW9kKGRhdGUsIHllYXJJdGVtTnVtYmVyKS5zdGFydFBlcmlvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBWRVJUSUNBTF9OQVZJR0FUSU9OX09GRlNFVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdZZWFyID0geSAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdZZWFyIDwgc3RhcnRQZXJpb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdE92ZXJPZmZzZXQgPSB5ZWFySXRlbU51bWJlciAlIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA+PSBzdGFydFBlcmlvZCAmJiB5IDwgc3RhcnRQZXJpb2QgKyBsZWZ0T3Zlck9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZWZ0T3Zlck9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBsZWZ0T3Zlck9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WWVhciA9IHkgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVZZWFyTmF2aWdhdGlvbihuZXdZZWFyLCBzdWJZZWFycyhfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sIG9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93RG93bjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHllYXJJdGVtTnVtYmVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFBlcmlvZCA9IGdldFllYXJzUGVyaW9kKGRhdGUsIHllYXJJdGVtTnVtYmVyKS5lbmRQZXJpb2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gVkVSVElDQUxfTkFWSUdBVElPTl9PRkZTRVQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WWVhciA9IHkgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3WWVhciA+IGVuZFBlcmlvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0T3Zlck9mZnNldCA9IHllYXJJdGVtTnVtYmVyICUgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5IDw9IGVuZFBlcmlvZCAmJiB5ID4gZW5kUGVyaW9kIC0gbGVmdE92ZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGVmdE92ZXJPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gbGVmdE92ZXJPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1llYXIgPSB5ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlWWVhck5hdmlnYXRpb24obmV3WWVhciwgYWRkWWVhcnMoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uLCBvZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlT25LZXlEb3duICYmIGhhbmRsZU9uS2V5RG93bihldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFllYXJDbGFzc05hbWVzID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXRlID0gX2EuZGF0ZSwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgbWluRGF0ZSA9IF9hLm1pbkRhdGUsIG1heERhdGUgPSBfYS5tYXhEYXRlLCBleGNsdWRlRGF0ZXMgPSBfYS5leGNsdWRlRGF0ZXMsIGluY2x1ZGVEYXRlcyA9IF9hLmluY2x1ZGVEYXRlcywgZmlsdGVyRGF0ZSA9IF9hLmZpbHRlckRhdGUsIHllYXJDbGFzc05hbWUgPSBfYS55ZWFyQ2xhc3NOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGNsc3goXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHRcIiwgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLVwiLmNvbmNhdCh5KSwgZGF0ZSA/IHllYXJDbGFzc05hbWUgPT09IG51bGwgfHwgeWVhckNsYXNzTmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogeWVhckNsYXNzTmFtZShzZXRZZWFyKGRhdGUsIHkpKSA6IHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci10ZXh0LS1zZWxlY3RlZFwiOiBfdGhpcy5pc1NlbGVjdGVkWWVhcih5KSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dC0tZGlzYWJsZWRcIjogKG1pbkRhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgbWF4RGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZURhdGVzIHx8XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckRhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzWWVhckRpc2FibGVkKHksIF90aGlzLnByb3BzKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dC0ta2V5Ym9hcmQtc2VsZWN0ZWRcIjogX3RoaXMuaXNLZXlib2FyZFNlbGVjdGVkKHkpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci10ZXh0LS1yYW5nZS1zdGFydFwiOiBfdGhpcy5pc1JhbmdlU3RhcnQoeSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHQtLXJhbmdlLWVuZFwiOiBfdGhpcy5pc1JhbmdlRW5kKHkpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci10ZXh0LS1pbi1yYW5nZVwiOiBfdGhpcy5pc0luUmFuZ2UoeSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHQtLWluLXNlbGVjdGluZy1yYW5nZVwiOiBfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2UoeSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHQtLXNlbGVjdGluZy1yYW5nZS1zdGFydFwiOiBfdGhpcy5pc1NlbGVjdGluZ1JhbmdlU3RhcnQoeSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHQtLXNlbGVjdGluZy1yYW5nZS1lbmRcIjogX3RoaXMuaXNTZWxlY3RpbmdSYW5nZUVuZCh5KSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dC0tdG9kYXlcIjogX3RoaXMuaXNDdXJyZW50WWVhcih5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRZZWFyVGFiSW5kZXggPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCItMVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZVNlbGVjdGVkID0gZ2V0WWVhcihfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGlzUHJlU2VsZWN0ZWRZZWFyRGlzYWJsZWQgPSBpc1llYXJEaXNhYmxlZCh5LCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4geSA9PT0gcHJlU2VsZWN0ZWQgJiYgIWlzUHJlU2VsZWN0ZWRZZWFyRGlzYWJsZWQgPyBcIjBcIiA6IFwiLTFcIjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0WWVhckNvbnRlbnQgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnJlbmRlclllYXJDb250ZW50ID8gX3RoaXMucHJvcHMucmVuZGVyWWVhckNvbnRlbnQoeSkgOiB5O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFllYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHllYXJzTGlzdCA9IFtdO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkYXRlID0gX2EuZGF0ZSwgeWVhckl0ZW1OdW1iZXIgPSBfYS55ZWFySXRlbU51bWJlciwgb25ZZWFyTW91c2VFbnRlciA9IF9hLm9uWWVhck1vdXNlRW50ZXIsIG9uWWVhck1vdXNlTGVhdmUgPSBfYS5vblllYXJNb3VzZUxlYXZlO1xuICAgICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2IgPSBnZXRZZWFyc1BlcmlvZChkYXRlLCB5ZWFySXRlbU51bWJlciksIHN0YXJ0UGVyaW9kID0gX2Iuc3RhcnRQZXJpb2QsIGVuZFBlcmlvZCA9IF9iLmVuZFBlcmlvZDtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgeWVhcnNMaXN0LnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpc18xLllFQVJfUkVGU1t5IC0gc3RhcnRQZXJpb2RdLCBvbkNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25ZZWFyQ2xpY2soZXZlbnQsIHkpO1xuICAgICAgICAgICAgICAgIH0sIG9uS2V5RG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NwYWNlS2V5RG93bihldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5rZXkgPSBLZXlUeXBlLkVudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uWWVhcktleURvd24oZXZlbnQsIHkpO1xuICAgICAgICAgICAgICAgIH0sIHRhYkluZGV4OiBOdW1iZXIodGhpc18xLmdldFllYXJUYWJJbmRleCh5KSksIGNsYXNzTmFtZTogdGhpc18xLmdldFllYXJDbGFzc05hbWVzKHkpLCBvbk1vdXNlRW50ZXI6ICF0aGlzXzEucHJvcHMudXNlUG9pbnRlckV2ZW50XG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBvblllYXJNb3VzZUVudGVyKGV2ZW50LCB5KTsgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgb25Qb2ludGVyRW50ZXI6IHRoaXNfMS5wcm9wcy51c2VQb2ludGVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIG9uWWVhck1vdXNlRW50ZXIoZXZlbnQsIHkpOyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvbk1vdXNlTGVhdmU6ICF0aGlzXzEucHJvcHMudXNlUG9pbnRlckV2ZW50XG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBvblllYXJNb3VzZUxlYXZlKGV2ZW50LCB5KTsgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IHRoaXNfMS5wcm9wcy51c2VQb2ludGVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIG9uWWVhck1vdXNlTGVhdmUoZXZlbnQsIHkpOyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBrZXk6IHksIFwiYXJpYS1jdXJyZW50XCI6IHRoaXNfMS5pc0N1cnJlbnRZZWFyKHkpID8gXCJkYXRlXCIgOiB1bmRlZmluZWQgfSwgdGhpc18xLmdldFllYXJDb250ZW50KHkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciB5ID0gc3RhcnRQZXJpb2Q7IHkgPD0gZW5kUGVyaW9kOyB5KyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXJcIiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXdyYXBwZXJcIiwgb25Nb3VzZUxlYXZlOiAhdGhpcy5wcm9wcy51c2VQb2ludGVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLmNsZWFyU2VsZWN0aW5nRGF0ZVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IHRoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50XG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wcm9wcy5jbGVhclNlbGVjdGluZ0RhdGVcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQgfSwgeWVhcnNMaXN0KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFllYXI7XG59KENvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVllYXJzKHllYXIsIG5vT2ZZZWFyLCBtaW5EYXRlLCBtYXhEYXRlKSB7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIgKiBub09mWWVhciArIDE7IGkrKykge1xuICAgICAgICB2YXIgbmV3WWVhciA9IHllYXIgKyBub09mWWVhciAtIGk7XG4gICAgICAgIHZhciBpc0luUmFuZ2UgPSB0cnVlO1xuICAgICAgICBpZiAobWluRGF0ZSkge1xuICAgICAgICAgICAgaXNJblJhbmdlID0gZ2V0WWVhcihtaW5EYXRlKSA8PSBuZXdZZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhEYXRlICYmIGlzSW5SYW5nZSkge1xuICAgICAgICAgICAgaXNJblJhbmdlID0gZ2V0WWVhcihtYXhEYXRlKSA+PSBuZXdZZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luUmFuZ2UpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChuZXdZZWFyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbnZhciBZZWFyRHJvcGRvd25PcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhZZWFyRHJvcGRvd25PcHRpb25zLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFllYXJEcm9wZG93bk9wdGlvbnMocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnllYXJPcHRpb25CdXR0b25zUmVmID0ge307XG4gICAgICAgIF90aGlzLmhhbmRsZU9wdGlvbktleURvd24gPSBmdW5jdGlvbiAoeWVhciwgZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlKHllYXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiRXNjYXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25DYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WWVhciA9IHllYXIgKyAoZS5rZXkgPT09IFwiQXJyb3dVcFwiID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJvdW5kcyBjaGVja2luZyB0byBlbnN1cmUgdGhlIHllYXIgZXhpc3RzIGluIG91ciByZWZzXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy55ZWFyT3B0aW9uQnV0dG9uc1JlZltuZXdZZWFyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMueWVhck9wdGlvbkJ1dHRvbnNSZWZbbmV3WWVhcl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHJlZnMgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgb24gcmUtcmVuZGVyXG4gICAgICAgICAgICBfdGhpcy55ZWFyT3B0aW9uQnV0dG9uc1JlZiA9IHt9O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkWWVhciA9IF90aGlzLnByb3BzLnllYXI7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLnN0YXRlLnllYXJzTGlzdC5tYXAoZnVuY3Rpb24gKHllYXIpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMueWVhck9wdGlvbkJ1dHRvbnNSZWZbeWVhcl0gPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHllYXIgPT09IHNlbGVjdGVkWWVhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCByb2xlOiBcImJ1dHRvblwiLCB0YWJJbmRleDogMCwgY2xhc3NOYW1lOiBzZWxlY3RlZFllYXIgPT09IHllYXJcbiAgICAgICAgICAgICAgICAgICAgPyBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uIHJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uLS1zZWxlY3RlZF95ZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uXCIsIGtleTogeWVhciwgb25DbGljazogX3RoaXMub25DaGFuZ2UuYmluZChfdGhpcywgeWVhciksIG9uS2V5RG93bjogX3RoaXMuaGFuZGxlT3B0aW9uS2V5RG93bi5iaW5kKF90aGlzLCB5ZWFyKSwgXCJhcmlhLXNlbGVjdGVkXCI6IHNlbGVjdGVkWWVhciA9PT0geWVhciA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRZZWFyID09PSB5ZWFyID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uLS1zZWxlY3RlZFwiIH0sIFwiXFx1MjcxM1wiKSkgOiAoXCJcIiksXG4gICAgICAgICAgICAgICAgeWVhcikpOyB9KTtcbiAgICAgICAgICAgIHZhciBtaW5ZZWFyID0gX3RoaXMucHJvcHMubWluRGF0ZSA/IGdldFllYXIoX3RoaXMucHJvcHMubWluRGF0ZSkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIG1heFllYXIgPSBfdGhpcy5wcm9wcy5tYXhEYXRlID8gZ2V0WWVhcihfdGhpcy5wcm9wcy5tYXhEYXRlKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW1heFllYXIgfHwgIV90aGlzLnN0YXRlLnllYXJzTGlzdC5maW5kKGZ1bmN0aW9uICh5ZWFyKSB7IHJldHVybiB5ZWFyID09PSBtYXhZZWFyOyB9KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudW5zaGlmdChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uXCIsIGtleTogXCJ1cGNvbWluZ1wiLCBvbkNsaWNrOiBfdGhpcy5pbmNyZW1lbnRZZWFycyB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uIHJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLXllYXJzIHJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLXllYXJzLXVwY29taW5nXCIgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWluWWVhciB8fCAhX3RoaXMuc3RhdGUueWVhcnNMaXN0LmZpbmQoZnVuY3Rpb24gKHllYXIpIHsgcmV0dXJuIHllYXIgPT09IG1pblllYXI7IH0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1vcHRpb25cIiwga2V5OiBcInByZXZpb3VzXCIsIG9uQ2xpY2s6IF90aGlzLmRlY3JlbWVudFllYXJzIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24gcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMgcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMtcHJldmlvdXNcIiB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKHllYXIpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNhbmNlbCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaGlmdFllYXJzID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHllYXJzID0gX3RoaXMuc3RhdGUueWVhcnNMaXN0Lm1hcChmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB5ZWFyICsgYW1vdW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgeWVhcnNMaXN0OiB5ZWFycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pbmNyZW1lbnRZZWFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaGlmdFllYXJzKDEpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kZWNyZW1lbnRZZWFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaGlmdFllYXJzKC0xKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHllYXJEcm9wZG93bkl0ZW1OdW1iZXIgPSBwcm9wcy55ZWFyRHJvcGRvd25JdGVtTnVtYmVyLCBzY3JvbGxhYmxlWWVhckRyb3Bkb3duID0gcHJvcHMuc2Nyb2xsYWJsZVllYXJEcm9wZG93bjtcbiAgICAgICAgdmFyIG5vT2ZZZWFyID0geWVhckRyb3Bkb3duSXRlbU51bWJlciB8fCAoc2Nyb2xsYWJsZVllYXJEcm9wZG93biA/IDEwIDogNSk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgeWVhcnNMaXN0OiBnZW5lcmF0ZVllYXJzKF90aGlzLnByb3BzLnllYXIsIG5vT2ZZZWFyLCBfdGhpcy5wcm9wcy5taW5EYXRlLCBfdGhpcy5wcm9wcy5tYXhEYXRlKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZHJvcGRvd25SZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBZZWFyRHJvcGRvd25PcHRpb25zLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duQ3VycmVudCA9IHRoaXMuZHJvcGRvd25SZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGRyb3Bkb3duQ3VycmVudCkge1xuICAgICAgICAgICAgLy8gR2V0IGFycmF5IGZyb20gSFRNTENvbGxlY3Rpb25cbiAgICAgICAgICAgIHZhciBkcm9wZG93bkN1cnJlbnRDaGlsZHJlbiA9IGRyb3Bkb3duQ3VycmVudC5jaGlsZHJlblxuICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShkcm9wZG93bkN1cnJlbnQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkWWVhck9wdGlvbkVsID0gZHJvcGRvd25DdXJyZW50Q2hpbGRyZW5cbiAgICAgICAgICAgICAgICA/IGRyb3Bkb3duQ3VycmVudENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKGNoaWxkRWwpIHsgcmV0dXJuIGNoaWxkRWwuYXJpYVNlbGVjdGVkOyB9KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGRyb3Bkb3duQ3VycmVudC5zY3JvbGxUb3AgPVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkWWVhck9wdGlvbkVsICYmIHNlbGVjdGVkWWVhck9wdGlvbkVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3RlZFllYXJPcHRpb25FbC5vZmZzZXRUb3AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGVkWWVhck9wdGlvbkVsLmNsaWVudEhlaWdodCAtIGRyb3Bkb3duQ3VycmVudC5jbGllbnRIZWlnaHQpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgIDogKGRyb3Bkb3duQ3VycmVudC5zY3JvbGxIZWlnaHQgLSBkcm9wZG93bkN1cnJlbnQuY2xpZW50SGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFllYXJEcm9wZG93bk9wdGlvbnMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duQ2xhc3MgPSBjbHN4KHtcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1kcm9wZG93blwiOiB0cnVlLFxuICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLWRyb3Bkb3duLS1zY3JvbGxhYmxlXCI6IHRoaXMucHJvcHMuc2Nyb2xsYWJsZVllYXJEcm9wZG93bixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDbGlja091dHNpZGVXcmFwcGVyLCB7IGNsYXNzTmFtZTogZHJvcGRvd25DbGFzcywgY29udGFpbmVyUmVmOiB0aGlzLmRyb3Bkb3duUmVmLCBvbkNsaWNrT3V0c2lkZTogdGhpcy5oYW5kbGVDbGlja091dHNpZGUgfSwgdGhpcy5yZW5kZXJPcHRpb25zKCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBZZWFyRHJvcGRvd25PcHRpb25zO1xufShDb21wb25lbnQpKTtcblxudmFyIFllYXJEcm9wZG93biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWWVhckRyb3Bkb3duLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFllYXJEcm9wZG93bigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZHJvcGRvd25WaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2VsZWN0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaW5ZZWFyID0gX3RoaXMucHJvcHMubWluRGF0ZVxuICAgICAgICAgICAgICAgID8gZ2V0WWVhcihfdGhpcy5wcm9wcy5taW5EYXRlKVxuICAgICAgICAgICAgICAgIDogMTkwMDtcbiAgICAgICAgICAgIHZhciBtYXhZZWFyID0gX3RoaXMucHJvcHMubWF4RGF0ZVxuICAgICAgICAgICAgICAgID8gZ2V0WWVhcihfdGhpcy5wcm9wcy5tYXhEYXRlKVxuICAgICAgICAgICAgICAgIDogMjEwMDtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbWluWWVhcjsgaSA8PSBtYXhZZWFyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IGtleTogaSwgdmFsdWU6IGkgfSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uU2VsZWN0Q2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5vbkNoYW5nZShwYXJzZUludChldmVudC50YXJnZXQudmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2VsZWN0TW9kZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgdmFsdWU6IF90aGlzLnByb3BzLnllYXIsIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXNlbGVjdFwiLCBvbkNoYW5nZTogX3RoaXMub25TZWxlY3RDaGFuZ2UgfSwgX3RoaXMucmVuZGVyU2VsZWN0T3B0aW9ucygpKSk7IH07XG4gICAgICAgIF90aGlzLnJlbmRlclJlYWRWaWV3ID0gZnVuY3Rpb24gKHZpc2libGUpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsga2V5OiBcInJlYWRcIiwgdHlwZTogXCJidXR0b25cIiwgc3R5bGU6IHsgdmlzaWJpbGl0eTogdmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIiB9LCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1yZWFkLXZpZXdcIiwgb25DbGljazogX3RoaXMudG9nZ2xlRHJvcGRvd24gfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItcmVhZC12aWV3LS1kb3duLWFycm93XCIgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXJlYWQtdmlldy0tc2VsZWN0ZWQteWVhclwiIH0sIF90aGlzLnByb3BzLnllYXIpKSk7IH07XG4gICAgICAgIF90aGlzLnJlbmRlckRyb3Bkb3duID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoWWVhckRyb3Bkb3duT3B0aW9ucywgX2Fzc2lnbih7IGtleTogXCJkcm9wZG93blwiIH0sIF90aGlzLnByb3BzLCB7IG9uQ2hhbmdlOiBfdGhpcy5vbkNoYW5nZSwgb25DYW5jZWw6IF90aGlzLnRvZ2dsZURyb3Bkb3duIH0pKSk7IH07XG4gICAgICAgIF90aGlzLnJlbmRlclNjcm9sbE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHJvcGRvd25WaXNpYmxlID0gX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtfdGhpcy5yZW5kZXJSZWFkVmlldyghZHJvcGRvd25WaXNpYmxlKV07XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQoX3RoaXMucmVuZGVyRHJvcGRvd24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgICAgICBfdGhpcy50b2dnbGVEcm9wZG93bigpO1xuICAgICAgICAgICAgaWYgKHllYXIgPT09IF90aGlzLnByb3BzLnllYXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoeWVhcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25WaXNpYmxlOiAhX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlLFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5hZGp1c3REYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlWWVhckNoYW5nZShfdGhpcy5wcm9wcy5kYXRlLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVllYXJDaGFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IF90aGlzLm9uU2VsZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChfdGhpcywgZGF0ZSwgZXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMuc2V0T3BlbigpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblNlbGVjdCA9IGZ1bmN0aW9uIChkYXRlLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vblNlbGVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGRhdGUsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0T3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykuc2V0T3BlbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFllYXJEcm9wZG93bi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWREcm9wZG93bjtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmRyb3Bkb3duTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNjcm9sbE1vZGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICAgICAgICByZW5kZXJlZERyb3Bkb3duID0gdGhpcy5yZW5kZXJTZWxlY3RNb2RlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItZHJvcGRvd24tY29udGFpbmVyIHJlYWN0LWRhdGVwaWNrZXJfX3llYXItZHJvcGRvd24tY29udGFpbmVyLS1cIi5jb25jYXQodGhpcy5wcm9wcy5kcm9wZG93bk1vZGUpIH0sIHJlbmRlcmVkRHJvcGRvd24pKTtcbiAgICB9O1xuICAgIHJldHVybiBZZWFyRHJvcGRvd247XG59KENvbXBvbmVudCkpO1xuXG52YXIgRFJPUERPV05fRk9DVVNfQ0xBU1NOQU1FUyA9IFtcbiAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItc2VsZWN0XCIsXG4gICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC1zZWxlY3RcIixcbiAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItc2VsZWN0XCIsXG5dO1xudmFyIE9VVFNJREVfQ0xJQ0tfSUdOT1JFX0NMQVNTID0gXCJyZWFjdC1kYXRlcGlja2VyLWlnbm9yZS1vbmNsaWNrb3V0c2lkZVwiO1xudmFyIGlzRHJvcGRvd25TZWxlY3QgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBjbGFzc05hbWVzID0gKGVsZW1lbnQuY2xhc3NOYW1lIHx8IFwiXCIpLnNwbGl0KC9cXHMrLyk7XG4gICAgcmV0dXJuIERST1BET1dOX0ZPQ1VTX0NMQVNTTkFNRVMuc29tZShmdW5jdGlvbiAodGVzdENsYXNzbmFtZSkgeyByZXR1cm4gY2xhc3NOYW1lcy5pbmRleE9mKHRlc3RDbGFzc25hbWUpID49IDA7IH0pO1xufTtcbnZhciBDYWxlbmRhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsZW5kYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXIocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vbnRoQ29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2xpY2tPdXRzaWRlKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0Q2xpY2tPdXRzaWRlUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEcm9wZG93bkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKGlzRHJvcGRvd25TZWxlY3QoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkRyb3Bkb3duRm9jdXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldERhdGVJblZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgcHJlU2VsZWN0aW9uID0gX2EucHJlU2VsZWN0aW9uLCBzZWxlY3RlZCA9IF9hLnNlbGVjdGVkLCBvcGVuVG9EYXRlID0gX2Eub3BlblRvRGF0ZTtcbiAgICAgICAgICAgIHZhciBtaW5EYXRlID0gZ2V0RWZmZWN0aXZlTWluRGF0ZShfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB2YXIgbWF4RGF0ZSA9IGdldEVmZmVjdGl2ZU1heERhdGUoX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXdEYXRlKCk7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbERhdGUgPSBvcGVuVG9EYXRlIHx8IHNlbGVjdGVkIHx8IHByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChpbml0aWFsRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtaW5EYXRlICYmIGlzQmVmb3JlKGN1cnJlbnQsIG1pbkRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5EYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXhEYXRlICYmIGlzQWZ0ZXIoY3VycmVudCwgbWF4RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heERhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmluY3JlYXNlTW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IF9hLmRhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGFkZE1vbnRocyhkYXRlLCAxKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU1vbnRoQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVjcmVhc2VNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogc3ViTW9udGhzKGRhdGUsIDEpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlTW9udGhDaGFuZ2UoX3RoaXMuc3RhdGUuZGF0ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEYXlDbGljayA9IGZ1bmN0aW9uIChkYXksIGV2ZW50LCBtb250aFNlbGVjdGVkSW4pIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uU2VsZWN0KGRheSwgZXZlbnQsIG1vbnRoU2VsZWN0ZWRJbik7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRQcmVTZWxlY3Rpb24gJiYgX3RoaXMucHJvcHMuc2V0UHJlU2VsZWN0aW9uKGRheSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURheU1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGluZ0RhdGU6IGRheSB9KTtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlciAmJiBfdGhpcy5wcm9wcy5vbkRheU1vdXNlRW50ZXIoZGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW9udGhNb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzZWxlY3RpbmdEYXRlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbk1vbnRoTW91c2VMZWF2ZSAmJiBfdGhpcy5wcm9wcy5vbk1vbnRoTW91c2VMZWF2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVZZWFyTW91c2VFbnRlciA9IGZ1bmN0aW9uIChldmVudCwgeWVhcikge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzZWxlY3RpbmdEYXRlOiBzZXRZZWFyKG5ld0RhdGUoKSwgeWVhcikgfSk7XG4gICAgICAgICAgICAhIV90aGlzLnByb3BzLm9uWWVhck1vdXNlRW50ZXIgJiYgX3RoaXMucHJvcHMub25ZZWFyTW91c2VFbnRlcihldmVudCwgeWVhcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVllYXJNb3VzZUxlYXZlID0gZnVuY3Rpb24gKGV2ZW50LCB5ZWFyKSB7XG4gICAgICAgICAgICAhIV90aGlzLnByb3BzLm9uWWVhck1vdXNlTGVhdmUgJiYgX3RoaXMucHJvcHMub25ZZWFyTW91c2VMZWF2ZShldmVudCwgeWVhcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVllYXJDaGFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uWWVhckNoYW5nZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGRhdGUpO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc1JlbmRlckFyaWFMaXZlTWVzc2FnZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5hZGp1c3REYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vblNlbGVjdChkYXRlKTtcbiAgICAgICAgICAgICAgICAoX2QgPSAoX2MgPSBfdGhpcy5wcm9wcykuc2V0T3BlbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucHJvcHMuc2V0UHJlU2VsZWN0aW9uICYmIF90aGlzLnByb3BzLnNldFByZVNlbGVjdGlvbihkYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0RW5hYmxlZFByZVNlbGVjdGlvbkRhdGVGb3JNb250aCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICBpZiAoIWlzRGF5RGlzYWJsZWQoZGF0ZSwgX3RoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRPZk1vbnRoID0gZ2V0U3RhcnRPZk1vbnRoKGRhdGUpO1xuICAgICAgICAgICAgdmFyIGVuZE9mTW9udGggPSBnZXRFbmRPZk1vbnRoKGRhdGUpO1xuICAgICAgICAgICAgdmFyIHRvdGFsRGF5cyA9IGRpZmZlcmVuY2VJbkRheXMoZW5kT2ZNb250aCwgc3RhcnRPZk1vbnRoKTtcbiAgICAgICAgICAgIHZhciBwcmVTZWxlY3RlZERhdGUgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgZGF5SWR4ID0gMDsgZGF5SWR4IDw9IHRvdGFsRGF5czsgZGF5SWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2luZ0RhdGUgPSBhZGREYXlzKHN0YXJ0T2ZNb250aCwgZGF5SWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGF5RGlzYWJsZWQocHJvY2Vzc2luZ0RhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3RlZERhdGUgPSBwcm9jZXNzaW5nRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZVNlbGVjdGVkRGF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW9udGhDaGFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB2YXIgZW5hYmxlZFByZVNlbGVjdGlvbkRhdGUgPSAoX2EgPSBfdGhpcy5nZXRFbmFibGVkUHJlU2VsZWN0aW9uRGF0ZUZvck1vbnRoKGRhdGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRlO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ3VzdG9tTW9udGhDaGFuZ2UoZW5hYmxlZFByZVNlbGVjdGlvbkRhdGUpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmFkanVzdERhdGVPbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uU2VsZWN0KGVuYWJsZWRQcmVTZWxlY3Rpb25EYXRlKTtcbiAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfdGhpcy5wcm9wcykuc2V0T3BlbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucHJvcHMuc2V0UHJlU2VsZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2V0UHJlU2VsZWN0aW9uKGVuYWJsZWRQcmVTZWxlY3Rpb25EYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ3VzdG9tTW9udGhDaGFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbk1vbnRoQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF0ZSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVNb250aFllYXJDaGFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlWWVhckNoYW5nZShkYXRlKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZU1vbnRoQ2hhbmdlKGRhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jaGFuZ2VZZWFyID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogc2V0WWVhcihkYXRlLCBOdW1iZXIoeWVhcikpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlWWVhckNoYW5nZShfdGhpcy5zdGF0ZS5kYXRlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNoYW5nZU1vbnRoID0gZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IF9hLmRhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHNldE1vbnRoKGRhdGUsIE51bWJlcihtb250aCkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW9udGhDaGFuZ2UoX3RoaXMuc3RhdGUuZGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgbW9udGhTZWxlY3RlZEluIHRvIDAgc28gdGhlIHRhcmdldCBtb250aCBhcHBlYXJzIGluIHRoZSBsZWZ0bW9zdCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW50IGJlaGF2aW9yIHdoZW4gdXNpbmcgY2hhbmdlTW9udGggaW4gY3VzdG9tIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25Nb250aFNlbGVjdGVkSW5DaGFuZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jaGFuZ2VNb250aFllYXIgPSBmdW5jdGlvbiAobW9udGhZZWFyKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IF9hLmRhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHNldFllYXIoc2V0TW9udGgoZGF0ZSwgZ2V0TW9udGgobW9udGhZZWFyKSksIGdldFllYXIobW9udGhZZWFyKSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oYW5kbGVNb250aFllYXJDaGFuZ2UoX3RoaXMuc3RhdGUuZGF0ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oZWFkZXIgPSBmdW5jdGlvbiAoZGF0ZSwgY3VzdG9tRGF5TmFtZUNvdW50KSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSA9PT0gdm9pZCAwKSB7IGRhdGUgPSBfdGhpcy5zdGF0ZS5kYXRlOyB9XG4gICAgICAgICAgICBpZiAoY3VzdG9tRGF5TmFtZUNvdW50ID09PSB2b2lkIDApIHsgY3VzdG9tRGF5TmFtZUNvdW50ID0gMDsgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGlmIGRhdGUgaXMgaW52YWxpZFxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMucHJvcHMuZGlzYWJsZWQ7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZldlZWsgPSBnZXRTdGFydE9mV2VlayhkYXRlLCBfdGhpcy5wcm9wcy5sb2NhbGUsIF90aGlzLnByb3BzLmNhbGVuZGFyU3RhcnREYXkpO1xuICAgICAgICAgICAgdmFyIGRheU5hbWVzID0gW107XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1dlZWtOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgZGF5TmFtZXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcIldcIiwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS1uYW1lIFwiLmNvbmNhdChkaXNhYmxlZCA/IFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LW5hbWUtLWRpc2FibGVkXCIgOiBcIlwiKSwgcm9sZTogXCJjb2x1bW5oZWFkZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19zci1vbmx5XCIgfSwgXCJXZWVrIG51bWJlclwiKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIF90aGlzLnByb3BzLndlZWtMYWJlbCB8fCBcIiNcIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXlOYW1lcy5jb25jYXQoWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRheSA9IGFkZERheXMoc3RhcnRPZldlZWssIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIHdlZWtEYXlOYW1lID0gX3RoaXMuZm9ybWF0V2Vla2RheShkYXksIF90aGlzLnByb3BzLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxEYXlOYW1lID0gZm9ybWF0RGF0ZShkYXksIFwiRUVFRVwiLCBfdGhpcy5wcm9wcy5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWVrRGF5Q2xhc3NOYW1lID0gX3RoaXMucHJvcHMud2Vla0RheUNsYXNzTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLndlZWtEYXlDbGFzc05hbWUoZGF5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBVc2UgY3VzdG9tIHJlbmRlciBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5yZW5kZXJDdXN0b21EYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21Db250ZW50ID0gX3RoaXMucHJvcHMucmVuZGVyQ3VzdG9tRGF5TmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXk6IGRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0TmFtZTogd2Vla0RheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsTmFtZTogZnVsbERheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IF90aGlzLnByb3BzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURheU5hbWVDb3VudDogY3VzdG9tRGF5TmFtZUNvdW50LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBvZmZzZXQsIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX2RheS1uYW1lXCIsIHdlZWtEYXlDbGFzc05hbWUsIGRpc2FibGVkID8gXCJyZWFjdC1kYXRlcGlja2VyX19kYXktbmFtZS0tZGlzYWJsZWRcIiA6IFwiXCIpIH0sIGN1c3RvbUNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCByZW5kZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IG9mZnNldCwgcm9sZTogXCJjb2x1bW5oZWFkZXJcIiwgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LW5hbWVcIiwgd2Vla0RheUNsYXNzTmFtZSwgZGlzYWJsZWQgPyBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS1uYW1lLS1kaXNhYmxlZFwiIDogXCJcIikgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fc3Itb25seVwiIH0sIGZ1bGxEYXlOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIHdlZWtEYXlOYW1lKSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5mb3JtYXRXZWVrZGF5ID0gZnVuY3Rpb24gKGRheSwgbG9jYWxlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZm9ybWF0V2Vla0RheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRGb3JtYXR0ZWRXZWVrZGF5SW5Mb2NhbGUoZGF5LCBfdGhpcy5wcm9wcy5mb3JtYXRXZWVrRGF5LCBsb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnVzZVdlZWtkYXlzU2hvcnRcbiAgICAgICAgICAgICAgICA/IGdldFdlZWtkYXlTaG9ydEluTG9jYWxlKGRheSwgbG9jYWxlKVxuICAgICAgICAgICAgICAgIDogZ2V0V2Vla2RheU1pbkluTG9jYWxlKGRheSwgbG9jYWxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVjcmVhc2VZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogc3ViWWVhcnMoZGF0ZSwgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKChfYiA9IF90aGlzLnByb3BzLnllYXJJdGVtTnVtYmVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBDYWxlbmRhci5kZWZhdWx0UHJvcHMueWVhckl0ZW1OdW1iZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDEpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlWWVhckNoYW5nZShfdGhpcy5zdGF0ZS5kYXRlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNsZWFyU2VsZWN0aW5nRGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2VsZWN0aW5nRGF0ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJQcmV2aW91c0J1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnJlbmRlckN1c3RvbUhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb250aHNTaG93biA9IChfYSA9IF90aGlzLnByb3BzLm1vbnRoc1Nob3duKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDYWxlbmRhci5kZWZhdWx0UHJvcHMubW9udGhzU2hvd247XG4gICAgICAgICAgICB2YXIgbW9udGhzVG9TdWJ0cmFjdCA9IF90aGlzLnByb3BzLnNob3dQcmV2aW91c01vbnRoc1xuICAgICAgICAgICAgICAgID8gbW9udGhzU2hvd24gLSAxXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgdmFyIG1vbnRoU2VsZWN0ZWRJbiA9IChfYiA9IF90aGlzLnByb3BzLm1vbnRoU2VsZWN0ZWRJbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbW9udGhzVG9TdWJ0cmFjdDtcbiAgICAgICAgICAgIHZhciBmcm9tTW9udGhEYXRlID0gc3ViTW9udGhzKF90aGlzLnN0YXRlLmRhdGUsIG1vbnRoU2VsZWN0ZWRJbik7XG4gICAgICAgICAgICB2YXIgYWxsUHJldkRheXNEaXNhYmxlZDtcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuZGlzYWJsZWQ6XG4gICAgICAgICAgICAgICAgICAgIGFsbFByZXZEYXlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIGFsbFByZXZEYXlzRGlzYWJsZWQgPSB5ZWFyRGlzYWJsZWRCZWZvcmUoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyOlxuICAgICAgICAgICAgICAgICAgICBhbGxQcmV2RGF5c0Rpc2FibGVkID0geWVhcnNEaXNhYmxlZEJlZm9yZShfdGhpcy5zdGF0ZS5kYXRlLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuc2hvd1F1YXJ0ZXJZZWFyUGlja2VyOlxuICAgICAgICAgICAgICAgICAgICBhbGxQcmV2RGF5c0Rpc2FibGVkID0gcXVhcnRlckRpc2FibGVkQmVmb3JlKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYWxsUHJldkRheXNEaXNhYmxlZCA9IG1vbnRoRGlzYWJsZWRCZWZvcmUoZnJvbU1vbnRoRGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoISgoX2MgPSBfdGhpcy5wcm9wcy5mb3JjZVNob3dNb250aE5hdmlnYXRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IENhbGVuZGFyLmRlZmF1bHRQcm9wcy5mb3JjZVNob3dNb250aE5hdmlnYXRpb24pICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLnNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgICAgIGFsbFByZXZEYXlzRGlzYWJsZWQpIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGljb25DbGFzc2VzID0gW1xuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi1pY29uXCIsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLWljb24tLXByZXZpb3VzXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS1wcmV2aW91c1wiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSBfdGhpcy5kZWNyZWFzZU1vbnRoO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IF90aGlzLmRlY3JlYXNlWWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxQcmV2RGF5c0Rpc2FibGVkICYmIF90aGlzLnByb3BzLnNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLXByZXZpb3VzLS1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICBjbGlja0hhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNGb3JZZWFyID0gX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dRdWFydGVyWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyO1xuICAgICAgICAgICAgdmFyIF9kID0gX3RoaXMucHJvcHMsIF9lID0gX2QucHJldmlvdXNNb250aEJ1dHRvbkxhYmVsLCBwcmV2aW91c01vbnRoQnV0dG9uTGFiZWwgPSBfZSA9PT0gdm9pZCAwID8gQ2FsZW5kYXIuZGVmYXVsdFByb3BzLnByZXZpb3VzTW9udGhCdXR0b25MYWJlbCA6IF9lLCBfZiA9IF9kLnByZXZpb3VzWWVhckJ1dHRvbkxhYmVsLCBwcmV2aW91c1llYXJCdXR0b25MYWJlbCA9IF9mID09PSB2b2lkIDAgPyBDYWxlbmRhci5kZWZhdWx0UHJvcHMucHJldmlvdXNZZWFyQnV0dG9uTGFiZWwgOiBfZjtcbiAgICAgICAgICAgIHZhciBfZyA9IF90aGlzLnByb3BzLCBfaCA9IF9nLnByZXZpb3VzTW9udGhBcmlhTGFiZWwsIHByZXZpb3VzTW9udGhBcmlhTGFiZWwgPSBfaCA9PT0gdm9pZCAwID8gdHlwZW9mIHByZXZpb3VzTW9udGhCdXR0b25MYWJlbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gcHJldmlvdXNNb250aEJ1dHRvbkxhYmVsXG4gICAgICAgICAgICAgICAgOiBcIlByZXZpb3VzIE1vbnRoXCIgOiBfaCwgX2ogPSBfZy5wcmV2aW91c1llYXJBcmlhTGFiZWwsIHByZXZpb3VzWWVhckFyaWFMYWJlbCA9IF9qID09PSB2b2lkIDAgPyB0eXBlb2YgcHJldmlvdXNZZWFyQnV0dG9uTGFiZWwgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IHByZXZpb3VzWWVhckJ1dHRvbkxhYmVsXG4gICAgICAgICAgICAgICAgOiBcIlByZXZpb3VzIFllYXJcIiA6IF9qO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oXCIgXCIpLCBvbkNsaWNrOiBjbGlja0hhbmRsZXIsIG9uS2V5RG93bjogX3RoaXMucHJvcHMuaGFuZGxlT25LZXlEb3duLCBcImFyaWEtbGFiZWxcIjogaXNGb3JZZWFyID8gcHJldmlvdXNZZWFyQXJpYUxhYmVsIDogcHJldmlvdXNNb250aEFyaWFMYWJlbCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBpY29uQ2xhc3Nlcy5qb2luKFwiIFwiKSB9LCBpc0ZvclllYXIgPyBwcmV2aW91c1llYXJCdXR0b25MYWJlbCA6IHByZXZpb3VzTW9udGhCdXR0b25MYWJlbCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaW5jcmVhc2VZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogYWRkWWVhcnMoZGF0ZSwgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKChfYiA9IF90aGlzLnByb3BzLnllYXJJdGVtTnVtYmVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBDYWxlbmRhci5kZWZhdWx0UHJvcHMueWVhckl0ZW1OdW1iZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDEpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlWWVhckNoYW5nZShfdGhpcy5zdGF0ZS5kYXRlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlck5leHRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMucmVuZGVyQ3VzdG9tSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFsbE5leHREYXlzRGlzYWJsZWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLmRpc2FibGVkOlxuICAgICAgICAgICAgICAgICAgICBhbGxOZXh0RGF5c0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyOlxuICAgICAgICAgICAgICAgICAgICBhbGxOZXh0RGF5c0Rpc2FibGVkID0geWVhckRpc2FibGVkQWZ0ZXIoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyOlxuICAgICAgICAgICAgICAgICAgICBhbGxOZXh0RGF5c0Rpc2FibGVkID0geWVhcnNEaXNhYmxlZEFmdGVyKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIGFsbE5leHREYXlzRGlzYWJsZWQgPSBxdWFydGVyRGlzYWJsZWRBZnRlcihfdGhpcy5zdGF0ZS5kYXRlLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGFsbE5leHREYXlzRGlzYWJsZWQgPSBtb250aERpc2FibGVkQWZ0ZXIoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoISgoX2EgPSBfdGhpcy5wcm9wcy5mb3JjZVNob3dNb250aE5hdmlnYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENhbGVuZGFyLmRlZmF1bHRQcm9wcy5mb3JjZVNob3dNb250aE5hdmlnYXRpb24pICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLnNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgICAgIGFsbE5leHREYXlzRGlzYWJsZWQpIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS1uZXh0XCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGljb25DbGFzc2VzID0gW1xuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi1pY29uXCIsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLWljb24tLW5leHRcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS1uZXh0LS13aXRoLXRpbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMudG9kYXlCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS1uZXh0LS13aXRoLXRvZGF5LWJ1dHRvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSBfdGhpcy5pbmNyZWFzZU1vbnRoO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IF90aGlzLmluY3JlYXNlWWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxOZXh0RGF5c0Rpc2FibGVkICYmIF90aGlzLnByb3BzLnNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLW5leHQtLWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0ZvclllYXIgPSBfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1F1YXJ0ZXJZZWFyUGlja2VyIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXI7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgX2MgPSBfYi5uZXh0TW9udGhCdXR0b25MYWJlbCwgbmV4dE1vbnRoQnV0dG9uTGFiZWwgPSBfYyA9PT0gdm9pZCAwID8gQ2FsZW5kYXIuZGVmYXVsdFByb3BzLm5leHRNb250aEJ1dHRvbkxhYmVsIDogX2MsIF9kID0gX2IubmV4dFllYXJCdXR0b25MYWJlbCwgbmV4dFllYXJCdXR0b25MYWJlbCA9IF9kID09PSB2b2lkIDAgPyBDYWxlbmRhci5kZWZhdWx0UHJvcHMubmV4dFllYXJCdXR0b25MYWJlbCA6IF9kO1xuICAgICAgICAgICAgdmFyIF9lID0gX3RoaXMucHJvcHMsIF9mID0gX2UubmV4dE1vbnRoQXJpYUxhYmVsLCBuZXh0TW9udGhBcmlhTGFiZWwgPSBfZiA9PT0gdm9pZCAwID8gdHlwZW9mIG5leHRNb250aEJ1dHRvbkxhYmVsID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBuZXh0TW9udGhCdXR0b25MYWJlbFxuICAgICAgICAgICAgICAgIDogXCJOZXh0IE1vbnRoXCIgOiBfZiwgX2cgPSBfZS5uZXh0WWVhckFyaWFMYWJlbCwgbmV4dFllYXJBcmlhTGFiZWwgPSBfZyA9PT0gdm9pZCAwID8gdHlwZW9mIG5leHRZZWFyQnV0dG9uTGFiZWwgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IG5leHRZZWFyQnV0dG9uTGFiZWxcbiAgICAgICAgICAgICAgICA6IFwiTmV4dCBZZWFyXCIgOiBfZztcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKFwiIFwiKSwgb25DbGljazogY2xpY2tIYW5kbGVyLCBvbktleURvd246IF90aGlzLnByb3BzLmhhbmRsZU9uS2V5RG93biwgXCJhcmlhLWxhYmVsXCI6IGlzRm9yWWVhciA/IG5leHRZZWFyQXJpYUxhYmVsIDogbmV4dE1vbnRoQXJpYUxhYmVsIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGljb25DbGFzc2VzLmpvaW4oXCIgXCIpIH0sIGlzRm9yWWVhciA/IG5leHRZZWFyQnV0dG9uTGFiZWwgOiBuZXh0TW9udGhCdXR0b25MYWJlbCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyQ3VycmVudE1vbnRoID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRlID09PSB2b2lkIDApIHsgZGF0ZSA9IF90aGlzLnN0YXRlLmRhdGU7IH1cbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW1wicmVhY3QtZGF0ZXBpY2tlcl9fY3VycmVudC1tb250aFwiXTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93WWVhckRyb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fY3VycmVudC1tb250aC0taGFzWWVhckRyb3Bkb3duXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dNb250aERyb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fY3VycmVudC1tb250aC0taGFzTW9udGhEcm9wZG93blwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyRHJvcGRvd24pIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19jdXJyZW50LW1vbnRoLS1oYXNNb250aFllYXJEcm9wZG93blwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImgyXCIsIHsgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oXCIgXCIpIH0sIGlzVmFsaWQoZGF0ZSlcbiAgICAgICAgICAgICAgICA/IGZvcm1hdERhdGUoZGF0ZSwgX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCwgX3RoaXMucHJvcHMubG9jYWxlKVxuICAgICAgICAgICAgICAgIDogXCJcIikpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJZZWFyRHJvcGRvd24gPSBmdW5jdGlvbiAob3ZlcnJpZGVIaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVIaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGVIaWRlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuc2hvd1llYXJEcm9wZG93biB8fCBvdmVycmlkZUhpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoWWVhckRyb3Bkb3duLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IGRhdGU6IF90aGlzLnN0YXRlLmRhdGUsIG9uQ2hhbmdlOiBfdGhpcy5jaGFuZ2VZZWFyLCB5ZWFyOiBnZXRZZWFyKF90aGlzLnN0YXRlLmRhdGUpIH0pKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlck1vbnRoRHJvcGRvd24gPSBmdW5jdGlvbiAob3ZlcnJpZGVIaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVIaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGVIaWRlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuc2hvd01vbnRoRHJvcGRvd24gfHwgb3ZlcnJpZGVIaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1vbnRoRHJvcGRvd24sIF9hc3NpZ24oe30sIENhbGVuZGFyLmRlZmF1bHRQcm9wcywgX3RoaXMucHJvcHMsIHsgbW9udGg6IGdldE1vbnRoKF90aGlzLnN0YXRlLmRhdGUpLCBvbkNoYW5nZTogX3RoaXMuY2hhbmdlTW9udGggfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyTW9udGhZZWFyRHJvcGRvd24gPSBmdW5jdGlvbiAob3ZlcnJpZGVIaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVIaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGVIaWRlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhckRyb3Bkb3duIHx8IG92ZXJyaWRlSGlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChNb250aFllYXJEcm9wZG93biwgX2Fzc2lnbih7fSwgQ2FsZW5kYXIuZGVmYXVsdFByb3BzLCBfdGhpcy5wcm9wcywgeyBkYXRlOiBfdGhpcy5zdGF0ZS5kYXRlLCBvbkNoYW5nZTogX3RoaXMuY2hhbmdlTW9udGhZZWFyIH0pKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVRvZGF5QnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uU2VsZWN0KGdldFN0YXJ0T2ZUb2RheSgpLCBldmVudCk7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRQcmVTZWxlY3Rpb24gJiYgX3RoaXMucHJvcHMuc2V0UHJlU2VsZWN0aW9uKGdldFN0YXJ0T2ZUb2RheSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyVG9kYXlCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLnRvZGF5QnV0dG9uIHx8IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX190b2RheS1idXR0b25cIiwgb25DbGljazogX3RoaXMuaGFuZGxlVG9kYXlCdXR0b25DbGljayB9LCBfdGhpcy5wcm9wcy50b2RheUJ1dHRvbikpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJEYXlOYW1lc0hlYWRlciA9IGZ1bmN0aW9uIChtb250aERhdGUsIGN1c3RvbURheU5hbWVDb3VudCkge1xuICAgICAgICAgICAgaWYgKGN1c3RvbURheU5hbWVDb3VudCA9PT0gdm9pZCAwKSB7IGN1c3RvbURheU5hbWVDb3VudCA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19kYXktbmFtZXNcIiwgcm9sZTogXCJyb3dcIiB9LCBfdGhpcy5oZWFkZXIobW9udGhEYXRlLCBjdXN0b21EYXlOYW1lQ291bnQpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckRlZmF1bHRIZWFkZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBtb250aERhdGUgPSBfYS5tb250aERhdGUsIGkgPSBfYS5pO1xuICAgICAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyLS1oYXMtdGltZS1zZWxlY3RcIjogX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QsXG4gICAgICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyLS1taWRkbGVcIjogX3RoaXMucHJvcHMubW9udGhIZWFkZXJQb3NpdGlvbiA9PT0gXCJtaWRkbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19oZWFkZXItLWJvdHRvbVwiOiBfdGhpcy5wcm9wcy5tb250aEhlYWRlclBvc2l0aW9uID09PSBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyQ3VycmVudE1vbnRoKG1vbnRoRGF0ZSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19oZWFkZXJfX2Ryb3Bkb3duIHJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlcl9fZHJvcGRvd24tLVwiLmNvbmNhdChfdGhpcy5wcm9wcy5kcm9wZG93bk1vZGUpLCBvbkZvY3VzOiBfdGhpcy5oYW5kbGVEcm9wZG93bkZvY3VzIH0sXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlck1vbnRoRHJvcGRvd24oaSAhPT0gMCksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlck1vbnRoWWVhckRyb3Bkb3duKGkgIT09IDApLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJZZWFyRHJvcGRvd24oaSAhPT0gMCkpKSk7XG4gICAgICAgICAgICAvLyBUb3AgcG9zaXRpb246IHJlbmRlciBoZWFkZXIgZGlyZWN0bHkgaW4gZGVmYXVsdCBsb2NhdGlvblxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm1vbnRoSGVhZGVyUG9zaXRpb24gPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyQ29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1pZGRsZS9ib3R0b20gcG9zaXRpb25zOiB3cmFwIHdpdGggbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyLXdyYXBwZXJcIiB9LFxuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlclByZXZpb3VzQnV0dG9uKCkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJOZXh0QnV0dG9uKCkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJDb250ZW50KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckN1c3RvbUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJBcmdzKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIG1vbnRoRGF0ZSA9IGhlYWRlckFyZ3MubW9udGhEYXRlLCBpID0gaGVhZGVyQXJncy5pO1xuICAgICAgICAgICAgaWYgKChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCAmJiAhX3RoaXMuc3RhdGUubW9udGhDb250YWluZXIpIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5wcm9wcywgc2hvd1llYXJQaWNrZXIgPSBfYy5zaG93WWVhclBpY2tlciwgeWVhckl0ZW1OdW1iZXIgPSBfYy55ZWFySXRlbU51bWJlcjtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlWWVhcnNSYW5nZTtcbiAgICAgICAgICAgIGlmIChzaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IGdldFllYXJzUGVyaW9kKG1vbnRoRGF0ZSwgeWVhckl0ZW1OdW1iZXIpLCBzdGFydFllYXIgPSBfZC5zdGFydFBlcmlvZCwgZW5kWWVhciA9IF9kLmVuZFBlcmlvZDtcbiAgICAgICAgICAgICAgICB2aXNpYmxlWWVhcnNSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRZZWFyOiBzdGFydFllYXIsXG4gICAgICAgICAgICAgICAgICAgIGVuZFllYXI6IGVuZFllYXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2TW9udGhCdXR0b25EaXNhYmxlZCA9IG1vbnRoRGlzYWJsZWRCZWZvcmUoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgdmFyIG5leHRNb250aEJ1dHRvbkRpc2FibGVkID0gbW9udGhEaXNhYmxlZEFmdGVyKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBwcmV2WWVhckJ1dHRvbkRpc2FibGVkID0geWVhckRpc2FibGVkQmVmb3JlKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBuZXh0WWVhckJ1dHRvbkRpc2FibGVkID0geWVhckRpc2FibGVkQWZ0ZXIoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlciByZWFjdC1kYXRlcGlja2VyX19oZWFkZXItLWN1c3RvbVwiLCBvbkZvY3VzOiBfdGhpcy5wcm9wcy5vbkRyb3Bkb3duRm9jdXMgfSwgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLnJlbmRlckN1c3RvbUhlYWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIF9hc3NpZ24oX2Fzc2lnbihfYXNzaWduKHt9LCBfdGhpcy5zdGF0ZSksIChzaG93WWVhclBpY2tlciAmJiB7IHZpc2libGVZZWFyc1JhbmdlOiB2aXNpYmxlWWVhcnNSYW5nZSB9KSksIHsgY3VzdG9tSGVhZGVyQ291bnQ6IGksIG1vbnRoRGF0ZTogbW9udGhEYXRlLCBjaGFuZ2VNb250aDogX3RoaXMuY2hhbmdlTW9udGgsIGNoYW5nZVllYXI6IF90aGlzLmNoYW5nZVllYXIsIGRlY3JlYXNlTW9udGg6IF90aGlzLmRlY3JlYXNlTW9udGgsIGluY3JlYXNlTW9udGg6IF90aGlzLmluY3JlYXNlTW9udGgsIGRlY3JlYXNlWWVhcjogX3RoaXMuZGVjcmVhc2VZZWFyLCBpbmNyZWFzZVllYXI6IF90aGlzLmluY3JlYXNlWWVhciwgcHJldk1vbnRoQnV0dG9uRGlzYWJsZWQ6IHByZXZNb250aEJ1dHRvbkRpc2FibGVkLCBuZXh0TW9udGhCdXR0b25EaXNhYmxlZDogbmV4dE1vbnRoQnV0dG9uRGlzYWJsZWQsIHByZXZZZWFyQnV0dG9uRGlzYWJsZWQ6IHByZXZZZWFyQnV0dG9uRGlzYWJsZWQsIG5leHRZZWFyQnV0dG9uRGlzYWJsZWQ6IG5leHRZZWFyQnV0dG9uRGlzYWJsZWQgfSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclllYXJIZWFkZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBtb250aERhdGUgPSBfYS5tb250aERhdGU7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgc2hvd1llYXJQaWNrZXIgPSBfYi5zaG93WWVhclBpY2tlciwgX2MgPSBfYi55ZWFySXRlbU51bWJlciwgeWVhckl0ZW1OdW1iZXIgPSBfYyA9PT0gdm9pZCAwID8gQ2FsZW5kYXIuZGVmYXVsdFByb3BzLnllYXJJdGVtTnVtYmVyIDogX2M7XG4gICAgICAgICAgICB2YXIgX2QgPSBnZXRZZWFyc1BlcmlvZChtb250aERhdGUsIHllYXJJdGVtTnVtYmVyKSwgc3RhcnRQZXJpb2QgPSBfZC5zdGFydFBlcmlvZCwgZW5kUGVyaW9kID0gX2QuZW5kUGVyaW9kO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlciByZWFjdC1kYXRlcGlja2VyLXllYXItaGVhZGVyXCIgfSwgc2hvd1llYXJQaWNrZXIgPyBcIlwiLmNvbmNhdChzdGFydFBlcmlvZCwgXCIgLSBcIikuY29uY2F0KGVuZFBlcmlvZCkgOiBnZXRZZWFyKG1vbnRoRGF0ZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbW9udGhEYXRlID0gX2EubW9udGhEYXRlLCBfYiA9IF9hLmksIGkgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iO1xuICAgICAgICAgICAgdmFyIGhlYWRlckFyZ3MgPSB7IG1vbnRoRGF0ZTogbW9udGhEYXRlLCBpOiBpIH07XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLnJlbmRlckN1c3RvbUhlYWRlciAhPT0gdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVuZGVyQ3VzdG9tSGVhZGVyKGhlYWRlckFyZ3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXJZZWFySGVhZGVyKGhlYWRlckFyZ3MpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXJEZWZhdWx0SGVhZGVyKGhlYWRlckFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJNb250aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSB8fCBfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb250aExpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBtb250aHNTaG93biA9IChfYSA9IF90aGlzLnByb3BzLm1vbnRoc1Nob3duKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDYWxlbmRhci5kZWZhdWx0UHJvcHMubW9udGhzU2hvd247XG4gICAgICAgICAgICB2YXIgbW9udGhzVG9TdWJ0cmFjdCA9IF90aGlzLnByb3BzLnNob3dQcmV2aW91c01vbnRoc1xuICAgICAgICAgICAgICAgID8gbW9udGhzU2hvd24gLSAxXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgdmFyIGZyb21Nb250aERhdGUgPSBfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyIHx8IF90aGlzLnByb3BzLnNob3dRdWFydGVyWWVhclBpY2tlclxuICAgICAgICAgICAgICAgID8gYWRkWWVhcnMoX3RoaXMuc3RhdGUuZGF0ZSwgbW9udGhzVG9TdWJ0cmFjdClcbiAgICAgICAgICAgICAgICA6IHN1Yk1vbnRocyhfdGhpcy5zdGF0ZS5kYXRlLCBtb250aHNUb1N1YnRyYWN0KTtcbiAgICAgICAgICAgIHZhciBtb250aFNlbGVjdGVkSW4gPSAoX2IgPSBfdGhpcy5wcm9wcy5tb250aFNlbGVjdGVkSW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG1vbnRoc1RvU3VidHJhY3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vbnRoc1Nob3duOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhzVG9BZGQgPSBpIC0gbW9udGhTZWxlY3RlZEluICsgbW9udGhzVG9TdWJ0cmFjdDtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhEYXRlID0gX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlciB8fCBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBhZGRZZWFycyhmcm9tTW9udGhEYXRlLCBtb250aHNUb0FkZClcbiAgICAgICAgICAgICAgICAgICAgOiBhZGRNb250aHMoZnJvbU1vbnRoRGF0ZSwgbW9udGhzVG9BZGQpO1xuICAgICAgICAgICAgICAgIHZhciBtb250aEtleSA9IFwibW9udGgtXCIuY29uY2F0KGkpO1xuICAgICAgICAgICAgICAgIHZhciBtb250aFNob3dzRHVwbGljYXRlRGF5c0VuZCA9IGkgPCBtb250aHNTaG93biAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgPSBpID4gMDtcbiAgICAgICAgICAgICAgICBtb250aExpc3QucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBtb250aEtleSwgcmVmOiBmdW5jdGlvbiAoZGl2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb250aENvbnRhaW5lciA9IGRpdiAhPT0gbnVsbCAmJiBkaXYgIT09IHZvaWQgMCA/IGRpdiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm1vbnRoSGVhZGVyUG9zaXRpb24gPT09IFwidG9wXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckhlYWRlcih7IG1vbnRoRGF0ZTogbW9udGhEYXRlLCBpOiBpIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1vbnRoLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IGNvbnRhaW5lclJlZjogX3RoaXMuY29udGFpbmVyUmVmLCBhcmlhTGFiZWxQcmVmaXg6IF90aGlzLnByb3BzLm1vbnRoQXJpYUxhYmVsUHJlZml4LCBkYXk6IG1vbnRoRGF0ZSwgb25EYXlDbGljazogX3RoaXMuaGFuZGxlRGF5Q2xpY2ssIGhhbmRsZU9uS2V5RG93bjogX3RoaXMucHJvcHMuaGFuZGxlT25EYXlLZXlEb3duLCBoYW5kbGVPbk1vbnRoS2V5RG93bjogX3RoaXMucHJvcHMuaGFuZGxlT25LZXlEb3duLCBvbkRheU1vdXNlRW50ZXI6IF90aGlzLmhhbmRsZURheU1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZTogX3RoaXMuaGFuZGxlTW9udGhNb3VzZUxlYXZlLCBvcmRlckluRGlzcGxheTogaSwgc2VsZWN0aW5nRGF0ZTogX3RoaXMuc3RhdGUuc2VsZWN0aW5nRGF0ZSwgbW9udGhTaG93c0R1cGxpY2F0ZURheXNFbmQ6IG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzRW5kLCBtb250aFNob3dzRHVwbGljYXRlRGF5c1N0YXJ0OiBtb250aFNob3dzRHVwbGljYXRlRGF5c1N0YXJ0LCBkYXlOYW1lc0hlYWRlcjogX3RoaXMucmVuZGVyRGF5TmFtZXNIZWFkZXIobW9udGhEYXRlLCBpKSwgbW9udGhIZWFkZXI6IF90aGlzLnByb3BzLm1vbnRoSGVhZGVyUG9zaXRpb24gPT09IFwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF90aGlzLnJlbmRlckhlYWRlcih7IG1vbnRoRGF0ZTogbW9udGhEYXRlLCBpOiBpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIG1vbnRoRm9vdGVyOiBfdGhpcy5wcm9wcy5tb250aEhlYWRlclBvc2l0aW9uID09PSBcImJvdHRvbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5yZW5kZXJIZWFkZXIoeyBtb250aERhdGU6IG1vbnRoRGF0ZSwgaTogaSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoTGlzdDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyWWVhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckhlYWRlcih7IG1vbnRoRGF0ZTogX3RoaXMuc3RhdGUuZGF0ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChZZWFyLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IHNlbGVjdGluZ0RhdGU6IF90aGlzLnN0YXRlLnNlbGVjdGluZ0RhdGUsIGRhdGU6IF90aGlzLnN0YXRlLmRhdGUsIG9uRGF5Q2xpY2s6IF90aGlzLmhhbmRsZURheUNsaWNrLCBjbGVhclNlbGVjdGluZ0RhdGU6IF90aGlzLmNsZWFyU2VsZWN0aW5nRGF0ZSwgb25ZZWFyTW91c2VFbnRlcjogX3RoaXMuaGFuZGxlWWVhck1vdXNlRW50ZXIsIG9uWWVhck1vdXNlTGVhdmU6IF90aGlzLmhhbmRsZVllYXJNb3VzZUxlYXZlIH0pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJUaW1lU2VjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCAmJlxuICAgICAgICAgICAgICAgIChfdGhpcy5zdGF0ZS5tb250aENvbnRhaW5lciB8fCBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFRpbWUsIF9hc3NpZ24oe30sIENhbGVuZGFyLmRlZmF1bHRQcm9wcywgX3RoaXMucHJvcHMsIHsgb25DaGFuZ2U6IF90aGlzLnByb3BzLm9uVGltZUNoYW5nZSwgZm9ybWF0OiBfdGhpcy5wcm9wcy50aW1lRm9ybWF0LCBpbnRlcnZhbHM6IF90aGlzLnByb3BzLnRpbWVJbnRlcnZhbHMsIG1vbnRoUmVmOiBfdGhpcy5zdGF0ZS5tb250aENvbnRhaW5lciB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJJbnB1dFRpbWVTZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuc2hvd1RpbWVJbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBzZWxlY3RzUmFuZ2UgbW9kZSAtIHJlbmRlciB0d28gdGltZSBpbnB1dHNcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5wcm9wcywgc3RhcnREYXRlID0gX2Muc3RhcnREYXRlLCBlbmREYXRlID0gX2MuZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gc3RhcnREYXRlID8gbmV3IERhdGUoc3RhcnREYXRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lVmFsaWQgPSBzdGFydFRpbWUgJiYgaXNWYWxpZChzdGFydFRpbWUpICYmIEJvb2xlYW4oc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lU3RyaW5nID0gc3RhcnRUaW1lVmFsaWRcbiAgICAgICAgICAgICAgICAgICAgPyBcIlwiLmNvbmNhdChhZGRaZXJvKHN0YXJ0VGltZS5nZXRIb3VycygpKSwgXCI6XCIpLmNvbmNhdChhZGRaZXJvKHN0YXJ0VGltZS5nZXRNaW51dGVzKCkpKVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBlbmREYXRlID8gbmV3IERhdGUoZW5kRGF0ZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRpbWVWYWxpZCA9IGVuZFRpbWUgJiYgaXNWYWxpZChlbmRUaW1lKSAmJiBCb29sZWFuKGVuZERhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRUaW1lU3RyaW5nID0gZW5kVGltZVZhbGlkXG4gICAgICAgICAgICAgICAgICAgID8gXCJcIi5jb25jYXQoYWRkWmVybyhlbmRUaW1lLmdldEhvdXJzKCkpLCBcIjpcIikuY29uY2F0KGFkZFplcm8oZW5kVGltZS5nZXRNaW51dGVzKCkpKVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElucHV0VGltZSwgX2Fzc2lnbih7fSwgQ2FsZW5kYXIuZGVmYXVsdFByb3BzLCBfdGhpcy5wcm9wcywgeyBkYXRlOiBzdGFydFRpbWUsIHRpbWVTdHJpbmc6IHN0YXJ0VGltZVN0cmluZywgb25DaGFuZ2U6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25UaW1lQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGltZSwgXCJzdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVJbnB1dExhYmVsOiAoKF9hID0gX3RoaXMucHJvcHMudGltZUlucHV0TGFiZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiVGltZVwiKSArIFwiIChTdGFydClcIiB9KSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRUaW1lLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IGRhdGU6IGVuZFRpbWUsIHRpbWVTdHJpbmc6IGVuZFRpbWVTdHJpbmcsIG9uQ2hhbmdlOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uVGltZUNoYW5nZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRpbWUsIFwiZW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZUlucHV0TGFiZWw6ICgoX2IgPSBfdGhpcy5wcm9wcy50aW1lSW5wdXRMYWJlbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJUaW1lXCIpICsgXCIgKEVuZClcIiB9KSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmdsZSBkYXRlIG1vZGUgKG9yaWdpbmFsIGJlaGF2aW9yKVxuICAgICAgICAgICAgdmFyIHRpbWUgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZFxuICAgICAgICAgICAgICAgID8gbmV3IERhdGUoX3RoaXMucHJvcHMuc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgdGltZVZhbGlkID0gdGltZSAmJiBpc1ZhbGlkKHRpbWUpICYmIEJvb2xlYW4oX3RoaXMucHJvcHMuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgdmFyIHRpbWVTdHJpbmcgPSB0aW1lVmFsaWRcbiAgICAgICAgICAgICAgICA/IFwiXCIuY29uY2F0KGFkZFplcm8odGltZS5nZXRIb3VycygpKSwgXCI6XCIpLmNvbmNhdChhZGRaZXJvKHRpbWUuZ2V0TWludXRlcygpKSlcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRUaW1lLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IGRhdGU6IHRpbWUsIHRpbWVTdHJpbmc6IHRpbWVTdHJpbmcsIG9uQ2hhbmdlOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25UaW1lQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfSB9KSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJBcmlhTGl2ZVJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIERvbid0IHJlbmRlciBhcmlhLWxpdmUgbWVzc2FnZSBpZiBkYXRlIGlzIGludmFsaWRcbiAgICAgICAgICAgIGlmICghaXNWYWxpZChfdGhpcy5zdGF0ZS5kYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyByb2xlOiBcImFsZXJ0XCIsIFwiYXJpYS1saXZlXCI6IFwicG9saXRlXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19hcmlhLWxpdmVcIiB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRZZWFyc1BlcmlvZChfdGhpcy5zdGF0ZS5kYXRlLCAoX2EgPSBfdGhpcy5wcm9wcy55ZWFySXRlbU51bWJlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogQ2FsZW5kYXIuZGVmYXVsdFByb3BzLnllYXJJdGVtTnVtYmVyKSwgc3RhcnRQZXJpb2QgPSBfYi5zdGFydFBlcmlvZCwgZW5kUGVyaW9kID0gX2IuZW5kUGVyaW9kO1xuICAgICAgICAgICAgdmFyIGFyaWFMaXZlTWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZSA9IFwiXCIuY29uY2F0KHN0YXJ0UGVyaW9kLCBcIiAtIFwiKS5jb25jYXQoZW5kUGVyaW9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2UgPSBnZXRZZWFyKF90aGlzLnN0YXRlLmRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlID0gXCJcIi5jb25jYXQoZ2V0TW9udGhJbkxvY2FsZShnZXRNb250aChfdGhpcy5zdGF0ZS5kYXRlKSwgX3RoaXMucHJvcHMubG9jYWxlKSwgXCIgXCIpLmNvbmNhdChnZXRZZWFyKF90aGlzLnN0YXRlLmRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyByb2xlOiBcImFsZXJ0XCIsIFwiYXJpYS1saXZlXCI6IFwicG9saXRlXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19hcmlhLWxpdmVcIiB9LCBfdGhpcy5zdGF0ZS5pc1JlbmRlckFyaWFMaXZlTWVzc2FnZSAmJiBhcmlhTGl2ZU1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fY2hpbGRyZW4tY29udGFpbmVyXCIgfSwgX3RoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGF0ZTogX3RoaXMuZ2V0RGF0ZUluVmlldygpLFxuICAgICAgICAgICAgc2VsZWN0aW5nRGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbW9udGhDb250YWluZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FsZW5kYXIsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1vbnRoc1Nob3duOiAxLFxuICAgICAgICAgICAgICAgIGZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3V0c2lkZUNsaWNrSWdub3JlQ2xhc3M6IE9VVFNJREVfQ0xJQ0tfSUdOT1JFX0NMQVNTLFxuICAgICAgICAgICAgICAgIHRpbWVDYXB0aW9uOiBcIlRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmV2aW91c1llYXJCdXR0b25MYWJlbDogXCJQcmV2aW91cyBZZWFyXCIsXG4gICAgICAgICAgICAgICAgbmV4dFllYXJCdXR0b25MYWJlbDogXCJOZXh0IFllYXJcIixcbiAgICAgICAgICAgICAgICBwcmV2aW91c01vbnRoQnV0dG9uTGFiZWw6IFwiUHJldmlvdXMgTW9udGhcIixcbiAgICAgICAgICAgICAgICBuZXh0TW9udGhCdXR0b25MYWJlbDogXCJOZXh0IE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgeWVhckl0ZW1OdW1iZXI6IERFRkFVTFRfWUVBUl9JVEVNX05VTUJFUixcbiAgICAgICAgICAgICAgICBtb250aEhlYWRlclBvc2l0aW9uOiBcInRvcFwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gbW9udGhDb250YWluZXIgaGVpZ2h0IGlzIG5lZWRlZCBpbiB0aW1lIGNvbXBvbmVudFxuICAgICAgICAvLyB0byBkZXRlcm1pbmUgdGhlIGhlaWdodCBmb3IgdGhlIHVsIGluIHRoZSB0aW1lIGNvbXBvbmVudFxuICAgICAgICAvLyBzZXRTdGF0ZSBoZXJlIHNvIGhlaWdodCBpcyBnaXZlbiBhZnRlciBmaW5hbCBjb21wb25lbnRcbiAgICAgICAgLy8gbGF5b3V0IGlzIHJlbmRlcmVkXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbk1vbnRoQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IG1vbnRoQ29udGFpbmVyOiBfdGhpcy5tb250aENvbnRhaW5lciB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnByZVNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgaXNWYWxpZCh0aGlzLnByb3BzLnByZVNlbGVjdGlvbikgJiZcbiAgICAgICAgICAgICghaXNTYW1lRGF5KHRoaXMucHJvcHMucHJlU2VsZWN0aW9uLCBwcmV2UHJvcHMucHJlU2VsZWN0aW9uKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubW9udGhTZWxlY3RlZEluICE9PSBwcmV2UHJvcHMubW9udGhTZWxlY3RlZEluKSkge1xuICAgICAgICAgICAgdmFyIGhhc01vbnRoQ2hhbmdlZF8xID0gIWlzU2FtZU1vbnRoKHRoaXMuc3RhdGUuZGF0ZSwgdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0ZTogdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNNb250aENoYW5nZWRfMSAmJiBfdGhpcy5oYW5kbGVDdXN0b21Nb250aENoYW5nZShfdGhpcy5zdGF0ZS5kYXRlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5vcGVuVG9EYXRlICYmXG4gICAgICAgICAgICAhaXNTYW1lRGF5KHRoaXMucHJvcHMub3BlblRvRGF0ZSwgcHJldlByb3BzLm9wZW5Ub0RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLnByb3BzLm9wZW5Ub0RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIENvbnRhaW5lciA9IHRoaXMucHJvcHMuY29udGFpbmVyIHx8IENhbGVuZGFyQ29udGFpbmVyO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xpY2tPdXRzaWRlV3JhcHBlciwgeyBvbkNsaWNrT3V0c2lkZTogdGhpcy5oYW5kbGVDbGlja091dHNpZGUsIHN0eWxlOiB7IGRpc3BsYXk6IFwiY29udGVudHNcIiB9LCBpZ25vcmVDbGFzczogdGhpcy5wcm9wcy5vdXRzaWRlQ2xpY2tJZ25vcmVDbGFzcyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6IFwiY29udGVudHNcIiB9LCByZWY6IHRoaXMuY29udGFpbmVyUmVmIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb250YWluZXIsIHsgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtZGF0ZXBpY2tlclwiLCB0aGlzLnByb3BzLmNsYXNzTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyLS10aW1lLW9ubHlcIjogdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHksXG4gICAgICAgICAgICAgICAgICAgIH0pLCBzaG93VGltZTogdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCB8fCB0aGlzLnByb3BzLnNob3dUaW1lSW5wdXQsIHNob3dUaW1lU2VsZWN0T25seTogdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHksIGlubGluZTogdGhpcy5wcm9wcy5pbmxpbmUgfSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJBcmlhTGl2ZVJlZ2lvbigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm1vbnRoSGVhZGVyUG9zaXRpb24gPT09IFwidG9wXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUHJldmlvdXNCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tb250aEhlYWRlclBvc2l0aW9uID09PSBcInRvcFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5leHRCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJNb250aHMoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJZZWFycygpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRvZGF5QnV0dG9uKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGltZVNlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJJbnB1dFRpbWVTZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oKSkpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXI7XG59KENvbXBvbmVudCkpO1xuXG4vKipcbiAqIGBDYWxlbmRhckljb25gIGlzIGEgUmVhY3QgY29tcG9uZW50IHRoYXQgcmVuZGVycyBhbiBpY29uIGZvciBhIGNhbGVuZGFyLlxuICogVGhlIGljb24gY2FuIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIENTUyBjbGFzcywgYSBSZWFjdCBub2RlLCBvciBhIGRlZmF1bHQgU1ZHIGljb24uXG4gKlxuICogQGNvbXBvbmVudFxuICogQHByb3AgIGljb24gLSBUaGUgaWNvbiB0byBiZSBkaXNwbGF5ZWQuIFRoaXMgY2FuIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIENTUyBjbGFzcyBvciBhIFJlYWN0IG5vZGUuXG4gKiBAcHJvcCAgY2xhc3NOYW1lIC0gQW4gb3B0aW9uYWwgc3RyaW5nIHJlcHJlc2VudGluZyBhZGRpdGlvbmFsIENTUyBjbGFzc2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGljb24uXG4gKiBAcHJvcCAgb25DbGljayAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBpY29uIGlzIGNsaWNrZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRvIHVzZSBhIENTUyBjbGFzcyBhcyB0aGUgaWNvblxuICogPENhbGVuZGFySWNvbiBpY29uPVwibXktaWNvbi1jbGFzc1wiIG9uQ2xpY2s9e215Q2xpY2tIYW5kbGVyfSAvPlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUbyB1c2UgYSBSZWFjdCBub2RlIGFzIHRoZSBpY29uXG4gKiA8Q2FsZW5kYXJJY29uIGljb249ezxNeUljb25Db21wb25lbnQgLz59IG9uQ2xpY2s9e215Q2xpY2tIYW5kbGVyfSAvPlxuICpcbiAqIEByZXR1cm5zICBUaGUgYENhbGVuZGFySWNvbmAgY29tcG9uZW50LlxuICovXG52YXIgQ2FsZW5kYXJJY29uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGljb24gPSBfYS5pY29uLCBfYiA9IF9hLmNsYXNzTmFtZSwgY2xhc3NOYW1lID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYiwgb25DbGljayA9IF9hLm9uQ2xpY2s7XG4gICAgdmFyIGRlZmF1bHRDbGFzcyA9IFwicmVhY3QtZGF0ZXBpY2tlcl9fY2FsZW5kYXItaWNvblwiO1xuICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpXCIsIHsgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChkZWZhdWx0Q2xhc3MsIFwiIFwiKS5jb25jYXQoaWNvbiwgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUpLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBvbkNsaWNrOiBvbkNsaWNrIH0pKTtcbiAgICB9XG4gICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGljb24pKSB7XG4gICAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGNoZWNraW5nIHRoYXQgdHlwZW9mIGljb24gaXMgc3RyaW5nIGZpcnN0LCB3ZSBjYW4gc2FmZWx5IGNhc3QgaWNvbiBhcyBSZWFjdC5SZWFjdEVsZW1lbnQgb24gdHlwZXMgbGV2ZWwgYW5kIGNvZGUgbGV2ZWxcbiAgICAgICAgdmFyIGljb25FbGVtZW50XzEgPSBpY29uO1xuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGljb25FbGVtZW50XzEsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoaWNvbkVsZW1lbnRfMS5wcm9wcy5jbGFzc05hbWUgfHwgXCJcIiwgXCIgXCIpLmNvbmNhdChkZWZhdWx0Q2xhc3MsIFwiIFwiKS5jb25jYXQoY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaWNvbkVsZW1lbnRfMS5wcm9wcy5vbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbkVsZW1lbnRfMS5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgU1ZHIEljb25cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwiXCIuY29uY2F0KGRlZmF1bHRDbGFzcywgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUpLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCA0NDggNTEyXCIsIG9uQ2xpY2s6IG9uQ2xpY2sgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk05NiAzMlY2NEg0OEMyMS41IDY0IDAgODUuNSAwIDExMnY0OEg0NDhWMTEyYzAtMjYuNS0yMS41LTQ4LTQ4LTQ4SDM1MlYzMmMwLTE3LjctMTQuMy0zMi0zMi0zMnMtMzIgMTQuMy0zMiAzMlY2NEgxNjBWMzJjMC0xNy43LTE0LjMtMzItMzItMzJTOTYgMTQuMyA5NiAzMnpNNDQ4IDE5MkgwVjQ2NGMwIDI2LjUgMjEuNSA0OCA0OCA0OEg0MDBjMjYuNSAwIDQ4LTIxLjUgNDgtNDhWMTkyelwiIH0pKSk7XG59O1xuXG4vKipcbiAqIGBQb3J0YWxgIGlzIGEgUmVhY3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHlvdSB0byByZW5kZXIgY2hpbGRyZW4gaW50byBhIERPTSBub2RlXG4gKiB0aGF0IGV4aXN0cyBvdXRzaWRlIHRoZSBET00gaGllcmFyY2h5IG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtQb3J0YWxQcm9wc30gcHJvcHMgLSBUaGUgcHJvcGVydGllcyB0aGF0IGRlZmluZSB0aGUgYFBvcnRhbGAgY29tcG9uZW50LlxuICogQHByb3BlcnR5IHtSZWFjdC5SZWFjdE5vZGV9IHByb3BzLmNoaWxkcmVuIC0gVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGludG8gdGhlIGBQb3J0YWxgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3BzLnBvcnRhbElkIC0gVGhlIGlkIG9mIHRoZSBET00gbm9kZSBpbnRvIHdoaWNoIHRoZSBgUG9ydGFsYCB3aWxsIHJlbmRlci5cbiAqIEBwcm9wZXJ0eSB7U2hhZG93Um9vdH0gW3Byb3BzLnBvcnRhbEhvc3RdIC0gVGhlIERPTSBub2RlIHRvIGhvc3QgdGhlIGBQb3J0YWxgLlxuICovXG52YXIgUG9ydGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9ydGFsKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wb3J0YWxSb290ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvcnRhbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucG9ydGFsUm9vdCA9ICh0aGlzLnByb3BzLnBvcnRhbEhvc3QgfHwgZG9jdW1lbnQpLmdldEVsZW1lbnRCeUlkKHRoaXMucHJvcHMucG9ydGFsSWQpO1xuICAgICAgICBpZiAoIXRoaXMucG9ydGFsUm9vdCkge1xuICAgICAgICAgICAgdGhpcy5wb3J0YWxSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMucG9ydGFsUm9vdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLnByb3BzLnBvcnRhbElkKTtcbiAgICAgICAgICAgICh0aGlzLnByb3BzLnBvcnRhbEhvc3QgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQodGhpcy5wb3J0YWxSb290KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcnRhbFJvb3QuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgfTtcbiAgICBQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3J0YWxSb290KSB7XG4gICAgICAgICAgICB0aGlzLnBvcnRhbFJvb3QucmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcnRhbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKHRoaXMucHJvcHMuY2hpbGRyZW4sIHRoaXMuZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcnRhbDtcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBmb2N1c2FibGVFbGVtZW50c1NlbGVjdG9yID0gXCJbdGFiaW5kZXhdLCBhLCBidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhXCI7XG52YXIgZm9jdXNhYmxlRmlsdGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBub2RlLnRhYkluZGV4ICE9PSAtMTtcbiAgICB9XG4gICAgcmV0dXJuICFub2RlLmRpc2FibGVkICYmIG5vZGUudGFiSW5kZXggIT09IC0xO1xufTtcbi8qKlxuICogYFRhYkxvb3BgIGlzIGEgUmVhY3QgY29tcG9uZW50IHRoYXQgbWFuYWdlcyB0YWJiaW5nIGJlaGF2aW9yIGZvciBpdHMgY2hpbGRyZW4uXG4gKlxuICogVGFiTG9vcCBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIHRhYmJpbmcgb3V0c2lkZSBvZiB0aGUgcG9wcGVyXG4gKiBJdCBjcmVhdGVzIGEgdGFiaW5kZXggbG9vcCBzbyB0aGF0IFwiVGFiXCIgb24gdGhlIGxhc3QgZWxlbWVudCB3aWxsIGZvY3VzIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBhbmQgXCJTaGlmdCBUYWJcIiBvbiB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGZvY3VzIHRoZSBsYXN0IGVsZW1lbnRcbiAqXG4gKiBAY29tcG9uZW50XG4gKiBAZXhhbXBsZVxuICogPFRhYkxvb3AgZW5hYmxlVGFiTG9vcD17dHJ1ZX0+XG4gKiAgIDxDaGlsZENvbXBvbmVudCAvPlxuICogPC9UYWJMb29wPlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIHRoZSBgVGFiTG9vcGAgY29tcG9uZW50LlxuICogQHBhcmFtIHByb3BzLmNoaWxkcmVuIC0gVGhlIGNoaWxkIGNvbXBvbmVudHMuXG4gKiBAcGFyYW0gcHJvcHMuZW5hYmxlVGFiTG9vcCAtIFdoZXRoZXIgdG8gZW5hYmxlIHRoZSB0YWIgbG9vcC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYFRhYkxvb3BgIGNvbXBvbmVudC5cbiAqL1xudmFyIFRhYkxvb3AgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYkxvb3AsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFiTG9vcChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBnZXRUYWJDaGlsZHJlbmAgaXMgYSBtZXRob2Qgb2YgdGhlIGBUYWJMb29wYCBjbGFzcyB0aGF0IHJldHJpZXZlcyBhbGwgdGFiYmFibGUgY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgYHRhYmJhYmxlYCBsaWJyYXJ5IHRvIGZpbmQgYWxsIHRhYmJhYmxlIGVsZW1lbnRzIHdpdGhpbiB0aGUgYFRhYkxvb3BgIGNvbXBvbmVudC5cbiAgICAgICAgICogSXQgdGhlbiBmaWx0ZXJzIG91dCBhbnkgZWxlbWVudHMgdGhhdCBhcmUgbm90IHZpc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCB0YWJiYWJsZSBhbmQgdmlzaWJsZSBjaGlsZHJlbiBvZiB0aGUgYFRhYkxvb3BgIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmdldFRhYkNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgICAgICAgIC5jYWxsKChfYSA9IF90aGlzLnRhYkxvb3BSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlRWxlbWVudHNTZWxlY3RvciksIDEsIC0xKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZm9jdXNhYmxlRmlsdGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRm9jdXNTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YWJDaGlsZHJlbiA9IF90aGlzLmdldFRhYkNoaWxkcmVuKCk7XG4gICAgICAgICAgICB0YWJDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIHRhYkNoaWxkcmVuLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICB0YWJDaGlsZHJlblt0YWJDaGlsZHJlbi5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVGb2N1c0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YWJDaGlsZHJlbiA9IF90aGlzLmdldFRhYkNoaWxkcmVuKCk7XG4gICAgICAgICAgICB0YWJDaGlsZHJlbiAmJiB0YWJDaGlsZHJlbi5sZW5ndGggPiAxICYmIHRhYkNoaWxkcmVuWzBdLmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRhYkxvb3BSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJMb29wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5wcm9wcy5lbmFibGVUYWJMb29wKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBUYWJMb29wLmRlZmF1bHRQcm9wcy5lbmFibGVUYWJMb29wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RhYi1sb29wXCIsIHJlZjogdGhpcy50YWJMb29wUmVmIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RhYi1sb29wX19zdGFydFwiLCB0YWJJbmRleDogMCwgb25Gb2N1czogdGhpcy5oYW5kbGVGb2N1c1N0YXJ0IH0pLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGFiLWxvb3BfX2VuZFwiLCB0YWJJbmRleDogMCwgb25Gb2N1czogdGhpcy5oYW5kbGVGb2N1c0VuZCB9KSkpO1xuICAgIH07XG4gICAgVGFiTG9vcC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGVuYWJsZVRhYkxvb3A6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gVGFiTG9vcDtcbn0oQ29tcG9uZW50KSk7XG5cbi8qKlxuICogYHdpdGhGbG9hdGluZ2AgaXMgYSBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRoYXQgYWRkcyBmbG9hdGluZyBiZWhhdmlvciB0byBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gQ29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCB0byBlbmhhbmNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBGbG9hdGluZ0NvbXBvbmVudCA9IHdpdGhGbG9hdGluZyhNeUNvbXBvbmVudCk7XG4gKiA8RmxvYXRpbmdDb21wb25lbnQgcG9wcGVyTW9kaWZpZXJzPXtbXX0gcG9wcGVyUHJvcHM9e3t9fSBoaWRlUG9wcGVyPXt0cnVlfSAvPlxuICpcbiAqIEBwYXJhbSBwb3BwZXJNb2RpZmllcnMgLSBUaGUgbW9kaWZpZXJzIHRvIHVzZSBmb3IgdGhlIHBvcHBlci5cbiAqIEBwYXJhbSBwb3BwZXJQcm9wcyAtIFRoZSBwcm9wcyB0byBwYXNzIHRvIHRoZSBwb3BwZXIuXG4gKiBAcGFyYW0gaGlkZVBvcHBlciAtIFdoZXRoZXIgdG8gaGlkZSB0aGUgcG9wcGVyLlxuICogQHBhcmFtIHBvcHBlclBsYWNlbWVudCAtIFRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBjb21wb25lbnQgd2l0aCBmbG9hdGluZyBiZWhhdmlvci5cbiAqL1xuZnVuY3Rpb24gd2l0aEZsb2F0aW5nKENvbXBvbmVudCkge1xuICAgIGZ1bmN0aW9uIFdpdGhGbG9hdGluZyhwcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBoaWRlUG9wcGVyID0gdHlwZW9mIHByb3BzLmhpZGVQb3BwZXIgPT09IFwiYm9vbGVhblwiID8gcHJvcHMuaGlkZVBvcHBlciA6IHRydWU7XG4gICAgICAgIHZhciBhcnJvd1JlZiA9IHVzZVJlZihudWxsKTtcbiAgICAgICAgdmFyIGZsb2F0aW5nUHJvcHMgPSB1c2VGbG9hdGluZyhfYXNzaWduKHsgb3BlbjogIWhpZGVQb3BwZXIsIHdoaWxlRWxlbWVudHNNb3VudGVkOiBhdXRvVXBkYXRlLCBwbGFjZW1lbnQ6IHByb3BzLnBvcHBlclBsYWNlbWVudCwgbWlkZGxld2FyZTogX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICAgICAgZmxpcCh7IHBhZGRpbmc6IDE1IH0pLFxuICAgICAgICAgICAgICAgIG9mZnNldCgxMCksXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3JlZnMgLS0gRmxvYXRpbmcgVUkgcmVxdWlyZXMgcmVmcyB0byBiZSBwYXNzZWQgZHVyaW5nIHJlbmRlclxuICAgICAgICAgICAgICAgIGFycm93KHsgZWxlbWVudDogYXJyb3dSZWYgfSlcbiAgICAgICAgICAgIF0sICgoX2EgPSBwcm9wcy5wb3BwZXJNb2RpZmllcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSwgdHJ1ZSkgfSwgcHJvcHMucG9wcGVyUHJvcHMpKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudFByb3BzID0gX2Fzc2lnbihfYXNzaWduKHt9LCBwcm9wcyksIHsgaGlkZVBvcHBlcjogaGlkZVBvcHBlciwgcG9wcGVyUHJvcHM6IF9hc3NpZ24oX2Fzc2lnbih7fSwgZmxvYXRpbmdQcm9wcyksIHsgYXJyb3dSZWY6IGFycm93UmVmIH0pIH0pO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9hc3NpZ24oe30sIGNvbXBvbmVudFByb3BzKSk7XG4gICAgfVxuICAgIFdpdGhGbG9hdGluZy5kaXNwbGF5TmFtZSA9IFwid2l0aEZsb2F0aW5nKFwiLmNvbmNhdChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIiwgXCIpXCIpO1xuICAgIHJldHVybiBXaXRoRmxvYXRpbmc7XG59XG5cbi8vIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG52YXIgUG9wcGVyQ29tcG9uZW50JDEgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCB3cmFwcGVyQ2xhc3NOYW1lID0gcHJvcHMud3JhcHBlckNsYXNzTmFtZSwgX2EgPSBwcm9wcy5oaWRlUG9wcGVyLCBoaWRlUG9wcGVyID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYSwgcG9wcGVyQ29tcG9uZW50ID0gcHJvcHMucG9wcGVyQ29tcG9uZW50LCB0YXJnZXRDb21wb25lbnQgPSBwcm9wcy50YXJnZXRDb21wb25lbnQsIGVuYWJsZVRhYkxvb3AgPSBwcm9wcy5lbmFibGVUYWJMb29wLCBwb3BwZXJPbktleURvd24gPSBwcm9wcy5wb3BwZXJPbktleURvd24sIHBvcnRhbElkID0gcHJvcHMucG9ydGFsSWQsIHBvcnRhbEhvc3QgPSBwcm9wcy5wb3J0YWxIb3N0LCBwb3BwZXJQcm9wcyA9IHByb3BzLnBvcHBlclByb3BzLCBzaG93QXJyb3cgPSBwcm9wcy5zaG93QXJyb3csIHBvcHBlclRhcmdldFJlZiA9IHByb3BzLnBvcHBlclRhcmdldFJlZiwgbW9udGhIZWFkZXJQb3NpdGlvbiA9IHByb3BzLm1vbnRoSGVhZGVyUG9zaXRpb247XG4gICAgLy8gV2hlbiBhIGN1c3RvbSBwb3BwZXJUYXJnZXRSZWYgaXMgcHJvdmlkZWQsIHVzZSBpdCBhcyB0aGUgcG9zaXRpb24gcmVmZXJlbmNlXG4gICAgLy8gVGhpcyBhbGxvd3MgdGhlIHBvcHBlciB0byBiZSBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIGEgc3BlY2lmaWMgZWxlbWVudFxuICAgIC8vIHdpdGhpbiB0aGUgY3VzdG9tIGlucHV0LCByYXRoZXIgdGhhbiB0aGUgd3JhcHBlciBkaXZcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocG9wcGVyVGFyZ2V0UmVmID09PSBudWxsIHx8IHBvcHBlclRhcmdldFJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wcGVyVGFyZ2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHBvcHBlclByb3BzLnJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UocG9wcGVyVGFyZ2V0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgW3BvcHBlclRhcmdldFJlZiwgcG9wcGVyUHJvcHMucmVmc10pO1xuICAgIHZhciBwb3BwZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKCFoaWRlUG9wcGVyKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gY2xzeChcInJlYWN0LWRhdGVwaWNrZXItcG9wcGVyXCIsICFzaG93QXJyb3cgJiYgXCJyZWFjdC1kYXRlcGlja2VyLXBvcHBlci1vZmZzZXRcIiwgbW9udGhIZWFkZXJQb3NpdGlvbiA9PT0gXCJtaWRkbGVcIiAmJlxuICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyLXBvcHBlci0taGVhZGVyLW1pZGRsZVwiLCBtb250aEhlYWRlclBvc2l0aW9uID09PSBcImJvdHRvbVwiICYmXG4gICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXItcG9wcGVyLS1oZWFkZXItYm90dG9tXCIsIGNsYXNzTmFtZSk7XG4gICAgICAgIHBvcHBlciA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFRhYkxvb3AsIHsgZW5hYmxlVGFiTG9vcDogZW5hYmxlVGFiTG9vcCB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcG9wcGVyUHJvcHMucmVmcy5zZXRGbG9hdGluZywgc3R5bGU6IHBvcHBlclByb3BzLmZsb2F0aW5nU3R5bGVzLCBjbGFzc05hbWU6IGNsYXNzZXMsIFwiZGF0YS1wbGFjZW1lbnRcIjogcG9wcGVyUHJvcHMucGxhY2VtZW50LCBvbktleURvd246IHBvcHBlck9uS2V5RG93biB9LFxuICAgICAgICAgICAgICAgIHBvcHBlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzaG93QXJyb3cgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdBcnJvdywgeyByZWY6IHBvcHBlclByb3BzLmFycm93UmVmLCBjb250ZXh0OiBwb3BwZXJQcm9wcy5jb250ZXh0LCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogMSwgaGVpZ2h0OiA4LCB3aWR0aDogMTYsIHN0eWxlOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC0xcHgpXCIgfSwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RyaWFuZ2xlXCIgfSkpKSkpO1xuICAgIH1cbiAgICBpZiAocHJvcHMucG9wcGVyQ29udGFpbmVyKSB7XG4gICAgICAgIHBvcHBlciA9IGNyZWF0ZUVsZW1lbnQocHJvcHMucG9wcGVyQ29udGFpbmVyLCB7fSwgcG9wcGVyKTtcbiAgICB9XG4gICAgaWYgKHBvcnRhbElkICYmICFoaWRlUG9wcGVyKSB7XG4gICAgICAgIHBvcHBlciA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBwb3J0YWxJZDogcG9ydGFsSWQsIHBvcnRhbEhvc3Q6IHBvcnRhbEhvc3QgfSwgcG9wcGVyKSk7XG4gICAgfVxuICAgIHZhciB3cmFwcGVyQ2xhc3NlcyA9IGNsc3goXCJyZWFjdC1kYXRlcGlja2VyLXdyYXBwZXJcIiwgd3JhcHBlckNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBwb3BwZXJQcm9wcy5yZWZzLnNldFJlZmVyZW5jZSwgY2xhc3NOYW1lOiB3cmFwcGVyQ2xhc3NlcyB9LCB0YXJnZXRDb21wb25lbnQpLFxuICAgICAgICBwb3BwZXIpKTtcbn07XG52YXIgUG9wcGVyQ29tcG9uZW50ID0gd2l0aEZsb2F0aW5nKFBvcHBlckNvbXBvbmVudCQxKTtcblxuLy8gQ29tcGFyZXMgZGF0ZXMgeWVhcittb250aCBjb21iaW5hdGlvbnNcbmZ1bmN0aW9uIGhhc1ByZVNlbGVjdGlvbkNoYW5nZWQoZGF0ZTEsIGRhdGUyKSB7XG4gICAgaWYgKGRhdGUxICYmIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiAoZ2V0TW9udGgoZGF0ZTEpICE9PSBnZXRNb250aChkYXRlMikgfHwgZ2V0WWVhcihkYXRlMSkgIT09IGdldFllYXIoZGF0ZTIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGUxICE9PSBkYXRlMjtcbn1cbi8qKlxuICogR2VuZXJhbCBkYXRlcGlja2VyIGNvbXBvbmVudC5cbiAqL1xudmFyIElOUFVUX0VSUl8xID0gXCJEYXRlIGlucHV0IG5vdCB2YWxpZC5cIjtcbnZhciBEYXRlUGlja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlUGlja2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhdGVQaWNrZXIocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaW5wdXQgPSBudWxsO1xuICAgICAgICBfdGhpcy5nZXRQcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGltZVpvbmUgPSBfdGhpcy5wcm9wcy50aW1lWm9uZTtcbiAgICAgICAgICAgIHZhciBiYXNlRGF0ZSA9IF90aGlzLnByb3BzLm9wZW5Ub0RhdGVcbiAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLm9wZW5Ub0RhdGVcbiAgICAgICAgICAgICAgICA6IF90aGlzLnByb3BzLnNlbGVjdHNFbmQgJiYgX3RoaXMucHJvcHMuc3RhcnREYXRlXG4gICAgICAgICAgICAgICAgICAgID8gX3RoaXMucHJvcHMuc3RhcnREYXRlXG4gICAgICAgICAgICAgICAgICAgIDogX3RoaXMucHJvcHMuc2VsZWN0c1N0YXJ0ICYmIF90aGlzLnByb3BzLmVuZERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX3RoaXMucHJvcHMuZW5kRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXdEYXRlKCk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHRoZSBzcGVjaWZpZWQgdGltZXpvbmUgZm9yIGRpc3BsYXlcbiAgICAgICAgICAgIHJldHVybiB0aW1lWm9uZSA/IHRvWm9uZWRUaW1lKGJhc2VEYXRlLCB0aW1lWm9uZSkgOiBiYXNlRGF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgZGF0ZSBmcm9tIHN0cmluZyBmb3JtYXQgdG8gc3RhbmRhcmQgRGF0ZSBmb3JtYXRcbiAgICAgICAgLy8gVXNlcyBwYXJzZURhdGUgd2l0aCBJU08gZm9ybWF0IHRvIHBhcnNlIGFzIGxvY2FsIHRpbWUsIHByZXZlbnRpbmdcbiAgICAgICAgLy8gZGF0ZXMgZnJvbSBzaGlmdGluZyBpbiB0aW1lem9uZXMgd2VzdCBvZiBVVEMuIFNlZSBpc3N1ZSAjNjEwNS5cbiAgICAgICAgX3RoaXMubW9kaWZ5SG9saWRheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gX3RoaXMucHJvcHMuaG9saWRheXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBob2xpZGF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBwYXJzZURhdGUoaG9saWRheS5kYXRlLCBcInl5eXktTU0tZGRcIiwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYWNjdW11bGF0b3IsIHRydWUpLCBbX2Fzc2lnbihfYXNzaWduKHt9LCBob2xpZGF5KSwgeyBkYXRlOiBkYXRlIH0pXSwgZmFsc2UpO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jYWxjSW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpbWVab25lID0gX3RoaXMucHJvcHMudGltZVpvbmU7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFByZVNlbGVjdGlvbiA9IF90aGlzLmdldFByZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIG1pbkRhdGUgPSBnZXRFZmZlY3RpdmVNaW5EYXRlKF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBtYXhEYXRlID0gZ2V0RWZmZWN0aXZlTWF4RGF0ZShfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB2YXIgYm91bmRlZFByZVNlbGVjdGlvbiA9IG1pbkRhdGUgJiYgaXNCZWZvcmUoZGVmYXVsdFByZVNlbGVjdGlvbiwgZ2V0U3RhcnRPZkRheShtaW5EYXRlKSlcbiAgICAgICAgICAgICAgICA/IG1pbkRhdGVcbiAgICAgICAgICAgICAgICA6IG1heERhdGUgJiYgaXNBZnRlcihkZWZhdWx0UHJlU2VsZWN0aW9uLCBnZXRFbmRPZkRheShtYXhEYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgPyBtYXhEYXRlXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc2VsZWN0ZWQvc3RhcnREYXRlIHRvIHpvbmVkIHRpbWUgZm9yIGRpc3BsYXkgaWYgdGltZXpvbmUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICB2YXIgaW5pdGlhbFByZVNlbGVjdGlvbiA9IF90aGlzLnByb3BzLnNlbGVjdHNSYW5nZVxuICAgICAgICAgICAgICAgID8gX3RoaXMucHJvcHMuc3RhcnREYXRlXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIGlmIChpbml0aWFsUHJlU2VsZWN0aW9uICYmIHRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFByZVNlbGVjdGlvbiA9IHRvWm9uZWRUaW1lKGluaXRpYWxQcmVTZWxlY3Rpb24sIHRpbWVab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BlbjogX3RoaXMucHJvcHMuc3RhcnRPcGVuIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByZXZlbnRGb2N1czogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb246IGluaXRpYWxQcmVTZWxlY3Rpb24gIT09IG51bGwgJiYgaW5pdGlhbFByZVNlbGVjdGlvbiAhPT0gdm9pZCAwID8gaW5pdGlhbFByZVNlbGVjdGlvbiA6IGJvdW5kZWRQcmVTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtaW5nIGhpZ2hsaWdodGVkIGRheXMgKHBlcmhhcHMgbmVzdGVkIGFycmF5KVxuICAgICAgICAgICAgICAgIC8vIHRvIGZsYXQgTWFwIGZvciBmYXN0ZXIgYWNjZXNzIGluIGRheS5qc3hcbiAgICAgICAgICAgICAgICBoaWdobGlnaHREYXRlczogZ2V0SGlnaExpZ2h0RGF5c01hcChfdGhpcy5wcm9wcy5oaWdobGlnaHREYXRlcyksXG4gICAgICAgICAgICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gdXNlZCB0byBmb2N1cyBkYXkgaW4gaW5saW5lIHZlcnNpb24gYWZ0ZXIgbW9udGggaGFzIGNoYW5nZWQsIGJ1dCBub3Qgb25cbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRGF5SW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1JlbmRlckFyaWFMaXZlTWVzc2FnZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FzSGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldElucHV0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgbG9jYWxlID0gX2IubG9jYWxlLCBzdGFydERhdGUgPSBfYi5zdGFydERhdGUsIGVuZERhdGUgPSBfYi5lbmREYXRlLCByYW5nZVNlcGFyYXRvciA9IF9iLnJhbmdlU2VwYXJhdG9yLCBzZWxlY3RlZCA9IF9iLnNlbGVjdGVkLCBzZWxlY3RlZERhdGVzID0gX2Iuc2VsZWN0ZWREYXRlcywgc2VsZWN0c011bHRpcGxlID0gX2Iuc2VsZWN0c011bHRpcGxlLCBzZWxlY3RzUmFuZ2UgPSBfYi5zZWxlY3RzUmFuZ2UsIGZvcm1hdE11bHRpcGxlRGF0ZXMgPSBfYi5mb3JtYXRNdWx0aXBsZURhdGVzLCB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGRhdGVGb3JtYXQgPSAoX2EgPSBfdGhpcy5wcm9wcy5kYXRlRm9ybWF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEYXRlUGlja2VyLmRlZmF1bHRQcm9wcy5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWUgPSBfdGhpcy5zdGF0ZS5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZURhdGVSYW5nZUZvcm1hdChzdGFydERhdGUsIGVuZERhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlU2VwYXJhdG9yOiByYW5nZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdHNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRNdWx0aXBsZURhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXREYXRlRm4gPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVEYXRlRm9ybWF0KGRhdGUsIHsgZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCwgbG9jYWxlOiBsb2NhbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNdWx0aXBsZURhdGVzKHNlbGVjdGVkRGF0ZXMgIT09IG51bGwgJiYgc2VsZWN0ZWREYXRlcyAhPT0gdm9pZCAwID8gc2VsZWN0ZWREYXRlcyA6IFtdLCBmb3JtYXREYXRlRm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZU11bHRpcGxlRGF0ZXNGb3JtYXQoc2VsZWN0ZWREYXRlcyAhPT0gbnVsbCAmJiBzZWxlY3RlZERhdGVzICE9PSB2b2lkIDAgPyBzZWxlY3RlZERhdGVzIDogW10sIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FmZURhdGVGb3JtYXQoc2VsZWN0ZWQsIHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlc2V0SGlkZGVuU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX2Fzc2lnbihfYXNzaWduKHt9LCBfdGhpcy5zdGF0ZSksIHsgd2FzSGlkZGVuOiBmYWxzZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEhpZGRlblN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9hc3NpZ24oX2Fzc2lnbih7fSwgX3RoaXMuc3RhdGUpLCB7IHdhc0hpZGRlbjogdHJ1ZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEhpZGRlblN0YXRlT25WaXNpYmlsaXR5SGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldEhpZGRlblN0YXR1cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jbGVhclByZXZlbnRGb2N1c1RpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJldmVudEZvY3VzVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5wcmV2ZW50Rm9jdXNUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMuaW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0Qmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5pbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJsdXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVmZXJCbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRCbHVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0T3BlbiA9IGZ1bmN0aW9uIChvcGVuLCBza2lwU2V0Qmx1cikge1xuICAgICAgICAgICAgaWYgKHNraXBTZXRCbHVyID09PSB2b2lkIDApIHsgc2tpcFNldEJsdXIgPSBmYWxzZTsgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBvcGVuICYmIF90aGlzLnN0YXRlLm9wZW5cbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5zdGF0ZS5wcmVTZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5jYWxjSW5pdGlhbFN0YXRlKCkucHJlU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGxhc3RQcmVTZWxlY3RDaGFuZ2U6IFBSRVNFTEVDVF9DSEFOR0VfVklBX05BVklHQVRFLFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghb3Blbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWQ6IHNraXBTZXRCbHVyID8gcHJldi5mb2N1c2VkIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAhc2tpcFNldEJsdXIgJiYgX3RoaXMuZGVmZXJCbHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pbnB1dE9rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNEYXRlKF90aGlzLnN0YXRlLnByZVNlbGVjdGlvbik7IH07XG4gICAgICAgIF90aGlzLmlzQ2FsZW5kYXJPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9wZW4gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gX3RoaXMuc3RhdGUub3BlbiAmJiAhX3RoaXMucHJvcHMuZGlzYWJsZWQgJiYgIV90aGlzLnByb3BzLnJlYWRPbmx5XG4gICAgICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5vcGVuO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBpc0F1dG9SZUZvY3VzID0gX3RoaXMuc3RhdGUud2FzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIGlzT3BlbkFsbG93ZWQgPSBpc0F1dG9SZUZvY3VzID8gX3RoaXMuc3RhdGUub3BlbiA6IHRydWU7XG4gICAgICAgICAgICBpZiAoaXNBdXRvUmVGb2N1cykge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0SGlkZGVuU3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLnN0YXRlLnByZXZlbnRGb2N1cykge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkZvY3VzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc09wZW5BbGxvd2VkICYmXG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5wcm9wcy5wcmV2ZW50T3Blbk9uRm9jdXMgJiZcbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZW5kRm9jdXNCYWNrVG9JbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJldmVudEZvY3VzVGltZW91dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyUHJldmVudEZvY3VzVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHBvcHBlciBhbmQgcmVmb2N1cyB0aGUgaW5wdXRcbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIGlucHV0IGZyb20gYXV0byBvcGVuaW5nIG9uRm9jdXNcbiAgICAgICAgICAgIC8vIHNldEZvY3VzIHRvIHRoZSBpbnB1dFxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmV2ZW50Rm9jdXM6IHRydWUgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByZXZlbnRGb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmV2ZW50Rm9jdXM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuaW5wdXRGb2N1c1RpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMuaW5wdXRGb2N1c1RpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRlZmVyRm9jdXNJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQoKTtcbiAgICAgICAgICAgIF90aGlzLmlucHV0Rm9jdXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRGb2N1cygpOyB9LCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJvcGRvd25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVzZXRJbnB1dFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX2Fzc2lnbihfYXNzaWduKHt9LCBfdGhpcy5zdGF0ZSksIHsgaW5wdXRWYWx1ZTogbnVsbCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnN0YXRlLm9wZW4gfHwgX3RoaXMucHJvcHMud2l0aFBvcnRhbCB8fCBfdGhpcy5wcm9wcy5zaG93VGltZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uQmx1cikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLm9wZW4gJiYgX3RoaXMucHJvcHMub3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNhbGVuZGFyQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkNsaWNrT3V0c2lkZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy53aXRoUG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gaGFuZGxlQ2hhbmdlIGlzIGNhbGxlZCB3aGVuIHVzZXIgdHlwZXMgaW4gdGhlIHRleHRib3hcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICB2YXIgYWxsQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhbGxBcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBhbGxBcmdzWzBdO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2hhbmdlUmF3KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2VSYXcuYXBwbHkoX3RoaXMsIGFsbEFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCAhPT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC50YXJnZXQpIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCA/IGV2ZW50LnRhcmdldC52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFzdFByZVNlbGVjdENoYW5nZTogUFJFU0VMRUNUX0NIQU5HRV9WSUFfSU5QVVQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfZyA9IF90aGlzLnByb3BzLCBzZWxlY3RzUmFuZ2UgPSBfZy5zZWxlY3RzUmFuZ2UsIHN0YXJ0RGF0ZSA9IF9nLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9nLmVuZERhdGU7XG4gICAgICAgICAgICB2YXIgZGF0ZUZvcm1hdCA9IChfYSA9IF90aGlzLnByb3BzLmRhdGVGb3JtYXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICB2YXIgc3RyaWN0UGFyc2luZyA9IChfYiA9IF90aGlzLnByb3BzLnN0cmljdFBhcnNpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLnN0cmljdFBhcnNpbmc7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnRhcmdldCkgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ID8gZXZlbnQudGFyZ2V0LnZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VTZXBhcmF0b3IgPSBfdGhpcy5wcm9wcy5yYW5nZVNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICB2YXIgdHJpbW1lZFJhbmdlU2VwYXJhdG9yID0gcmFuZ2VTZXBhcmF0b3IudHJpbSgpO1xuICAgICAgICAgICAgICAgIHZhciBfaCA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdChkYXRlRm9ybWF0LmluY2x1ZGVzKHRyaW1tZWRSYW5nZVNlcGFyYXRvcilcbiAgICAgICAgICAgICAgICAgICAgPyByYW5nZVNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICA6IHRyaW1tZWRSYW5nZVNlcGFyYXRvciwgMilcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwudHJpbSgpOyB9KSwgdmFsdWVTdGFydCA9IF9oWzBdLCB2YWx1ZUVuZCA9IF9oWzFdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydERhdGVOZXcgPSBwYXJzZURhdGUodmFsdWVTdGFydCAhPT0gbnVsbCAmJiB2YWx1ZVN0YXJ0ICE9PSB2b2lkIDAgPyB2YWx1ZVN0YXJ0IDogXCJcIiwgZGF0ZUZvcm1hdCwgX3RoaXMucHJvcHMubG9jYWxlLCBzdHJpY3RQYXJzaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kRGF0ZU5ldyA9IHN0YXJ0RGF0ZU5ld1xuICAgICAgICAgICAgICAgICAgICA/IHBhcnNlRGF0ZSh2YWx1ZUVuZCAhPT0gbnVsbCAmJiB2YWx1ZUVuZCAhPT0gdm9pZCAwID8gdmFsdWVFbmQgOiBcIlwiLCBkYXRlRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUsIHN0cmljdFBhcnNpbmcpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDaGFuZ2VkID0gKHN0YXJ0RGF0ZSA9PT0gbnVsbCB8fCBzdGFydERhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXJ0RGF0ZS5nZXRUaW1lKCkpICE9PSAoc3RhcnREYXRlTmV3ID09PSBudWxsIHx8IHN0YXJ0RGF0ZU5ldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhcnREYXRlTmV3LmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZENoYW5nZWQgPSAoZW5kRGF0ZSA9PT0gbnVsbCB8fCBlbmREYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbmREYXRlLmdldFRpbWUoKSkgIT09IChlbmREYXRlTmV3ID09PSBudWxsIHx8IGVuZERhdGVOZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuZERhdGVOZXcuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0Q2hhbmdlZCAmJiAhZW5kQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGFydERhdGVOZXcgJiYgaXNEYXlEaXNhYmxlZChzdGFydERhdGVOZXcsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmREYXRlTmV3ICYmIGlzRGF5RGlzYWJsZWQoZW5kRGF0ZU5ldywgX3RoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHByZVNlbGVjdGlvbiB0byBrZWVwIGNhbGVuZGFyIHZpZXdwb3J0IGNvbnNpc3RlbnQgd2hlbiByZW9wZW5pbmdcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc3RhcnREYXRlIGZvciBwcmVTZWxlY3Rpb24gdG8gbWF0Y2ggY2FsY0luaXRpYWxTdGF0ZSBiZWhhdmlvclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERhdGVOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmVTZWxlY3Rpb246IHN0YXJ0RGF0ZU5ldyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9kID0gKF9jID0gX3RoaXMucHJvcHMpLm9uQ2hhbmdlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgW3N0YXJ0RGF0ZU5ldywgZW5kRGF0ZU5ld10sIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzZWxlY3RzUmFuZ2VcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZSh2YWx1ZSwgZGF0ZUZvcm1hdCwgX3RoaXMucHJvcHMubG9jYWxlLCBzdHJpY3RQYXJzaW5nLCAoX2UgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc2VsZWN0aW9uIGlmIGVpdGhlciAoMSkgZGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCwgb3IgKDIpIGlucHV0IGZpZWxkIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKGRhdGUgfHwgIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFNlbGVjdGVkKGRhdGUsIGV2ZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIV90aGlzLnByb3BzLmlubGluZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBmdWxsIGRhdGUgcGFyc2luZyBmYWlsZWQgYnV0IHdlIGhhdmUgcGFydGlhbCBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGV4dHJhY3QgZGF0ZSBpbmZvIGZvciBjYWxlbmRhciBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZEYXRlID0gcGFyc2VEYXRlRm9yTmF2aWdhdGlvbih2YWx1ZSwgKF9mID0gX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBwcmVTZWxlY3Rpb24gaWYgbmF2RGF0ZSBpcyB2YWxpZCBhbmQgd2l0aGluIG1pbi9tYXggYm91bmRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXZEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIV90aGlzLnByb3BzLm1pbkRhdGUgfHwgIWlzQmVmb3JlKG5hdkRhdGUsIF90aGlzLnByb3BzLm1pbkRhdGUpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFfdGhpcy5wcm9wcy5tYXhEYXRlIHx8ICFpc0FmdGVyKG5hdkRhdGUsIF90aGlzLnByb3BzLm1heERhdGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmVTZWxlY3Rpb246IG5hdkRhdGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVNlbGVjdCA9IGZ1bmN0aW9uIChkYXRlLCBldmVudCwgbW9udGhTZWxlY3RlZEluKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMucmVhZE9ubHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZSwgc3RhcnREYXRlID0gX2Iuc3RhcnREYXRlLCBlbmREYXRlID0gX2IuZW5kRGF0ZSwgbG9jYWxlID0gX2IubG9jYWxlLCBzd2FwUmFuZ2UgPSBfYi5zd2FwUmFuZ2U7XG4gICAgICAgICAgICB2YXIgZGF0ZUZvcm1hdCA9IChfYSA9IF90aGlzLnByb3BzLmRhdGVGb3JtYXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICB2YXIgaXNEYXRlU2VsZWN0aW9uQ29tcGxldGUgPSAhc2VsZWN0c1JhbmdlIHx8XG4gICAgICAgICAgICAgICAgKHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSAmJiAoc3dhcFJhbmdlIHx8ICFpc0RhdGVCZWZvcmUoZGF0ZSwgc3RhcnREYXRlKSkpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3VsZENsb3NlT25TZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAhX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICBpc0RhdGVTZWxlY3Rpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRpbmcgb25Gb2N1cyBldmVudCB0byBmaXggaXNzdWVcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vSGFja2VyMHgwMS9yZWFjdC1kYXRlcGlja2VyL2lzc3Vlcy82MjhcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kRm9jdXNCYWNrVG9JbnB1dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2hhbmdlUmF3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZERhdGUgPSBzYWZlRGF0ZUZvcm1hdChkYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQ6IGRhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlUmF3KGV2ZW50LCB7IGRhdGU6IGRhdGUsIGZvcm1hdHRlZERhdGU6IGZvcm1hdHRlZERhdGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZChkYXRlLCBldmVudCwgZmFsc2UsIG1vbnRoU2VsZWN0ZWRJbik7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd0RhdGVTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zaG91bGRDbG9zZU9uU2VsZWN0IHx8IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0UHJlU2VsZWN0aW9uKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEYXRlU2VsZWN0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0U2VsZWN0ZWQgaXMgY2FsbGVkIGVpdGhlciBmcm9tIGhhbmRsZUNoYW5nZSAodXNlciB0eXBlZCBkYXRlIGludG8gdGV4dGJveCBhbmQgaXQgd2FzIHBhcnNlZCkgb3IgaGFuZGxlU2VsZWN0ICh1c2VyIHNlbGVjdGVkIGRhdGUgZnJvbSBjYWxlbmRhciB1c2luZyBtb3VzZSBvciBrZXlib2FyZClcbiAgICAgICAgX3RoaXMuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoZGF0ZSwgZXZlbnQsIGtlZXBJbnB1dCwgbW9udGhTZWxlY3RlZEluKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIHRpbWVab25lID0gX3RoaXMucHJvcHMudGltZVpvbmU7XG4gICAgICAgICAgICAvLyBJZiB0aW1lem9uZSBpcyBzcGVjaWZpZWQsIGNvbnZlcnQgdGhlIHNlbGVjdGVkIGRhdGUgZnJvbSB6b25lZCB0aW1lIHRvIFVUQ1xuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBvbkNoYW5nZSBjYWxsYmFjayByZWNlaXZlcyBhIHByb3BlciBVVEMgRGF0ZSBvYmplY3RcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkRGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZERhdGUgJiYgdGltZVpvbmUpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRGF0ZSA9IGZyb21ab25lZFRpbWUoY2hhbmdlZERhdGUsIHRpbWVab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVhcmx5IHJldHVybiBpZiBzZWxlY3RlZCB5ZWFyL21vbnRoL2RheSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWREYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGlzWWVhckRpc2FibGVkKGdldFllYXIoY2hhbmdlZERhdGUpLCBfdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZERhdGUgIT09IG51bGwgJiYgaXNNb250aERpc2FibGVkKGNoYW5nZWREYXRlLCBfdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkRGF0ZSAhPT0gbnVsbCAmJiBpc0RheURpc2FibGVkKGNoYW5nZWREYXRlLCBfdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYyA9IF90aGlzLnByb3BzLCBvbkNoYW5nZSA9IF9jLm9uQ2hhbmdlLCBzZWxlY3RzUmFuZ2UgPSBfYy5zZWxlY3RzUmFuZ2UsIHN0YXJ0RGF0ZSA9IF9jLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9jLmVuZERhdGUsIHNlbGVjdHNNdWx0aXBsZSA9IF9jLnNlbGVjdHNNdWx0aXBsZSwgc2VsZWN0ZWREYXRlcyA9IF9jLnNlbGVjdGVkRGF0ZXMsIG1pblRpbWUgPSBfYy5taW5UaW1lLCBzd2FwUmFuZ2UgPSBfYy5zd2FwUmFuZ2U7XG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwoX3RoaXMucHJvcHMuc2VsZWN0ZWQsIGNoYW5nZWREYXRlKSB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmFsbG93U2FtZURheSB8fFxuICAgICAgICAgICAgICAgIHNlbGVjdHNSYW5nZSB8fFxuICAgICAgICAgICAgICAgIHNlbGVjdHNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBwcmV2aW91c2x5IHNlbGVjdGVkIHRpbWUgaWYgb25seSBkYXRlIGlzIGN1cnJlbnRseSBiZWluZyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFrZWVwSW5wdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIV90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLnNob3dUaW1lSW5wdXQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZERhdGUgPSBzZXRUaW1lKGNoYW5nZWREYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91cjogZ2V0SG91cnMoX3RoaXMucHJvcHMuc2VsZWN0ZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZTogZ2V0TWludXRlcyhfdGhpcy5wcm9wcy5zZWxlY3RlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kOiBnZXRTZWNvbmRzKF90aGlzLnByb3BzLnNlbGVjdGVkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG1pblRpbWUgaXMgcHJlc2VudCB0aGVuIHNldCB0aGUgdGltZSB0byBtaW5UaW1lXG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcElucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QgfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pblRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRGF0ZSA9IHNldFRpbWUoY2hhbmdlZERhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91cjogbWluVGltZS5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGU6IG1pblRpbWUuZ2V0TWludXRlcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmQ6IG1pblRpbWUuZ2V0U2Vjb25kcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuaW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBjaGFuZ2VkRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuZm9jdXNTZWxlY3RlZE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IG1vbnRoU2VsZWN0ZWRJbjogbW9udGhTZWxlY3RlZEluIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vUmFuZ2VzID0gIXN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1N0YXJ0UmFuZ2UgPSBzdGFydERhdGUgJiYgIWVuZERhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNPbmx5RW5kUmFuZ2UgPSAhc3RhcnREYXRlICYmICEhZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUmFuZ2VGaWxsZWQgPSBzdGFydERhdGUgJiYgZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW2NoYW5nZWREYXRlLCBudWxsXSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc1N0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkRGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbbnVsbCwgbnVsbF0sIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0ZUJlZm9yZShjaGFuZ2VkRGF0ZSwgc3RhcnREYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2FwUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKFtjaGFuZ2VkRGF0ZSwgc3RhcnREYXRlXSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKFtjaGFuZ2VkRGF0ZSwgbnVsbF0sIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW3N0YXJ0RGF0ZSwgY2hhbmdlZERhdGVdLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzT25seUVuZFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZERhdGUgJiYgaXNEYXRlQmVmb3JlKGNoYW5nZWREYXRlLCBlbmREYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbY2hhbmdlZERhdGUsIGVuZERhdGVdLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW2NoYW5nZWREYXRlLCBudWxsXSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JhbmdlRmlsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW2NoYW5nZWREYXRlLCBudWxsXSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdHNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZERhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHNlbGVjdGVkRGF0ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWREYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWREYXRlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKFtjaGFuZ2VkRGF0ZV0sIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0NoYW5nZWREYXRlQWxyZWFkeVNlbGVjdGVkID0gc2VsZWN0ZWREYXRlcy5zb21lKGZ1bmN0aW9uIChzZWxlY3RlZERhdGUpIHsgcmV0dXJuIGlzU2FtZURheShzZWxlY3RlZERhdGUsIGNoYW5nZWREYXRlKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZERhdGVBbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHREYXRlcyA9IHNlbGVjdGVkRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzZWxlY3RlZERhdGUpIHsgcmV0dXJuICFpc1NhbWVEYXkoc2VsZWN0ZWREYXRlLCBjaGFuZ2VkRGF0ZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UobmV4dERhdGVzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBzZWxlY3RlZERhdGVzLCB0cnVlKSwgW2NoYW5nZWREYXRlXSwgZmFsc2UpLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoY2hhbmdlZERhdGUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXBJbnB1dCkge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vblNlbGVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGNoYW5nZWREYXRlLCBldmVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpbnB1dFZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBXaGVuIGNoZWNraW5nIHByZVNlbGVjdGlvbiB2aWEgbWluL21heERhdGUsIHRpbWVzIG5lZWQgdG8gYmUgbWFuaXB1bGF0ZWQgdmlhIGdldFN0YXJ0T2ZEYXkvZ2V0RW5kT2ZEYXlcbiAgICAgICAgX3RoaXMuc2V0UHJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5yZWFkT25seSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaGFzTWluRGF0ZSA9IGlzRGF0ZShfdGhpcy5wcm9wcy5taW5EYXRlKTtcbiAgICAgICAgICAgIHZhciBoYXNNYXhEYXRlID0gaXNEYXRlKF90aGlzLnByb3BzLm1heERhdGUpO1xuICAgICAgICAgICAgdmFyIGlzVmFsaWREYXRlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVTdGFydE9mRGF5ID0gZ2V0U3RhcnRPZkRheShkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTWluRGF0ZSAmJiBoYXNNYXhEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzRGF5SW5SYW5nZSB1c2VzIGdldFN0YXJ0T2ZEYXkgaW50ZXJuYWxseSwgc28gbm90IG5lY2Vzc2FyeSB0byBtYW5pcHVsYXRlIHRpbWVzIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZERhdGVTZWxlY3Rpb24gPSBpc0RheUluUmFuZ2UoZGF0ZSwgX3RoaXMucHJvcHMubWluRGF0ZSwgX3RoaXMucHJvcHMubWF4RGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc01pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkRhdGVTdGFydE9mRGF5ID0gZ2V0U3RhcnRPZkRheShfdGhpcy5wcm9wcy5taW5EYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZERhdGVTZWxlY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBZnRlcihkYXRlLCBtaW5EYXRlU3RhcnRPZkRheSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKGRhdGVTdGFydE9mRGF5LCBtaW5EYXRlU3RhcnRPZkRheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc01heERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heERhdGVFbmRPZkRheSA9IGdldEVuZE9mRGF5KF90aGlzLnByb3BzLm1heERhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkRGF0ZVNlbGVjdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JlZm9yZShkYXRlLCBtYXhEYXRlRW5kT2ZEYXkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFcXVhbChkYXRlU3RhcnRPZkRheSwgbWF4RGF0ZUVuZE9mRGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYWxpZERhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHByZVNlbGVjdGlvbjogZGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudG9nZ2xlQ2FsZW5kYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRPcGVuKCFfdGhpcy5zdGF0ZS5vcGVuKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlVGltZUNoYW5nZSA9IGZ1bmN0aW9uICh0aW1lLCBtb2RpZnlEYXRlVHlwZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5wcm9wcywgc2VsZWN0c1JhbmdlID0gX2Muc2VsZWN0c1JhbmdlLCBzdGFydERhdGUgPSBfYy5zdGFydERhdGUsIGVuZERhdGUgPSBfYy5lbmREYXRlLCBvbkNoYW5nZSA9IF9jLm9uQ2hhbmdlLCB0aW1lWm9uZSA9IF9jLnRpbWVab25lO1xuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vIEluIHJhbmdlIG1vZGUsIGFwcGx5IHRpbWUgdG8gdGhlIGFwcHJvcHJpYXRlIGRhdGVcbiAgICAgICAgICAgICAgICAvLyBJZiBtb2RpZnlEYXRlVHlwZSBpcyBzcGVjaWZpZWQsIHVzZSB0aGF0IHRvIGRldGVybWluZSB3aGljaCBkYXRlIHRvIG1vZGlmeVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBsZWdhY3kgYmVoYXZpb3I6XG4gICAgICAgICAgICAgICAgLy8gLSBJZiB3ZSBoYXZlIGEgc3RhcnREYXRlIGJ1dCBubyBlbmREYXRlLCBhcHBseSB0aW1lIHRvIHN0YXJ0RGF0ZVxuICAgICAgICAgICAgICAgIC8vIC0gSWYgd2UgaGF2ZSBib3RoLCBhcHBseSB0aW1lIHRvIGVuZERhdGVcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZ5RGF0ZVR5cGUgPT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IG1vZGlmeSBzdGFydCBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkU3RhcnREYXRlID0gc2V0VGltZShzdGFydERhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyOiBnZXRIb3Vycyh0aW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGU6IGdldE1pbnV0ZXModGltZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb246IGNoYW5nZWRTdGFydERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSB6b25lZCB0aW1lIHRvIFVUQyBpZiB0aW1lem9uZSBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lWm9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRTdGFydERhdGUgPSBmcm9tWm9uZWRUaW1lKGNoYW5nZWRTdGFydERhdGUsIHRpbWVab25lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGltZVpvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZnJvbVpvbmVkVGltZShlbmREYXRlLCB0aW1lWm9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZW5kRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGlmeURhdGVUeXBlID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgbW9kaWZ5IGVuZCBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZEVuZERhdGUgPSBzZXRUaW1lKGVuZERhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyOiBnZXRIb3Vycyh0aW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGU6IGdldE1pbnV0ZXModGltZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb246IGNoYW5nZWRFbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gem9uZWQgdGltZSB0byBVVEMgaWYgdGltZXpvbmUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZVpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRW5kRGF0ZSA9IGZyb21ab25lZFRpbWUoY2hhbmdlZEVuZERhdGUsIHRpbWVab25lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGltZVpvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZnJvbVpvbmVkVGltZShzdGFydERhdGUsIHRpbWVab25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGFydERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRFbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IGJlaGF2aW9yIGZvciBzaG93VGltZVNlbGVjdCAoc2luZ2xlIHRpbWUgcGlja2VyKVxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzU3RhcnRSYW5nZSA9IHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1N0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRpbWUgdG8gc3RhcnREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZFN0YXJ0RGF0ZSA9IHNldFRpbWUoc3RhcnREYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91cjogZ2V0SG91cnModGltZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlOiBnZXRNaW51dGVzKHRpbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBjaGFuZ2VkU3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gem9uZWQgdGltZSB0byBVVEMgaWYgdGltZXpvbmUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZVpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkU3RhcnREYXRlID0gZnJvbVpvbmVkVGltZShjaGFuZ2VkU3RhcnREYXRlLCB0aW1lWm9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW2NoYW5nZWRTdGFydERhdGUsIG51bGxdLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RGF0ZSAmJiBlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0aW1lIHRvIGVuZERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkRW5kRGF0ZSA9IHNldFRpbWUoZW5kRGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXI6IGdldEhvdXJzKHRpbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZTogZ2V0TWludXRlcyh0aW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZVNlbGVjdGlvbjogY2hhbmdlZEVuZERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSB6b25lZCB0aW1lIHRvIFVUQyBpZiB0aW1lem9uZSBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lWm9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRFbmREYXRlID0gZnJvbVpvbmVkVGltZShjaGFuZ2VkRW5kRGF0ZSwgdGltZVpvbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lWm9uZSA/IGZyb21ab25lZFRpbWUoc3RhcnREYXRlLCB0aW1lWm9uZSkgOiBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEVuZERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gZGF0ZXMgc2VsZWN0ZWQgeWV0LCBqdXN0IHVwZGF0ZSBwcmVTZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkRGF0ZSA9IHNldFRpbWUoX3RoaXMuZ2V0UHJlU2VsZWN0aW9uKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyOiBnZXRIb3Vycyh0aW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGU6IGdldE1pbnV0ZXModGltZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb246IGNoYW5nZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZGF0ZSBtb2RlIChvcmlnaW5hbCBiZWhhdmlvcilcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIDogX3RoaXMuZ2V0UHJlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWREYXRlID0gX3RoaXMucHJvcHMuc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgPyB0aW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2V0VGltZShzZWxlY3RlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91cjogZ2V0SG91cnModGltZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGU6IGdldE1pbnV0ZXModGltZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBjaGFuZ2VkRGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gem9uZWQgdGltZSB0byBVVEMgaWYgdGltZXpvbmUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWREYXRlICYmIHRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWREYXRlID0gZnJvbVpvbmVkVGltZShjaGFuZ2VkRGF0ZSwgdGltZVpvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25DaGFuZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBjaGFuZ2VkRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvdWxkQ2xvc2VPblNlbGVjdCAmJiAhX3RoaXMucHJvcHMuc2hvd1RpbWVJbnB1dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRGb2N1c0JhY2tUb0lucHV0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVJbnB1dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4odHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5IHx8IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc1JlbmRlckFyaWFMaXZlTWVzc2FnZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaW5wdXRWYWx1ZTogbnVsbCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25JbnB1dENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuZGlzYWJsZWQgJiYgIV90aGlzLnByb3BzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0T3Blbih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbklucHV0Q2xpY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlVGltZU9ubHlBcnJvd0tleSA9IGZ1bmN0aW9uIChldmVudEtleSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gX3RoaXMucHJvcHMuc2VsZWN0ZWQgfHwgX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uIHx8IG5ld0RhdGUoKTtcbiAgICAgICAgICAgIHZhciB0aW1lSW50ZXJ2YWxzID0gKF9hID0gX3RoaXMucHJvcHMudGltZUludGVydmFscykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMzA7XG4gICAgICAgICAgICB2YXIgZGF0ZUZvcm1hdCA9IChfYiA9IF90aGlzLnByb3BzLmRhdGVGb3JtYXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICB2YXIgZm9ybWF0U3RyID0gQXJyYXkuaXNBcnJheShkYXRlRm9ybWF0KSA/IGRhdGVGb3JtYXRbMF0gOiBkYXRlRm9ybWF0O1xuICAgICAgICAgICAgdmFyIGJhc2VEYXRlID0gZ2V0U3RhcnRPZkRheShjdXJyZW50VGltZSk7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1pbnV0ZXMgPSBnZXRIb3VycyhjdXJyZW50VGltZSkgKiA2MCArIGdldE1pbnV0ZXMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgdmFyIG1heE1pbnV0ZXMgPSAyMyAqIDYwICsgNjAgLSB0aW1lSW50ZXJ2YWxzOyAvLyBDYXAgYXQgbGFzdCB2YWxpZCBpbnRlcnZhbCBvZiB0aGUgZGF5XG4gICAgICAgICAgICB2YXIgbmV3VGltZTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5BcnJvd1VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld01pbnV0ZXMgPSBNYXRoLm1heCgwLCBjdXJyZW50TWludXRlcyAtIHRpbWVJbnRlcnZhbHMpO1xuICAgICAgICAgICAgICAgIG5ld1RpbWUgPSBhZGRNaW51dGVzKGJhc2VEYXRlLCBuZXdNaW51dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdNaW51dGVzID0gTWF0aC5taW4obWF4TWludXRlcywgY3VycmVudE1pbnV0ZXMgKyB0aW1lSW50ZXJ2YWxzKTtcbiAgICAgICAgICAgICAgICBuZXdUaW1lID0gYWRkTWludXRlcyhiYXNlRGF0ZSwgbmV3TWludXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IGZvcm1hdERhdGUobmV3VGltZSwgZm9ybWF0U3RyIHx8IERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLmRhdGVGb3JtYXQsIF90aGlzLnByb3BzLmxvY2FsZSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBuZXdUaW1lLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IGZvcm1hdHRlZFRpbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RzUmFuZ2UgfHwgX3RoaXMucHJvcHMuc2VsZWN0c011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gX3RoaXMucHJvcHMuc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5nZXRQcmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkRGF0ZSA9IF90aGlzLnByb3BzLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyBuZXdUaW1lXG4gICAgICAgICAgICAgICAgOiBzZXRUaW1lKHNlbGVjdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IGdldEhvdXJzKG5ld1RpbWUpLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGU6IGdldE1pbnV0ZXMobmV3VGltZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2QgPSAoX2MgPSBfdGhpcy5wcm9wcykub25DaGFuZ2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBjaGFuZ2VkRGF0ZSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5IHx8IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc1JlbmRlckFyaWFMaXZlTWVzc2FnZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9UaW1lT3B0aW9uKG5ld1RpbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVRpbWVPbmx5RW50ZXJLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIHZhciBpbnB1dEVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZSA9IGlucHV0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBkYXRlRm9ybWF0ID0gKF9hID0gX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIHZhciB0aW1lRm9ybWF0ID0gX3RoaXMucHJvcHMudGltZUZvcm1hdCB8fCBcInBcIjtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VGltZSA9IF90aGlzLnN0YXRlLnByZVNlbGVjdGlvbiB8fCBfdGhpcy5wcm9wcy5zZWxlY3RlZCB8fCBuZXdEYXRlKCk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkRGF0ZSA9IHBhcnNlRGF0ZShpbnB1dFZhbHVlLCBkYXRlRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUsIChfYiA9IF90aGlzLnByb3BzLnN0cmljdFBhcnNpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLCBkZWZhdWx0VGltZSk7XG4gICAgICAgICAgICB2YXIgdGltZVRvQ29tbWl0ID0gZGVmYXVsdFRpbWU7XG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0ZSAmJiBpc1ZhbGlkKHBhcnNlZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGltZVRvQ29tbWl0ID0gcGFyc2VkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHRlZEl0ZW0gPSAoKF9jID0gX3RoaXMuY2FsZW5kYXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jb250YWluZXJSZWYuY3VycmVudCkgaW5zdGFuY2VvZiBFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLmNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoXCIucmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1saXN0LWl0ZW1bdGFiaW5kZXg9JzAnXVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRJdGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1UZXh0ID0gKF9kID0gaGlnaGxpZ2h0ZWRJdGVtLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVGltZSA9IHBhcnNlRGF0ZShpdGVtVGV4dCwgdGltZUZvcm1hdCwgX3RoaXMucHJvcHMubG9jYWxlLCBmYWxzZSwgZGVmYXVsdFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1UaW1lICYmIGlzVmFsaWQoaXRlbVRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZVRvQ29tbWl0ID0gaXRlbVRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVUaW1lQ2hhbmdlKHRpbWVUb0NvbW1pdCk7XG4gICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIF90aGlzLnNlbmRGb2N1c0JhY2tUb0lucHV0KCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNjcm9sbFRvVGltZU9wdGlvbiA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCEoKF9hID0gX3RoaXMuY2FsZW5kYXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWluZXJSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuY2FsZW5kYXIuY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgdGltZUxpc3RJdGVtcyA9IEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIucmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1saXN0LWl0ZW1cIikpO1xuICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3RUaW1lRGlmZiA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHRpbWVGb3JtYXQgPSBfdGhpcy5wcm9wcy50aW1lRm9ybWF0IHx8IFwicFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0aW1lTGlzdEl0ZW1zXzEgPSB0aW1lTGlzdEl0ZW1zOyBfaSA8IHRpbWVMaXN0SXRlbXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRpbWVMaXN0SXRlbXNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1UZXh0ID0gKF9iID0gaXRlbS50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1UaW1lID0gcGFyc2VEYXRlKGl0ZW1UZXh0LCB0aW1lRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUsIGZhbHNlLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1UaW1lICYmIGlzVmFsaWQoaXRlbVRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lTWludXRlKGl0ZW1UaW1lLCB0aW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVEaWZmID0gTWF0aC5hYnMoaXRlbVRpbWUuZ2V0VGltZSgpIC0gdGltZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVEaWZmIDwgY2xvc2VzdFRpbWVEaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFRpbWVEaWZmID0gdGltZURpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSkge1xuICAgICAgICAgICAgICAgIHRpbWVMaXN0SXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SXRlbS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SXRlbS5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25JbnB1dEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uS2V5RG93bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc3RhdGUub3BlbiAmJlxuICAgICAgICAgICAgICAgICFfdGhpcy5wcm9wcy5pbmxpbmUgJiZcbiAgICAgICAgICAgICAgICAhX3RoaXMucHJvcHMucHJldmVudE9wZW5PbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLkFycm93RG93biB8fFxuICAgICAgICAgICAgICAgICAgICBldmVudEtleSA9PT0gS2V5VHlwZS5BcnJvd1VwIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5ID09PSBLZXlUeXBlLkVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IF90aGlzLm9uSW5wdXRDbGljaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUub3BlbiAmJiBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuQXJyb3dEb3duIHx8IGV2ZW50S2V5ID09PSBLZXlUeXBlLkFycm93VXApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlVGltZU9ubHlBcnJvd0tleShldmVudEtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLkVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVRpbWVPbmx5RW50ZXJLZXkoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2FsZW5kYXIgaXMgb3BlbiwgdGhlc2Uga2V5cyB3aWxsIGZvY3VzIHRoZSBzZWxlY3RlZCBpdGVtXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUub3Blbikge1xuICAgICAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5BcnJvd0Rvd24gfHwgZXZlbnRLZXkgPT09IEtleVR5cGUuQXJyb3dVcCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JTdHJpbmcgPSBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCIucmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1saXN0LWl0ZW1bdGFiaW5kZXg9JzAnXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF90aGlzLnByb3BzLnNob3dXZWVrUGlja2VyICYmIF90aGlzLnByb3BzLnNob3dXZWVrTnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJy5yZWFjdC1kYXRlcGlja2VyX193ZWVrLW51bWJlclt0YWJpbmRleD1cIjBcIl0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5zaG93RnVsbE1vbnRoWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJy5yZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0W3RhYmluZGV4PVwiMFwiXSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnLnJlYWN0LWRhdGVwaWNrZXJfX2RheVt0YWJpbmRleD1cIjBcIl0nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gKChfZCA9IF90aGlzLmNhbGVuZGFyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY29udGFpbmVyUmVmLmN1cnJlbnQpIGluc3RhbmNlb2YgRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIuY29udGFpbmVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvclN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW0uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3RGF0ZShfdGhpcy5zdGF0ZS5wcmVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5FbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW5wdXRPaygpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5sYXN0UHJlU2VsZWN0Q2hhbmdlID09PSBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9OQVZJR0FURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2VsZWN0KGNvcHksIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy5wcm9wcy5zaG91bGRDbG9zZU9uU2VsZWN0ICYmIF90aGlzLnNldFByZVNlbGVjdGlvbihjb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLkVzY2FwZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kRm9jdXNCYWNrVG9JbnB1dCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlucHV0T2soKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2YgPSAoX2UgPSBfdGhpcy5wcm9wcykub25JbnB1dEVycm9yKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSwgeyBjb2RlOiAxLCBtc2c6IElOUFVUX0VSUl8xIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Qb3J0YWxLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRLZXkgPSBldmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuRXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRGb2N1czogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHByZXZlbnRGb2N1czogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBrZXlEb3duIGV2ZW50cyBwYXNzZWQgZG93biB0byBkYXkuanN4XG4gICAgICAgIF90aGlzLm9uRGF5S2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICB2YXIgX2cgPSBfdGhpcy5wcm9wcywgbWluRGF0ZSA9IF9nLm1pbkRhdGUsIG1heERhdGUgPSBfZy5tYXhEYXRlLCBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiA9IF9nLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uLCBzaG93V2Vla1BpY2tlciA9IF9nLnNob3dXZWVrUGlja2VyLCBzaG91bGRDbG9zZU9uU2VsZWN0ID0gX2cuc2hvdWxkQ2xvc2VPblNlbGVjdCwgbG9jYWxlID0gX2cubG9jYWxlLCBjYWxlbmRhclN0YXJ0RGF5ID0gX2cuY2FsZW5kYXJTdGFydERheSwgYWRqdXN0RGF0ZU9uQ2hhbmdlID0gX2cuYWRqdXN0RGF0ZU9uQ2hhbmdlLCBpbmxpbmUgPSBfZy5pbmxpbmU7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIHZhciBpc1NoaWZ0S2V5QWN0aXZlID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgICAgICB2YXIgY29weSA9IG5ld0RhdGUoX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVOZXdEYXRlID0gZnVuY3Rpb24gKGV2ZW50S2V5LCBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NhbGN1bGF0ZWREYXRlID0gZGF0ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd1JpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBzaG93V2Vla1BpY2tlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkV2Vla3MoZGF0ZSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93TGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gc2hvd1dlZWtQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN1YldlZWtzKGRhdGUsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdWJEYXlzKGRhdGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd1VwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBzdWJXZWVrcyhkYXRlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dEb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBhZGRXZWVrcyhkYXRlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuUGFnZVVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBpc1NoaWZ0S2V5QWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdWJZZWFycyhkYXRlLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3ViTW9udGhzKGRhdGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5QYWdlRG93bjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gaXNTaGlmdEtleUFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkWWVhcnMoZGF0ZSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkZE1vbnRocyhkYXRlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuSG9tZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gZ2V0U3RhcnRPZldlZWsoZGF0ZSwgbG9jYWxlLCBjYWxlbmRhclN0YXJ0RGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuRW5kOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBnZXRFbmRPZldlZWsoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NhbGN1bGF0ZWREYXRlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXROZXdEYXRlID0gZnVuY3Rpb24gKGV2ZW50S2V5LCBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIE1BWF9JVEVSQVRJT05TID0gNDA7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50S2V5Q29weSA9IGV2ZW50S2V5O1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZERhdGVGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gY2FsY3VsYXRlTmV3RGF0ZShldmVudEtleSwgZGF0ZSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCF2YWxpZERhdGVGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9ucyA+PSBNQVhfSVRFUkFUSU9OUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG1pbkRhdGUgZXhpc3RzIGFuZCB0aGUgbmV3IHNlbGVjdGlvbiBpcyBiZWZvcmUgdGhlIG1pbiBkYXRlLCBnZXQgdGhlIG5lYXJlc3QgZGF0ZSB0aGF0IGlzbid0IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5EYXRlICYmIG5ld1NlbGVjdGlvbiA8IG1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29weSA9IEtleVR5cGUuQXJyb3dSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IGlzRGF5RGlzYWJsZWQobWluRGF0ZSwgX3RoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjYWxjdWxhdGVOZXdEYXRlKGV2ZW50S2V5Q29weSwgbmV3U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbWluRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtYXhEYXRlIGV4aXN0cyBhbmQgdGhlIG5ldyBzZWxlY3Rpb24gaXMgYWZ0ZXIgdGhlIG1heCBkYXRlLCBnZXQgdGhlIG5lYXJlc3QgZGF0ZSB0aGF0IGlzbid0IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIG5ld1NlbGVjdGlvbiA+IG1heERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29weSA9IEtleVR5cGUuQXJyb3dMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gaXNEYXlEaXNhYmxlZChtYXhEYXRlLCBfdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNhbGN1bGF0ZU5ld0RhdGUoZXZlbnRLZXlDb3B5LCBuZXdTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtYXhEYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RheURpc2FibGVkKG5ld1NlbGVjdGlvbiwgX3RoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBQYWdlVXAgYW5kIEhvbWUgaXMgcHJlc3NlZCB0byBhIGRpc2FibGVkIGRhdGUsIGl0IHdpbGwgdHJ5IHRvIGZpbmQgdGhlIG5leHQgYXZhaWxhYmxlIGRhdGUgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEtleUNvcHkgPT09IEtleVR5cGUuUGFnZVVwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRLZXlDb3B5ID09PSBLZXlUeXBlLkhvbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEtleUNvcHkgPSBLZXlUeXBlLkFycm93UmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBQYWdlRG93biBhbmQgRW5kIGlzIHByZXNzZWQgdG8gYSBkaXNhYmxlZCBkYXRlLCBpdCB3aWxsIHRyeSB0byBmaW5kIHRoZSBuZXh0IGF2YWlsYWJsZSBkYXRlIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50S2V5Q29weSA9PT0gS2V5VHlwZS5QYWdlRG93biB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29weSA9PT0gS2V5VHlwZS5FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEtleUNvcHkgPSBLZXlUeXBlLkFycm93TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IGNhbGN1bGF0ZU5ld0RhdGUoZXZlbnRLZXlDb3B5LCBuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWREYXRlRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NlbGVjdGlvbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuRW50ZXIpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNlbGVjdChjb3B5LCBldmVudCk7XG4gICAgICAgICAgICAgICAgIXNob3VsZENsb3NlT25TZWxlY3QgJiYgX3RoaXMuc2V0UHJlU2VsZWN0aW9uKGNvcHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLkVzY2FwZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pbnB1dE9rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9kID0gKF9jID0gX3RoaXMucHJvcHMpLm9uSW5wdXRFcnJvcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIHsgY29kZTogMSwgbXNnOiBJTlBVVF9FUlJfMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93TGVmdDpcbiAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dVcDpcbiAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dEb3duOlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5QYWdlVXA6XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLlBhZ2VEb3duOlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5Ib21lOlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5FbmQ6XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IGdldE5ld0RhdGUoZXZlbnRLZXksIGNvcHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV3U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgKF9mID0gKF9lID0gX3RoaXMucHJvcHMpLm9uSW5wdXRFcnJvcikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UsIHsgY29kZTogMSwgbXNnOiBJTlBVVF9FUlJfMSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBsYXN0UHJlU2VsZWN0Q2hhbmdlOiBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9OQVZJR0FURSB9KTtcbiAgICAgICAgICAgIGlmIChhZGp1c3REYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZChuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0UHJlU2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgICAvLyBJbiBpbmxpbmUgbW9kZSwgYWx3YXlzIHNldCBzaG91bGRGb2N1c0RheUlubGluZSB0byB0cnVlIHdoZW4gbmF2aWdhdGluZyB2aWEga2V5Ym9hcmQuXG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgZm9jdXMgaXMgcHJvcGVybHkgdHJhbnNmZXJyZWQgdG8gdGhlIG5ldyBkYXkgZWxlbWVudCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHRoZSBtb250aCBjaGFuZ2VkLiBUaGUgdXNlciBpbml0aWF0ZWQgdGhpcyBuYXZpZ2F0aW9uIGZyb20gYSBmb2N1c2VkIGRheSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHNob3VsZCBhbHdheXMgZm9jdXMgdGhlIGRlc3RpbmF0aW9uIGRheS5cbiAgICAgICAgICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNob3VsZEZvY3VzRGF5SW5saW5lOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBoYW5kbGUgZ2VuZXJpYyBrZXkgZG93biBldmVudHMgaW4gdGhlIHBvcHBlciB0aGF0IGRvIG5vdCBhZGp1c3Qgb3Igc2VsZWN0IGRhdGVzXG4gICAgICAgIC8vIGV4OiB3aGlsZSBmb2N1c2luZyBwcmV2IGFuZCBuZXh0IG1vbnRoIGJ1dHRvbnNcbiAgICAgICAgX3RoaXMub25Qb3BwZXJLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRLZXkgPSBldmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuRXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kRm9jdXNCYWNrVG9JbnB1dCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNsZWFyQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNlbmRGb2N1c0JhY2tUb0lucHV0KCk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgc2VsZWN0c1JhbmdlID0gX2Euc2VsZWN0c1JhbmdlLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSkge1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbbnVsbCwgbnVsbF0sIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShudWxsLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IG51bGwgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub25DbGVhckNsaWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uU2Nyb2xsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLnByb3BzLmNsb3NlT25TY3JvbGwgPT09IFwiYm9vbGVhblwiICYmXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuY2xvc2VPblNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGRvY3VtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgX3RoaXMucHJvcHMuY2xvc2VPblNjcm9sbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmNsb3NlT25TY3JvbGwoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW9udGhTZWxlY3RlZEluQ2hhbmdlID0gZnVuY3Rpb24gKG1vbnRoU2VsZWN0ZWRJbikge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBtb250aFNlbGVjdGVkSW46IG1vbnRoU2VsZWN0ZWRJbiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyQ2FsZW5kYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5pbmxpbmUgJiYgIV90aGlzLmlzQ2FsZW5kYXJPcGVuKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDYWxlbmRhciwgX2Fzc2lnbih7IHNob3dNb250aFllYXJEcm9wZG93bjogdW5kZWZpbmVkLCByZWY6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyID0gZWxlbTtcbiAgICAgICAgICAgICAgICB9IH0sIF90aGlzLnByb3BzLCBfdGhpcy5zdGF0ZSwgeyBzZXRPcGVuOiBfdGhpcy5zZXRPcGVuLCBkYXRlRm9ybWF0OiAoX2EgPSBfdGhpcy5wcm9wcy5kYXRlRm9ybWF0Q2FsZW5kYXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLmRhdGVGb3JtYXRDYWxlbmRhciwgb25TZWxlY3Q6IF90aGlzLmhhbmRsZVNlbGVjdCwgb25DbGlja091dHNpZGU6IF90aGlzLmhhbmRsZUNhbGVuZGFyQ2xpY2tPdXRzaWRlLCBob2xpZGF5czogZ2V0SG9saWRheXNNYXAoX3RoaXMubW9kaWZ5SG9saWRheXMoKSksIG91dHNpZGVDbGlja0lnbm9yZUNsYXNzOiBfdGhpcy5wcm9wcy5vdXRzaWRlQ2xpY2tJZ25vcmVDbGFzcywgb25Ecm9wZG93bkZvY3VzOiBfdGhpcy5oYW5kbGVEcm9wZG93bkZvY3VzLCBvblRpbWVDaGFuZ2U6IF90aGlzLmhhbmRsZVRpbWVDaGFuZ2UsIGNsYXNzTmFtZTogX3RoaXMucHJvcHMuY2FsZW5kYXJDbGFzc05hbWUsIGNvbnRhaW5lcjogX3RoaXMucHJvcHMuY2FsZW5kYXJDb250YWluZXIsIGhhbmRsZU9uS2V5RG93bjogX3RoaXMucHJvcHMub25LZXlEb3duLCBoYW5kbGVPbkRheUtleURvd246IF90aGlzLm9uRGF5S2V5RG93biwgc2V0UHJlU2VsZWN0aW9uOiBfdGhpcy5zZXRQcmVTZWxlY3Rpb24sIGRyb3Bkb3duTW9kZTogKF9iID0gX3RoaXMucHJvcHMuZHJvcGRvd25Nb2RlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBEYXRlUGlja2VyLmRlZmF1bHRQcm9wcy5kcm9wZG93bk1vZGUsIG9uTW9udGhTZWxlY3RlZEluQ2hhbmdlOiBfdGhpcy5oYW5kbGVNb250aFNlbGVjdGVkSW5DaGFuZ2UgfSksIF90aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckFyaWFMaXZlUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IF90aGlzLnByb3BzLmxvY2FsZTtcbiAgICAgICAgICAgIHZhciBkYXRlRm9ybWF0ID0gKF9hID0gX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIHZhciBpc0NvbnRhaW5zVGltZSA9IF90aGlzLnByb3BzLnNob3dUaW1lSW5wdXQgfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3Q7XG4gICAgICAgICAgICB2YXIgbG9uZ0RhdGVGb3JtYXQgPSBpc0NvbnRhaW5zVGltZSA/IFwiUFBQUHBcIiA6IFwiUFBQUFwiO1xuICAgICAgICAgICAgdmFyIGFyaWFMaXZlTWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2UgPSBcIlNlbGVjdGVkIHN0YXJ0IGRhdGU6IFwiLmNvbmNhdChzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5zdGFydERhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogbG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgIH0pLCBcIi4gXCIpLmNvbmNhdChfdGhpcy5wcm9wcy5lbmREYXRlXG4gICAgICAgICAgICAgICAgICAgID8gXCJFbmQgZGF0ZTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZURhdGVGb3JtYXQoX3RoaXMucHJvcHMuZW5kRGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQ6IGxvbmdEYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlID0gXCJTZWxlY3RlZCB0aW1lOiBcIi5jb25jYXQoc2FmZURhdGVGb3JtYXQoX3RoaXMucHJvcHMuc2VsZWN0ZWQsIHsgZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCwgbG9jYWxlOiBsb2NhbGUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2UgPSBcIlNlbGVjdGVkIHllYXI6IFwiLmNvbmNhdChzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5zZWxlY3RlZCwgeyBkYXRlRm9ybWF0OiBcInl5eXlcIiwgbG9jYWxlOiBsb2NhbGUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZSA9IFwiU2VsZWN0ZWQgbW9udGg6IFwiLmNvbmNhdChzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5zZWxlY3RlZCwgeyBkYXRlRm9ybWF0OiBcIk1NTU0geXl5eVwiLCBsb2NhbGU6IGxvY2FsZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnByb3BzLnNob3dRdWFydGVyWWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2UgPSBcIlNlbGVjdGVkIHF1YXJ0ZXI6IFwiLmNvbmNhdChzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5zZWxlY3RlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogXCJ5eXl5LCBRUVFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2UgPSBcIlNlbGVjdGVkIGRhdGU6IFwiLmNvbmNhdChzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5zZWxlY3RlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogbG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyByb2xlOiBcImFsZXJ0XCIsIFwiYXJpYS1saXZlXCI6IFwicG9saXRlXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19hcmlhLWxpdmVcIiB9LCBhcmlhTGl2ZU1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyRGF0ZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xzeChfdGhpcy5wcm9wcy5jbGFzc05hbWUsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hW190aGlzLnByb3BzLm91dHNpZGVDbGlja0lnbm9yZUNsYXNzIHx8XG4gICAgICAgICAgICAgICAgICAgIERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLm91dHNpZGVDbGlja0lnbm9yZUNsYXNzXSA9IF90aGlzLnN0YXRlLm9wZW4sXG4gICAgICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgICAgIHZhciBjdXN0b21JbnB1dCA9IF90aGlzLnByb3BzLmN1c3RvbUlucHV0IHx8IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6IFwidGV4dFwiIH0pO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUlucHV0UmVmID0gX3RoaXMucHJvcHMuY3VzdG9tSW5wdXRSZWYgfHwgXCJyZWZcIjtcbiAgICAgICAgICAgIC8vIEJ1aWxkIGFyaWEgcHJvcHMgb2JqZWN0LCBvbmx5IGluY2x1ZGluZyBkZWZpbmVkIHZhbHVlcyB0byBhdm9pZFxuICAgICAgICAgICAgLy8gb3ZlcndyaXRpbmcgYXJpYSBhdHRyaWJ1dGVzIHRoYXQgbWF5IGJlIHNldCBvbiB0aGUgY3VzdG9tIGlucHV0XG4gICAgICAgICAgICB2YXIgYXJpYVByb3BzID0ge307XG4gICAgICAgICAgICB2YXIgYXJpYURlc2NyaWJlZEJ5ID0gKF9jID0gX3RoaXMucHJvcHNbXCJhcmlhLWRlc2NyaWJlZGJ5XCJdKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBfdGhpcy5wcm9wcy5hcmlhRGVzY3JpYmVkQnk7XG4gICAgICAgICAgICB2YXIgYXJpYUludmFsaWQgPSAoX2QgPSBfdGhpcy5wcm9wc1tcImFyaWEtaW52YWxpZFwiXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogX3RoaXMucHJvcHMuYXJpYUludmFsaWQ7XG4gICAgICAgICAgICB2YXIgYXJpYUxhYmVsID0gKF9lID0gX3RoaXMucHJvcHNbXCJhcmlhLWxhYmVsXCJdKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBfdGhpcy5wcm9wcy5hcmlhTGFiZWw7XG4gICAgICAgICAgICB2YXIgYXJpYUxhYmVsbGVkQnkgPSAoX2YgPSBfdGhpcy5wcm9wc1tcImFyaWEtbGFiZWxsZWRieVwiXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogX3RoaXMucHJvcHMuYXJpYUxhYmVsbGVkQnk7XG4gICAgICAgICAgICB2YXIgYXJpYVJlcXVpcmVkID0gKF9nID0gX3RoaXMucHJvcHNbXCJhcmlhLXJlcXVpcmVkXCJdKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBfdGhpcy5wcm9wcy5hcmlhUmVxdWlyZWQ7XG4gICAgICAgICAgICBpZiAoYXJpYURlc2NyaWJlZEJ5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgYXJpYVByb3BzW1wiYXJpYS1kZXNjcmliZWRieVwiXSA9IGFyaWFEZXNjcmliZWRCeTtcbiAgICAgICAgICAgIGlmIChhcmlhSW52YWxpZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGFyaWFQcm9wc1tcImFyaWEtaW52YWxpZFwiXSA9IGFyaWFJbnZhbGlkO1xuICAgICAgICAgICAgaWYgKGFyaWFMYWJlbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGFyaWFQcm9wc1tcImFyaWEtbGFiZWxcIl0gPSBhcmlhTGFiZWw7XG4gICAgICAgICAgICBpZiAoYXJpYUxhYmVsbGVkQnkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBhcmlhUHJvcHNbXCJhcmlhLWxhYmVsbGVkYnlcIl0gPSBhcmlhTGFiZWxsZWRCeTtcbiAgICAgICAgICAgIGlmIChhcmlhUmVxdWlyZWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBhcmlhUHJvcHNbXCJhcmlhLXJlcXVpcmVkXCJdID0gYXJpYVJlcXVpcmVkO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjdXN0b21JbnB1dCwgX2Fzc2lnbigoX2IgPSB7fSwgX2JbY3VzdG9tSW5wdXRSZWZdID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgIH0sIF9iLnZhbHVlID0gX3RoaXMuZ2V0SW5wdXRWYWx1ZSgpLCBfYi5vbkJsdXIgPSBfdGhpcy5oYW5kbGVCbHVyLCBfYi5vbkNoYW5nZSA9IF90aGlzLmhhbmRsZUNoYW5nZSwgX2Iub25DbGljayA9IF90aGlzLm9uSW5wdXRDbGljaywgX2Iub25Gb2N1cyA9IF90aGlzLmhhbmRsZUZvY3VzLCBfYi5vbktleURvd24gPSBfdGhpcy5vbklucHV0S2V5RG93biwgX2IuaWQgPSBfdGhpcy5wcm9wcy5pZCwgX2IubmFtZSA9IF90aGlzLnByb3BzLm5hbWUsIF9iLmZvcm0gPSBfdGhpcy5wcm9wcy5mb3JtLCBfYi5hdXRvRm9jdXMgPSBfdGhpcy5wcm9wcy5hdXRvRm9jdXMsIF9iLnBsYWNlaG9sZGVyID0gX3RoaXMucHJvcHMucGxhY2Vob2xkZXJUZXh0LCBfYi5kaXNhYmxlZCA9IF90aGlzLnByb3BzLmRpc2FibGVkLCBfYi5hdXRvQ29tcGxldGUgPSBfdGhpcy5wcm9wcy5hdXRvQ29tcGxldGUsIF9iLmNsYXNzTmFtZSA9IGNsc3goY3VzdG9tSW5wdXQucHJvcHMuY2xhc3NOYW1lLCBjbGFzc05hbWUpLCBfYi50aXRsZSA9IF90aGlzLnByb3BzLnRpdGxlLCBfYi5yZWFkT25seSA9IF90aGlzLnByb3BzLnJlYWRPbmx5LCBfYi5yZXF1aXJlZCA9IF90aGlzLnByb3BzLnJlcXVpcmVkLCBfYi50YWJJbmRleCA9IF90aGlzLnByb3BzLnRhYkluZGV4LCBfYiksIGFyaWFQcm9wcykpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDbGVhckJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBpc0NsZWFyYWJsZSA9IF9hLmlzQ2xlYXJhYmxlLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBzZWxlY3RlZCA9IF9hLnNlbGVjdGVkLCBzdGFydERhdGUgPSBfYS5zdGFydERhdGUsIGVuZERhdGUgPSBfYS5lbmREYXRlLCBjbGVhckJ1dHRvblRpdGxlID0gX2EuY2xlYXJCdXR0b25UaXRsZSwgX2IgPSBfYS5jbGVhckJ1dHRvbkNsYXNzTmFtZSwgY2xlYXJCdXR0b25DbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLCBfYyA9IF9hLmFyaWFMYWJlbENsb3NlLCBhcmlhTGFiZWxDbG9zZSA9IF9jID09PSB2b2lkIDAgPyBcIkNsb3NlXCIgOiBfYywgc2VsZWN0ZWREYXRlcyA9IF9hLnNlbGVjdGVkRGF0ZXMsIHJlYWRPbmx5ID0gX2EucmVhZE9ubHk7XG4gICAgICAgICAgICBpZiAoaXNDbGVhcmFibGUgJiZcbiAgICAgICAgICAgICAgICAhcmVhZE9ubHkgJiZcbiAgICAgICAgICAgICAgICAoc2VsZWN0ZWQgIT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgIT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlICE9IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGVkRGF0ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWREYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWREYXRlcy5sZW5ndGgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX2Nsb3NlLWljb25cIiwgY2xlYXJCdXR0b25DbGFzc05hbWUsIHsgXCJyZWFjdC1kYXRlcGlja2VyX19jbG9zZS1pY29uLS1kaXNhYmxlZFwiOiBkaXNhYmxlZCB9KSwgZGlzYWJsZWQ6IGRpc2FibGVkLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ2xvc2UsIG9uQ2xpY2s6IF90aGlzLm9uQ2xlYXJDbGljaywgdGl0bGU6IGNsZWFyQnV0dG9uVGl0bGUsIHRhYkluZGV4OiAtMSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5jYWxjSW5pdGlhbFN0YXRlKCk7XG4gICAgICAgIF90aGlzLnByZXZlbnRGb2N1c1RpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVQaWNrZXIsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbG93U2FtZURheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogXCJNTS9kZC95eXl5XCIsXG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdENhbGVuZGFyOiBcIkxMTEwgeXl5eVwiLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25Nb2RlOiBcInNjcm9sbFwiLFxuICAgICAgICAgICAgICAgIHByZXZlbnRPcGVuT25Gb2N1czogZmFsc2UsXG4gICAgICAgICAgICAgICAgbW9udGhzU2hvd246IDEsXG4gICAgICAgICAgICAgICAgb3V0c2lkZUNsaWNrSWdub3JlQ2xhc3M6IE9VVFNJREVfQ0xJQ0tfSUdOT1JFX0NMQVNTLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByYW5nZVNlcGFyYXRvcjogREFURV9SQU5HRV9TRVBBUkFUT1IsXG4gICAgICAgICAgICAgICAgd2l0aFBvcnRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsZWN0c0Rpc2FibGVkRGF5c0luUmFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3VsZENsb3NlT25TZWxlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvd1RpbWVTZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dUaW1lSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dQcmV2aW91c01vbnRoczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd01vbnRoWWVhclBpY2tlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0Z1bGxNb250aFllYXJQaWNrZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dGb3VyQ29sdW1uTW9udGhZZWFyUGlja2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93WWVhclBpY2tlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1F1YXJ0ZXJZZWFyUGlja2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93V2Vla1BpY2tlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RyaWN0UGFyc2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3dhcFJhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aW1lSW50ZXJ2YWxzOiAzMCxcbiAgICAgICAgICAgICAgICB0aW1lQ2FwdGlvbjogXCJUaW1lXCIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNNb250aEFyaWFMYWJlbDogXCJQcmV2aW91cyBNb250aFwiLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzTW9udGhCdXR0b25MYWJlbDogXCJQcmV2aW91cyBNb250aFwiLFxuICAgICAgICAgICAgICAgIG5leHRNb250aEFyaWFMYWJlbDogXCJOZXh0IE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoQnV0dG9uTGFiZWw6IFwiTmV4dCBNb250aFwiLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzWWVhckFyaWFMYWJlbDogXCJQcmV2aW91cyBZZWFyXCIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNZZWFyQnV0dG9uTGFiZWw6IFwiUHJldmlvdXMgWWVhclwiLFxuICAgICAgICAgICAgICAgIG5leHRZZWFyQXJpYUxhYmVsOiBcIk5leHQgWWVhclwiLFxuICAgICAgICAgICAgICAgIG5leHRZZWFyQnV0dG9uTGFiZWw6IFwiTmV4dCBZZWFyXCIsXG4gICAgICAgICAgICAgICAgdGltZUlucHV0TGFiZWw6IFwiVGltZVwiLFxuICAgICAgICAgICAgICAgIGVuYWJsZVRhYkxvb3A6IHRydWUsXG4gICAgICAgICAgICAgICAgeWVhckl0ZW1OdW1iZXI6IERFRkFVTFRfWUVBUl9JVEVNX05VTUJFUixcbiAgICAgICAgICAgICAgICBmb2N1c1NlbGVjdGVkTW9udGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dQb3BwZXJBcnJvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGNsdWRlU2Nyb2xsYmFyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGN1c3RvbVRpbWVJbnB1dDogbnVsbCxcbiAgICAgICAgICAgICAgICBjYWxlbmRhclN0YXJ0RGF5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2FsZW5kYXJPbkljb25DbGljazogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXNlUG9pbnRlckV2ZW50OiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEYXRlUGlja2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuc2V0SGlkZGVuU3RhdGVPblZpc2liaWxpdHlIaWRkZW4pO1xuICAgIH07XG4gICAgRGF0ZVBpY2tlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gVXBkYXRlIHByZVNlbGVjdGlvbiB3aGVuIHNlbGVjdGVkL3N0YXJ0RGF0ZSBwcm9wIGNoYW5nZXMgdG8gYSBkaWZmZXJlbnQgbW9udGgveWVhci5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBjYWxlbmRhciB2aWV3IHVwZGF0ZXMgd2hlbiBkYXRlcyBhcmUgcHJvZ3JhbW1hdGljYWxseSBzZXRcbiAgICAgICAgLy8gKGUuZy4sIHZpYSBcIlRvZGF5XCIgb3IgXCJUaGlzIFdlZWtcIiBidXR0b25zKS4gKEZpeCBmb3IgIzMzNjcpXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdHNSYW5nZSAmJlxuICAgICAgICAgICAgaGFzUHJlU2VsZWN0aW9uQ2hhbmdlZChwcmV2UHJvcHMuc3RhcnREYXRlLCB0aGlzLnByb3BzLnN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJlU2VsZWN0aW9uKHRoaXMucHJvcHMuc3RhcnREYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNQcmVTZWxlY3Rpb25DaGFuZ2VkKHByZXZQcm9wcy5zZWxlY3RlZCwgdGhpcy5wcm9wcy5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJlU2VsZWN0aW9uKHRoaXMucHJvcHMuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1vbnRoU2VsZWN0ZWRJbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBwcmV2UHJvcHMubW9udGhzU2hvd24gIT09IHRoaXMucHJvcHMubW9udGhzU2hvd24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb250aFNlbGVjdGVkSW46IDAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgbW9udGhTZWxlY3RlZEluIHdoZW4gY2FsZW5kYXIgb3BlbnMgZm9yIHJhbmdlIHNlbGVjdGlvblxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgc3RhcnREYXRlIGlzIGRpc3BsYXllZCBhcyB0aGUgZmlyc3QgbW9udGggd2hlbiByZW9wZW5pbmdcbiAgICAgICAgLy8gKEZpeCBmb3IgIzU5MzkpLCBidXQgd2UgZG9uJ3QgcmVzZXQgZHVyaW5nIGFjdGl2ZSBzZWxlY3Rpb24gdG8gYXZvaWRcbiAgICAgICAgLy8gdGhlIHZpZXcganVtcGluZyB3aGVuIGNsaWNraW5nIGRhdGVzIGluIHRoZSBzZWNvbmQgY2FsZW5kYXIgKEZpeCBmb3IgIzUyNzUpXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdHNSYW5nZSAmJlxuICAgICAgICAgICAgcHJldlN0YXRlLm9wZW4gPT09IGZhbHNlICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlLm9wZW4gPT09IHRydWUgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubW9udGhTZWxlY3RlZEluICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgbW9udGhTZWxlY3RlZEluOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMuaGlnaGxpZ2h0RGF0ZXMgIT09IHRoaXMucHJvcHMuaGlnaGxpZ2h0RGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodERhdGVzOiBnZXRIaWdoTGlnaHREYXlzTWFwKHRoaXMucHJvcHMuaGlnaGxpZ2h0RGF0ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2U3RhdGUuZm9jdXNlZCAmJlxuICAgICAgICAgICAgIWlzRXF1YWwocHJldlByb3BzLnNlbGVjdGVkLCB0aGlzLnByb3BzLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTdGF0ZS5vcGVuICE9PSB0aGlzLnN0YXRlLm9wZW4pIHtcbiAgICAgICAgICAgIGlmIChwcmV2U3RhdGUub3BlbiA9PT0gZmFsc2UgJiYgdGhpcy5zdGF0ZS5vcGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5wcm9wcykub25DYWxlbmRhck9wZW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2U3RhdGUub3BlbiA9PT0gdHJ1ZSAmJiB0aGlzLnN0YXRlLm9wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5wcm9wcykub25DYWxlbmRhckNsb3NlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGVQaWNrZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyUHJldmVudEZvY3VzVGltZW91dCgpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdGhpcy5zZXRIaWRkZW5TdGF0ZU9uVmlzaWJpbGl0eUhpZGRlbik7XG4gICAgfTtcbiAgICBEYXRlUGlja2VyLnByb3RvdHlwZS5yZW5kZXJJbnB1dENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgc2hvd0ljb24gPSBfYS5zaG93SWNvbiwgaWNvbiA9IF9hLmljb24sIGNhbGVuZGFySWNvbkNsYXNzbmFtZSA9IF9hLmNhbGVuZGFySWNvbkNsYXNzbmFtZSwgY2FsZW5kYXJJY29uQ2xhc3NOYW1lID0gX2EuY2FsZW5kYXJJY29uQ2xhc3NOYW1lLCB0b2dnbGVDYWxlbmRhck9uSWNvbkNsaWNrID0gX2EudG9nZ2xlQ2FsZW5kYXJPbkljb25DbGljaztcbiAgICAgICAgdmFyIG9wZW4gPSB0aGlzLnN0YXRlLm9wZW47XG4gICAgICAgIGlmIChjYWxlbmRhckljb25DbGFzc25hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImNhbGVuZGFySWNvbkNsYXNzbmFtZSBwcm9wcyBpcyBkZXByZWNhdGVkLiBzaG91bGQgdXNlIGNhbGVuZGFySWNvbkNsYXNzTmFtZSBwcm9wcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2lucHV0LWNvbnRhaW5lclwiLmNvbmNhdChzaG93SWNvbiA/IFwiIHJlYWN0LWRhdGVwaWNrZXJfX3ZpZXctY2FsZW5kYXItaWNvblwiIDogXCJcIikgfSxcbiAgICAgICAgICAgIHNob3dJY29uICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFySWNvbiwgX2Fzc2lnbih7IGljb246IGljb24sIGNsYXNzTmFtZTogY2xzeChjYWxlbmRhckljb25DbGFzc05hbWUsICFjYWxlbmRhckljb25DbGFzc05hbWUgJiYgY2FsZW5kYXJJY29uQ2xhc3NuYW1lLCBvcGVuICYmIFwicmVhY3QtZGF0ZXBpY2tlci1pZ25vcmUtb25jbGlja291dHNpZGVcIikgfSwgKHRvZ2dsZUNhbGVuZGFyT25JY29uQ2xpY2tcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogdGhpcy50b2dnbGVDYWxlbmRhcixcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBudWxsKSkpKSxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaXNSZW5kZXJBcmlhTGl2ZU1lc3NhZ2UgJiYgdGhpcy5yZW5kZXJBcmlhTGl2ZVJlZ2lvbigpLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRlSW5wdXQoKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2xlYXJCdXR0b24oKSkpO1xuICAgIH07XG4gICAgRGF0ZVBpY2tlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnJlbmRlckNhbGVuZGFyKCk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmlubGluZSlcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMud2l0aFBvcnRhbCkge1xuICAgICAgICAgICAgdmFyIHBvcnRhbENvbnRhaW5lciA9IHRoaXMuc3RhdGUub3BlbiA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFRhYkxvb3AsIHsgZW5hYmxlVGFiTG9vcDogdGhpcy5wcm9wcy5lbmFibGVUYWJMb29wIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19wb3J0YWxcIiwgdGFiSW5kZXg6IC0xLCBvbktleURvd246IHRoaXMub25Qb3J0YWxLZXlEb3duIH0sIGNhbGVuZGFyKSkpIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm9wZW4gJiYgdGhpcy5wcm9wcy5wb3J0YWxJZCkge1xuICAgICAgICAgICAgICAgIHBvcnRhbENvbnRhaW5lciA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwgX2Fzc2lnbih7IHBvcnRhbElkOiB0aGlzLnByb3BzLnBvcnRhbElkIH0sIHRoaXMucHJvcHMpLCBwb3J0YWxDb250YWluZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySW5wdXRDb250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBwb3J0YWxDb250YWluZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wcGVyQ29tcG9uZW50LCBfYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5wb3BwZXJDbGFzc05hbWUsIGhpZGVQb3BwZXI6ICF0aGlzLmlzQ2FsZW5kYXJPcGVuKCksIHRhcmdldENvbXBvbmVudDogdGhpcy5yZW5kZXJJbnB1dENvbnRhaW5lcigpLCBwb3BwZXJDb21wb25lbnQ6IGNhbGVuZGFyLCBwb3BwZXJPbktleURvd246IHRoaXMub25Qb3BwZXJLZXlEb3duLCBzaG93QXJyb3c6IHRoaXMucHJvcHMuc2hvd1BvcHBlckFycm93LCBtb250aEhlYWRlclBvc2l0aW9uOiB0aGlzLnByb3BzLm1vbnRoSGVhZGVyUG9zaXRpb24gfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlUGlja2VyO1xufShDb21wb25lbnQpKTtcbnZhciBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9JTlBVVCA9IFwiaW5wdXRcIjtcbnZhciBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9OQVZJR0FURSA9IFwibmF2aWdhdGVcIjtcblxuZXhwb3J0IHsgQ2FsZW5kYXJDb250YWluZXIsIERhdGVQaWNrZXIsIERhdGVQaWNrZXIgYXMgZGVmYXVsdCwgZ2V0RGVmYXVsdExvY2FsZSwgcmVnaXN0ZXJMb2NhbGUsIHNldERlZmF1bHRMb2NhbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-datepicker/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-datepicker/dist/react-datepicker.css":
/*!*****************************************************************!*\
  !*** ./node_modules/react-datepicker/dist/react-datepicker.css ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"5368531fa70f\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9kaXN0L3JlYWN0LWRhdGVwaWNrZXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5uYXB1cm5hLWhvc3BpdGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRhdGVwaWNrZXIvZGlzdC9yZWFjdC1kYXRlcGlja2VyLmNzcz9lM2Y3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNTM2ODUzMWZhNzBmXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-datepicker/dist/react-datepicker.css\n");

/***/ })

};
;